{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LaserProcessing","text":""},{"location":"#overview","title":"Overview","text":"<p>This project focuses on processing data related to laser applications, encompassing data extraction, image segmentation, and physical modeling of laser-induced heat transfer in 3D space. It utilizes SQLite databases for data storage and employs numerical methods, potentially Physics-Informed Neural Networks (PINNs), to simulate and analyze laser interactions with materials.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The project aims to provide tools for analyzing microscope images, extracting relevant data, performing segmentation on those images, and simulating the thermal effects of laser radiation within a three-dimensional environment. It appears designed for research or engineering applications involving laser material processing or characterization.</p>"},{"location":"PINN_3D_real_parms/","title":"PINN 3D Real Parameters","text":""},{"location":"PINN_3D_real_parms/#overview","title":"Overview","text":"<p>This module implements a physics-informed neural network (PINN) for simulating 3D laser heat transfer processes. It provides tools for configuring laser parameters, converting between dimensional and non-dimensional units, and visualizing simulation results. The module supports both pulsed and continuous laser modes and offers functionalities for training and saving/loading PINN models.</p>"},{"location":"PINN_3D_real_parms/#purpose","title":"Purpose","text":"<p>This module is designed for simulating and analyzing laser-induced heat transfer in 3D materials. It allows users to define laser source terms, solve the heat equation using a PINN, and visualize the resulting temperature distributions. The module provides functionalities for setting up simulations with different laser parameters, converting between physical and non-dimensional coordinates and temperatures, and analyzing the simulation results through various plots and animations. It is intended for research and engineering applications focused on laser material processing and characterization.</p>"},{"location":"PINN_3D_real_parms/conditions/","title":"Conditions","text":""},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.compute_centers","title":"<code>compute_centers(n, spacing, device)</code>","text":"<p>Computes the centers of a 3D grid with specified spacing.</p> <p>This method generates coordinates for the center of each point in a 3D grid. The grid is centered at the origin by adjusting the index range based on whether the grid size is odd or even. This allows for accurate representation of points in 3D space for subsequent calculations or simulations.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>The size of the grid along each dimension (integer).</p> required <code>spacing</code> <p>The distance between grid points (float).</p> required <code>device</code> <p>The device to use for tensor creation (e.g., 'cpu', 'cuda').</p> required <p>Returns:</p> Type Description <p>A list of torch.Tensor objects, where each tensor contains the</p> <p>(x, y, z) coordinates of a grid center.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def compute_centers(n, spacing, device):\n    \"\"\"\n    Computes the centers of a 3D grid with specified spacing.\n\n    This method generates coordinates for the center of each point in a 3D grid.\n    The grid is centered at the origin by adjusting the index range based on\n    whether the grid size is odd or even. This allows for accurate representation\n    of points in 3D space for subsequent calculations or simulations.\n\n    Args:\n      n: The size of the grid along each dimension (integer).\n      spacing: The distance between grid points (float).\n      device: The device to use for tensor creation (e.g., 'cpu', 'cuda').\n\n    Returns:\n      A list of torch.Tensor objects, where each tensor contains the\n      (x, y, z) coordinates of a grid center.\n    \"\"\"\n    if n % 2 == 1:\n        idx = torch.arange(-(n//2), n//2 + 1, device=device, dtype=torch.float32)\n    else:\n        half = n // 2\n        idx = torch.arange(-half + 0.5, half, step=1.0, device=device, dtype=torch.float32)\n\n    centers = []\n    for i in idx:\n        for j in idx:\n            for k in idx:\n                centers.append(torch.tensor([i * spacing, j * spacing, k * spacing], device=device))\n\n    return centers\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.convert_to_physical_coords","title":"<code>convert_to_physical_coords(x_norm, y_norm, z_norm, t_norm)</code>","text":"<p>Converts normalized coordinates to physical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_norm</code> <code>float</code> <p>Normalized x-coordinate.</p> required <code>y_norm</code> <code>float</code> <p>Normalized y-coordinate.</p> required <code>z_norm</code> <code>float</code> <p>Normalized z-coordinate.</p> required <code>t_norm</code> <code>float</code> <p>Normalized time.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the physical x, y, z coordinates and time.    (x_phys, y_phys, z_phys, t_phys)</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def convert_to_physical_coords(x_norm, y_norm, z_norm, t_norm):\n    \"\"\"\n    Converts normalized coordinates to physical coordinates.\n\n    Args:\n        x_norm (float): Normalized x-coordinate.\n        y_norm (float): Normalized y-coordinate.\n        z_norm (float): Normalized z-coordinate.\n        t_norm (float): Normalized time.\n\n    Returns:\n        tuple: A tuple containing the physical x, y, z coordinates and time.\n               (x_phys, y_phys, z_phys, t_phys)\n    \"\"\"\n    x_phys = x_norm * config.CHARACTERISTIC_LENGTH\n    y_phys = y_norm * config.CHARACTERISTIC_LENGTH  \n    z_phys = z_norm * config.CHARACTERISTIC_LENGTH\n    t_phys = t_norm * config.CHARACTERISTIC_TIME\n    return x_phys, y_phys, z_phys, t_phys\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.convert_to_physical_temperature","title":"<code>convert_to_physical_temperature(T_norm)</code>","text":"<p>Converts a dimensionless temperature to a physical temperature.</p> <p>Parameters:</p> Name Type Description Default <code>T_norm</code> <code>float</code> <p>The dimensionless temperature value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The corresponding physical temperature.</p> <p>This method calculates the physical temperature based on a given dimensionless temperature, a base temperature, and a characteristic temperature. This conversion is essential for interpreting temperature values within the context of laser-material interaction simulations, allowing for meaningful analysis of thermal behavior.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def convert_to_physical_temperature(T_norm):\n    \"\"\"\n    Converts a dimensionless temperature to a physical temperature.\n\n    Args:\n        T_norm (float): The dimensionless temperature value.\n\n    Returns:\n        float: The corresponding physical temperature.\n\n    This method calculates the physical temperature based on a given dimensionless temperature, a base temperature, and a characteristic temperature. This conversion is essential for interpreting temperature values within the context of laser-material interaction simulations, allowing for meaningful analysis of thermal behavior.\n    \"\"\"\n    return config.INITIAL_TEMPERATURE + T_norm * config.CHARACTERISTIC_TEMPERATURE\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.get_laser_parameters_for_mode","title":"<code>get_laser_parameters_for_mode(laser_mode=None)</code>","text":"<p>Returns the laser parameters for a specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>laser_mode</code> <code>str</code> <p>The desired laser mode (\"continuous\" or \"pulsed\").                           If None, the default mode from the configuration is used. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the laser parameters for the given mode.    The dictionary includes parameters like mode, amplitude, pulse characteristics,    beam characteristics, peak power, and a descriptive string.    The parameters are sourced from the project's configuration.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def get_laser_parameters_for_mode(laser_mode=None):\n    \"\"\"\n    Returns the laser parameters for a specified mode.\n\n    Args:\n        laser_mode (str, optional): The desired laser mode (\"continuous\" or \"pulsed\"). \n                                     If None, the default mode from the configuration is used. Defaults to None.\n\n    Returns:\n        dict: A dictionary containing the laser parameters for the given mode. \n              The dictionary includes parameters like mode, amplitude, pulse characteristics, \n              beam characteristics, peak power, and a descriptive string. \n              The parameters are sourced from the project's configuration.\n    \"\"\"\n    if laser_mode is None:\n        laser_mode = config.LASER_MODE\n\n    if laser_mode == \"continuous\":\n        return {\n            \"mode\": \"continuous\",\n            \"amplitude\": config.LASER_AMPLITUDE,\n            \"pulse_sigma\": config.LASER_PULSE_SIGMA_NORM,\n            \"pulse_period\": config.LASER_PULSE_PERIOD_NORM,\n            \"beam_sigma\": config.LASER_SIGMA_NORM,\n            \"peak_power\": config.LASER_CONTINUOUS_POWER,\n            \"description\": \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c\"\n        }\n    else:\n        return {\n            \"mode\": \"pulsed\",\n            \"amplitude\": config.LASER_AMPLITUDE,\n            \"pulse_sigma\": config.LASER_PULSE_SIGMA_NORM,\n            \"pulse_period\": config.LASER_PULSE_PERIOD_NORM,\n            \"beam_sigma\": config.LASER_SIGMA_NORM,\n            \"num_pulses\": config.NUM_PULSES,\n            \"peak_power\": config.LASER_PEAK_POWER,\n            \"description\": f\"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c: {config.NUM_PULSES} \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\"\n        }\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.get_physical_extent","title":"<code>get_physical_extent(x_norm_range, y_norm_range, z_norm_range)</code>","text":"<p>\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438.</p> <p>Parameters:</p> Name Type Description Default <code>x_norm_range</code> <code>tuple</code> <p>Normalized range of x-coordinates.</p> required <code>y_norm_range</code> <code>tuple</code> <p>Normalized range of y-coordinates.</p> required <code>z_norm_range</code> <code>tuple</code> <p>Normalized range of z-coordinates.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the physical extents for x, y, and z dimensions, represented as tuples of (min, max) values in micrometers.</p> <p>The method converts normalized coordinates to physical dimensions based on a characteristic length, enabling accurate representation of the simulated or measured space. This conversion is crucial for relating the simulation results to real-world scales and for proper visualization of the data.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def get_physical_extent(x_norm_range, y_norm_range, z_norm_range):\n    \"\"\"\n    \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438.\n\n    Args:\n        x_norm_range (tuple): Normalized range of x-coordinates.\n        y_norm_range (tuple): Normalized range of y-coordinates.\n        z_norm_range (tuple): Normalized range of z-coordinates.\n\n    Returns:\n        tuple: A tuple containing the physical extents for x, y, and z dimensions, represented as tuples of (min, max) values in micrometers.\n\n    The method converts normalized coordinates to physical dimensions based on a characteristic length, enabling accurate representation of the simulated or measured space. This conversion is crucial for relating the simulation results to real-world scales and for proper visualization of the data.\n    \"\"\"\n    x_phys_min = x_norm_range[0] * config.CHARACTERISTIC_LENGTH * 1e6  # \u0432 \u043c\u043a\u043c\n    x_phys_max = x_norm_range[1] * config.CHARACTERISTIC_LENGTH * 1e6\n    y_phys_min = y_norm_range[0] * config.CHARACTERISTIC_LENGTH * 1e6\n    y_phys_max = y_norm_range[1] * config.CHARACTERISTIC_LENGTH * 1e6\n    z_phys_min = z_norm_range[0] * config.CHARACTERISTIC_LENGTH * 1e6\n    z_phys_max = z_norm_range[1] * config.CHARACTERISTIC_LENGTH * 1e6\n\n    return (x_phys_min, x_phys_max), (y_phys_min, y_phys_max), (z_phys_min, z_phys_max)\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.initial_gaussian","title":"<code>initial_gaussian(x_tensor, y_tensor, z_tensor, t0=1.0)</code>","text":"<p>Initializes a Gaussian distribution as the initial condition for simulating heat distribution.</p> <p>Parameters:</p> Name Type Description Default <code>x_tensor</code> <code>Tensor</code> <p>Tensor representing the x-coordinates of the spatial domain.</p> required <code>y_tensor</code> <code>Tensor</code> <p>Tensor representing the y-coordinates of the spatial domain.</p> required <code>z_tensor</code> <code>Tensor</code> <p>Tensor representing the z-coordinates of the spatial domain.</p> required <code>t0</code> <code>float</code> <p>Initial amplitude of the Gaussian. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <p>torch.Tensor: A tensor representing the initial heat distribution, modeled as a sum of Gaussian functions.</p> <p>This method creates an initial heat distribution by placing Gaussian 'hotspots' at several points in space. These hotspots serve as the starting point for simulating how heat diffuses through the material when exposed to a laser. The positions of these hotspots are determined by <code>compute_centers</code>, and their initial intensity is defined by <code>t0</code> and <code>config.SIGMA0</code>.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def initial_gaussian(x_tensor, y_tensor, z_tensor, t0=1.0):\n    \"\"\"\n    Initializes a Gaussian distribution as the initial condition for simulating heat distribution.\n\n    Args:\n        x_tensor (torch.Tensor): Tensor representing the x-coordinates of the spatial domain.\n        y_tensor (torch.Tensor): Tensor representing the y-coordinates of the spatial domain.\n        z_tensor (torch.Tensor): Tensor representing the z-coordinates of the spatial domain.\n        t0 (float, optional): Initial amplitude of the Gaussian. Defaults to 1.0.\n\n    Returns:\n        torch.Tensor: A tensor representing the initial heat distribution, modeled as a sum of Gaussian functions.\n\n    This method creates an initial heat distribution by placing Gaussian 'hotspots' at several points in space. These hotspots serve as the starting point for simulating how heat diffuses through the material when exposed to a laser. The positions of these hotspots are determined by `compute_centers`, and their initial intensity is defined by `t0` and `config.SIGMA0`.\n    \"\"\"\n    centers = compute_centers(config.NUM_GAUSSIANS, config.GAUSSIAN_SPACING, x_tensor.device)\n    gaussians = []\n    for c in centers:\n        r_squared = (x_tensor - c[0])**2 + (y_tensor - c[1])**2 + (z_tensor - c[2])**2\n        gaussians.append(t0 * torch.exp(-r_squared / (2 * config.SIGMA0**2)))\n\n    return sum(gaussians)\n</code></pre>"},{"location":"PINN_3D_real_parms/conditions/#PINN_3D_real_parms.conditions.laser_source_term","title":"<code>laser_source_term(x_tensor, y_tensor, z_tensor, t_tensor, amplitude=None, pulse_sigma=None, pulse_period=None, beam_sigma=None, laser_mode=None)</code>","text":"<p>\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0442\u0435\u043f\u043b\u0430 \u0432 \u0431\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0445 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u0445. \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u043b\u0430, \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c\u043e\u0433\u043e \u043b\u0430\u0437\u0435\u0440\u043e\u043c, \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435 \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0434\u0432\u0430 \u0440\u0435\u0436\u0438\u043c\u0430: \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 (pulsed) \u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 (continuous).</p> <p>Parameters:</p> Name Type Description Default <code>x_tensor</code> <code>Tensor</code> <p>\u0422\u0435\u043d\u0437\u043e\u0440 x-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.</p> required <code>y_tensor</code> <code>Tensor</code> <p>\u0422\u0435\u043d\u0437\u043e\u0440 y-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.</p> required <code>z_tensor</code> <code>Tensor</code> <p>\u0422\u0435\u043d\u0437\u043e\u0440 z-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.</p> required <code>t_tensor</code> <code>Tensor</code> <p>\u0422\u0435\u043d\u0437\u043e\u0440 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.</p> required <code>amplitude</code> <code>float</code> <p>\u0410\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.</p> <code>None</code> <code>pulse_sigma</code> <code>float</code> <p>\u0428\u0438\u0440\u0438\u043d\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.</p> <code>None</code> <code>pulse_period</code> <code>float</code> <p>\u041f\u0435\u0440\u0438\u043e\u0434 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.</p> <code>None</code> <code>beam_sigma</code> <code>float</code> <p>\u0428\u0438\u0440\u0438\u043d\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.</p> <code>None</code> <code>laser_mode</code> <code>str</code> <p>\u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430 (\"pulsed\" \u0438\u043b\u0438 \"continuous\"). \u0415\u0441\u043b\u0438 None, \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.</p> <code>None</code> <p>Returns:</p> Type Description <p>torch.Tensor: \u0422\u0435\u043d\u0437\u043e\u0440, \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0442\u0435\u043f\u043b\u0430.</p> Source code in <code>PINN_3D_real_parms/conditions.py</code> <pre><code>def laser_source_term(x_tensor, y_tensor, z_tensor, t_tensor, \n                     amplitude=None,\n                     pulse_sigma=None,\n                     pulse_period=None,\n                     beam_sigma=None,\n                     laser_mode=None):\n    \"\"\"\n    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0442\u0435\u043f\u043b\u0430 \u0432 \u0431\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0445 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u0445.\n    \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u043b\u0430, \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c\u043e\u0433\u043e \u043b\u0430\u0437\u0435\u0440\u043e\u043c, \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435 \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.\n    \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0434\u0432\u0430 \u0440\u0435\u0436\u0438\u043c\u0430: \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 (pulsed) \u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 (continuous).\n\n    Args:\n        x_tensor (torch.Tensor): \u0422\u0435\u043d\u0437\u043e\u0440 x-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.\n        y_tensor (torch.Tensor): \u0422\u0435\u043d\u0437\u043e\u0440 y-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.\n        z_tensor (torch.Tensor): \u0422\u0435\u043d\u0437\u043e\u0440 z-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.\n        t_tensor (torch.Tensor): \u0422\u0435\u043d\u0437\u043e\u0440 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.\n        amplitude (float, optional): \u0410\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.\n        pulse_sigma (float, optional): \u0428\u0438\u0440\u0438\u043d\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.\n        pulse_period (float, optional): \u041f\u0435\u0440\u0438\u043e\u0434 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.\n        beam_sigma (float, optional): \u0428\u0438\u0440\u0438\u043d\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.\n        laser_mode (str, optional): \u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430 (\"pulsed\" \u0438\u043b\u0438 \"continuous\"). \u0415\u0441\u043b\u0438 None, \u0431\u0435\u0440\u0435\u0442\u0441\u044f \u0438\u0437 config.\n\n    Returns:\n        torch.Tensor: \u0422\u0435\u043d\u0437\u043e\u0440, \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0439 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0442\u0435\u043f\u043b\u0430.\n    \"\"\"\n    if laser_mode is None:\n        laser_mode = config.LASER_MODE\n\n    # \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0435\u0441\u043b\u0438 \u043d\u0435 \u0443\u043a\u0430\u0437\u0430\u043d\u044b\n    if amplitude is None:\n        amplitude = config.LASER_AMPLITUDE\n    if pulse_sigma is None:\n        pulse_sigma = config.LASER_PULSE_SIGMA_NORM\n    if pulse_period is None:\n        pulse_period = config.LASER_PULSE_PERIOD_NORM\n    if beam_sigma is None:\n        beam_sigma = config.LASER_SIGMA_NORM\n\n    # \u041f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 - \u0421\u0422\u0410\u0422\u0418\u0427\u041d\u042b\u0419 \u043f\u0443\u0447\u043e\u043a \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 (0,0)\n    r2 = x_tensor**2 + y_tensor**2  # \u0446\u0435\u043d\u0442\u0440 \u0432\u0441\u0435\u0433\u0434\u0430 \u0432 (0,0)\n    spatial_dist = amplitude * torch.exp(-r2 / (beam_sigma**2))\n\n    # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0435\u0436\u0438\u043c\u0430\n    if laser_mode == \"continuous\":\n        # \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c - \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u0439 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\n        temporal_dist = torch.ones_like(t_tensor)\n    else:\n        # \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c - \u0433\u0430\u0443\u0441\u0441\u043e\u0432\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b\n        if pulse_period &gt; 0:\n            t_mod = torch.fmod(t_tensor, pulse_period)\n        else:\n            t_mod = t_tensor\n        pulse_center = pulse_period / 2.0 if pulse_period &gt; 0 else 0.5\n        temporal_dist = torch.exp(-(t_mod - pulse_center)**2 / (2 * pulse_sigma**2))\n\n    # \u0413\u043b\u0443\u0431\u0438\u043d\u043d\u043e\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 (\u044d\u043a\u0441\u043f\u043e\u043d\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u0435 \u043f\u043e \u0411\u0443\u0433\u0435\u0440\u0443-\u041b\u0430\u043c\u0431\u0435\u0440\u0442\u0443)\n    alpha_norm = config.MATERIAL_ABSORPTION * config.CHARACTERISTIC_LENGTH\n    z_dist = torch.exp(-alpha_norm * z_tensor)\n\n    source = spatial_dist * temporal_dist * z_dist\n\n    return source\n</code></pre>"},{"location":"PINN_3D_real_parms/config/","title":"Config","text":""},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig","title":"<code>LaserConfig</code>","text":"<p>\u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>class LaserConfig:\n    \"\"\"\n    \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430\n    \"\"\"\n\n\n    def __init__(self, config_file=None):\n        \"\"\"\n        \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.\n\n        \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f, \n        \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432.\n        \u0415\u0441\u043b\u0438 \u0444\u0430\u0439\u043b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043d\u0435 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.\n\n        Args:\n            config_file (str, optional): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n        self.default_config = {\n            # \u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430\n            \"laser\": {\n                \"wavelength\": 10.6e-6,          # \u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b [\u043c]\n                \"rep_rate\": 8000.0,             # \u0427\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f [\u0413\u0446]\n                \"pulse_duration\": 15e-6,        # \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430 FWHM [\u0441]\n                \"avg_power\": 10.0,              # \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c [\u0412\u0442]\n                \"beam_radius\": 62e-6,           # \u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430 [\u043c]\n                \"scan_velocity\": 0.06,          # \u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f [\u043c/\u0441]\n                \"mode\": \"pulsed\",               # \u0420\u0435\u0436\u0438\u043c: \"pulsed\" \u0438\u043b\u0438 \"continuous\"\n                \"continuous_power\": 10.0,       # \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u043b\u0430\u0437\u0435\u0440\u0430 [\u0412\u0442]\n                \"num_pulses\": 8,                # \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 (\u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430)\n                \"simulation_time\": None         # \u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f [\u0441] (None - \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438)\n            },\n\n            # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n            \"material\": {\n                \"density\": 2200.0,              # \u041f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c [\u043a\u0433/\u043c^3]\n                \"specific_heat\": 670.0,         # \u0423\u0434\u0435\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043f\u043b\u043e\u0435\u043c\u043a\u043e\u0441\u0442\u044c [\u0414\u0436/(\u043a\u0433\u00b7\u041a)]\n                \"conductivity\": 1.4,            # \u0422\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u044c [\u0412\u0442/(\u043c\u00b7\u041a)]\n                \"absorption\": 5000.0,           # \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u044f [1/\u043c]\n                \"reflectivity\": 0.25,           # \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n                \"initial_temperature\": 300.0    # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 [K]\n            },\n\n            # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN\n            \"pinn\": {\n                \"num_gaussians\": 1,\n                \"gaussian_spacing\": 0.5,\n                \"sigma0\": 0.1,\n                \"laser_amplitude\": 1.0,\n                \"collocation_points\": {\"x\": 20, \"y\": 20, \"z\": 20, \"t\": 20},\n                \"visualization_points\": {\"x\": 30, \"y\": 30, \"z\": 30, \"t\": 20}\n            },\n\n            # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n            \"training\": {\n                \"num_epochs\": 1000,\n                \"learning_rate\": 1e-3,\n                \"device\": \"auto\",  # \"auto\", \"cpu\", \"cuda\", \"mps\"\n                \"loss_weights\": {\"pde\": 1.0, \"ic\": 1.0, \"bc\": 2.0}\n            }\n        }\n\n        # \u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0435\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d\n        if config_file and os.path.exists(config_file):\n            self.load_from_json(config_file)\n        else:\n            self.config = self.default_config.copy()\n\n        # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.calculate_derived_parameters()\n\n    def load_from_json(self, filepath):\n        \"\"\"\n        \u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 JSON \u0444\u0430\u0439\u043b\u0430.\n\n        Args:\n            filepath (str): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439.\n\n        Returns:\n            None: \u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 self.config, \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0448\u0438\u0431\u043a\u0438.\n\n        \u041c\u0435\u0442\u043e\u0434 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e JSON \u0444\u0430\u0439\u043b\u0430, \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u044f \u0435\u0435 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0433\u0438\u0431\u043a\u043e \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445, \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043e\u0434 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0438 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c \u0441 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u043e\u0439 \u0444\u0430\u0439\u043b\u0430. \u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.\n        \"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                loaded_config = json.load(f)\n\n            # \u0420\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e\n            self.config = self.deep_update(self.default_config.copy(), loaded_config)\n            print(f\"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u0430 \u0438\u0437 {filepath}\")\n\n        except Exception as e:\n            print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438\u0437 {filepath}: {e}\")\n            print(\"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\")\n            self.config = self.default_config.copy()\n\n        # \u041f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438\n        self.calculate_derived_parameters()\n\n    def deep_update(self, base_dict, update_dict):\n        \"\"\"\n        Recursively updates a dictionary by merging the contents of another dictionary into it. If both dictionaries have a common key with dictionary values, the function recursively calls itself to merge the nested dictionaries. Otherwise, the value from the update dictionary overwrites the value in the base dictionary. This ensures a deep merge of dictionary structures.\n        \"\"\"\n        for key, value in update_dict.items():\n            if key in base_dict and isinstance(base_dict[key], dict) and isinstance(value, dict):\n                base_dict[key] = self.deep_update(base_dict[key], value)\n            else:\n                base_dict[key] = value\n        return base_dict\n\n    def save_to_json(self, filepath):\n        \"\"\"\n        \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0432 JSON \u0444\u0430\u0439\u043b.\n\n        Args:\n            filepath (str): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f.\n\n        Returns:\n            None\n\n        This method persists the configuration data to a JSON file, ensuring that settings and parameters are saved for later use or to maintain consistency across sessions. It handles potential errors during file writing and provides feedback to the user on success or failure.\n        \"\"\"\n        try:\n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(self.config, f, indent=2, ensure_ascii=False, default=str)\n            print(f\"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u0432 {filepath}\")\n        except Exception as e:\n            print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {e}\")\n\n    def calculate_derived_parameters(self):\n        \"\"\"\n        \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0438 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432.\n\n        \u042d\u0442\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0442 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c, \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430, \u0447\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f), \u0442\u0435\u043f\u043b\u043e\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b \u0434\u043b\u0438\u043d\u044b \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043d\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438.  \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0437\u0430\u0432\u0438\u0441\u044f\u0442 \u043e\u0442 \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0438\u043b\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439) \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u043c\u0443 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0442\u0435\u043f\u043b\u043e\u043f\u0435\u0440\u0435\u043d\u043e\u0441\u0430.\n\n        Args:\n            self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n\n        Returns:\n            None. \u041c\u0435\u0442\u043e\u0434 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig.\n        \"\"\"\n        laser = self.config[\"laser\"]\n        material = self.config[\"material\"]\n\n        # \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0440\u0435\u0436\u0438\u043c\n        self.LASER_MODE = laser[\"mode\"]\n\n        # \u0412\u044b\u0431\u043e\u0440 \u0440\u0435\u0436\u0438\u043c\u0430\n        if self.LASER_MODE == \"continuous\":\n            # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0441\u0440\u0435\u0434\u043d\u044e\u044e \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u043a\u0430\u043a \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u0443\u044e\n            self.LASER_PEAK_POWER = laser[\"continuous_power\"]\n            self.LASER_PULSE_DURATION = 1e-6  # \u043c\u0430\u043b\u0430\u044f \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439\n            self.LASER_REP_RATE = 1.0  # \u0447\u0430\u0441\u0442\u043e\u0442\u0430 1 \u0413\u0446 \u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f\n            self.LASER_AVG_POWER = laser[\"continuous_power\"]\n        else:\n            # \u0414\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n            self.LASER_AVG_POWER = laser[\"avg_power\"]\n            self.LASER_REP_RATE = laser[\"rep_rate\"]\n            self.LASER_PULSE_DURATION = laser[\"pulse_duration\"]\n            self.LASER_PEAK_POWER = laser[\"avg_power\"] / (laser[\"rep_rate\"] * laser[\"pulse_duration\"])\n\n        # \u041e\u0431\u0449\u0438\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\n        self.LASER_PULSE_PERIOD = 1.0 / self.LASER_REP_RATE\n        self.LASER_DUTY_CYCLE = self.LASER_REP_RATE * self.LASER_PULSE_DURATION\n        self.LASER_PEAK_INTENSITY = (2 * self.LASER_PEAK_POWER) / (math.pi * laser[\"beam_radius\"]**2)\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0433\u0430\u0443\u0441\u0441\u043e\u0432\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n        self.LASER_PULSE_SIGMA = self.LASER_PULSE_DURATION / (2 * math.sqrt(2 * math.log(2)))\n\n        # \u0422\u0435\u043f\u043b\u043e\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.THERMAL_DIFFUSIVITY = material[\"conductivity\"] / (material[\"density\"] * material[\"specific_heat\"])\n\n        # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b\n        self.CHARACTERISTIC_LENGTH = laser[\"beam_radius\"]\n        self.CHARACTERISTIC_TIME = self.CHARACTERISTIC_LENGTH**2 / self.THERMAL_DIFFUSIVITY\n        self.CHARACTERISTIC_TEMPERATURE = (\n            (1 - material[\"reflectivity\"]) * \n            self.LASER_PEAK_INTENSITY * \n            material[\"absorption\"] * \n            self.CHARACTERISTIC_LENGTH**2 / \n            material[\"conductivity\"]\n        )\n\n        # \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.LASER_AMPLITUDE = self.config[\"pinn\"][\"laser_amplitude\"]\n        self.LASER_PULSE_DURATION_NORM = self.LASER_PULSE_DURATION / self.CHARACTERISTIC_TIME\n        self.LASER_PULSE_PERIOD_NORM = self.LASER_PULSE_PERIOD / self.CHARACTERISTIC_TIME\n        self.LASER_PULSE_SIGMA_NORM = self.LASER_PULSE_SIGMA / self.CHARACTERISTIC_TIME\n        self.LASER_SIGMA_NORM = 1.0\n\n        # \u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n        if laser[\"simulation_time\"] is not None:\n            # \u0415\u0441\u043b\u0438 \u0432\u0440\u0435\u043c\u044f \u0437\u0430\u0434\u0430\u043d\u043e \u044f\u0432\u043d\u043e\n            self.SIMULATION_TIME_PHYSICAL = laser[\"simulation_time\"]\n        else:\n            # \u0410\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0440\u0430\u0441\u0447\u0435\u0442\n            if self.LASER_MODE == \"pulsed\":\n                self.SIMULATION_TIME_PHYSICAL = laser[\"num_pulses\"] * self.LASER_PULSE_PERIOD\n                self.NUM_PULSES = laser[\"num_pulses\"]\n            else:\n                # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n                self.SIMULATION_TIME_PHYSICAL = self.CHARACTERISTIC_TIME\n                self.NUM_PULSES = 1\n\n        self.SIMULATION_TIME_NORM = self.SIMULATION_TIME_PHYSICAL / self.CHARACTERISTIC_TIME\n\n        # \u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\n        self.MATERIAL_DENSITY = material[\"density\"]\n        self.MATERIAL_SPECIFIC_HEAT = material[\"specific_heat\"]\n        self.MATERIAL_CONDUCTIVITY = material[\"conductivity\"]\n        self.MATERIAL_ABSORPTION = material[\"absorption\"]\n        self.MATERIAL_REFLECTIVITY = material[\"reflectivity\"]\n        self.INITIAL_TEMPERATURE = material[\"initial_temperature\"]\n\n        # PINN \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.NUM_GAUSSIANS = self.config[\"pinn\"][\"num_gaussians\"]\n        self.GAUSSIAN_SPACING = self.config[\"pinn\"][\"gaussian_spacing\"]\n        self.SIGMA0 = self.config[\"pinn\"][\"sigma0\"]\n\n        # \u0414\u0440\u0443\u0433\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u0439 \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u0438\n        self.LASER_WAVELENGTH = laser[\"wavelength\"]\n        self.LASER_BEAM_RADIUS = laser[\"beam_radius\"]\n        self.LASER_SCAN_VELOCITY = laser[\"scan_velocity\"]\n        self.LASER_CONTINUOUS_POWER = laser[\"continuous_power\"]\n\n        # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\n        self.update_globals()\n\n    def update_globals(self):\n        \"\"\"\n        Updates module-level variables with the current configuration values.\n\n        This method iterates through the non-private, non-callable attributes of the LaserConfig instance and makes them accessible as module-level variables. This allows external code to access the configuration parameters without directly referencing the LaserConfig object. Additionally, the entire LaserConfig object is exposed as 'CONFIG' within the module for complete configuration access.\n\n        Args:\n            self: The LaserConfig instance whose attributes are to be updated in the module scope.\n\n        Returns:\n            None\n        \"\"\"\n        import sys\n        module = sys.modules[__name__]\n\n        for attr_name in dir(self):\n            if not attr_name.startswith('_') and not callable(getattr(self, attr_name)):\n                attr_value = getattr(self, attr_name)\n                if not isinstance(attr_value, dict) and not isinstance(attr_value, list):\n                    setattr(module, attr_name, attr_value)\n\n        # \u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0441\u0430\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u043e\u043b\u043d\u043e\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n        setattr(module, 'CONFIG', self)\n\n    def print_summary(self):\n        \"\"\"\n        \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043c\u043e\u0434\u0435\u043b\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430.\n\n        Args:\n            self (LaserConfig): \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.\n\n        Returns:\n            None: \u041c\u0435\u0442\u043e\u0434 \u0432\u044b\u0432\u043e\u0434\u0438\u0442 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0438 \u043d\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0438\u043a\u0430\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.\n\n        \u041c\u0435\u0442\u043e\u0434 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0443\u0434\u043e\u0431\u043d\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0430 \u0432\u0441\u0435\u0445 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0431\u044b\u0441\u0442\u0440\u043e \u0443\u0431\u0435\u0434\u0438\u0442\u044c\u0441\u044f, \u0447\u0442\u043e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0434\u0430\u043d\u0430 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043f\u0435\u0440\u0435\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.\n        \"\"\"\n        print(\"=\" * 60)\n        print(\"\u041a\u041e\u041d\u0424\u0418\u0413\u0423\u0420\u0410\u0426\u0418\u042f \u041c\u041e\u0414\u0415\u041b\u0418 \u041b\u0410\u0417\u0415\u0420\u041d\u041e\u0413\u041e \u041d\u0410\u0413\u0420\u0415\u0412\u0410\")\n        print(\"=\" * 60)\n        print(f\"\u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430: {self.LASER_MODE.upper()}\")\n        print(f\"\u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b: \u043a\u0432\u0430\u0440\u0446 JS1\")\n        print(f\"\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {self.INITIAL_TEMPERATURE} K\")\n        print()\n\n        print(\"\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b:\")\n        print(f\"  \u0414\u043b\u0438\u043d\u0430: {self.CHARACTERISTIC_LENGTH*1e6:.2f} \u043c\u043a\u043c\")\n        print(f\"  \u0412\u0440\u0435\u043c\u044f: {self.CHARACTERISTIC_TIME*1e3:.2f} \u043c\u0441\")\n        print(f\"  \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {self.CHARACTERISTIC_TEMPERATURE:.1f} K\")\n        print()\n\n        if self.LASER_MODE == \"pulsed\":\n            print(\"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c:\")\n            print(f\"  \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_AVG_POWER} \u0412\u0442\")\n            print(f\"  \u0427\u0430\u0441\u0442\u043e\u0442\u0430: {self.LASER_REP_RATE:.0f} \u0413\u0446\")\n            print(f\"  \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430: {self.LASER_PULSE_DURATION*1e6:.1f} \u043c\u043a\u0441\")\n            print(f\"  \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432: {self.NUM_PULSES}\")\n            print(f\"  \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_POWER:.1f} \u0412\u0442\")\n            print(f\"  \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_INTENSITY/1e6:.1f} \u041c\u0412\u0442/\u043c\u00b2\")\n        else:\n            print(\"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c:\")\n            print(f\"  \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_CONTINUOUS_POWER} \u0412\u0442\")\n            print(f\"  \u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_INTENSITY/1e6:.1f} \u041c\u0412\u0442/\u043c\u00b2\")\n\n        print()\n        print(\"\u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f:\")\n        print(f\"  \u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435: {self.SIMULATION_TIME_PHYSICAL*1e6:.1f} \u043c\u043a\u0441\")\n        print(f\"  \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0435: {self.SIMULATION_TIME_NORM:.3f}\")\n        print()\n\n        print(\"\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN:\")\n        print(f\"  \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u0430\u044f \u0430\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u043b\u0430\u0437\u0435\u0440\u0430: {self.LASER_AMPLITUDE}\")\n        print(f\"  \u0422\u043e\u0447\u043a\u0438 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u0438: {self.config['pinn']['collocation_points']}\")\n        print(f\"  \u0422\u043e\u0447\u043a\u0438 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438: {self.config['pinn']['visualization_points']}\")\n        print(\"=\" * 60)\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.__init__","title":"<code>__init__(config_file=None)</code>","text":"<p>\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.</p> <p>\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f,  \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432. \u0415\u0441\u043b\u0438 \u0444\u0430\u0439\u043b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043d\u0435 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>\u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def __init__(self, config_file=None):\n    \"\"\"\n    \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.\n\n    \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f, \n    \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432.\n    \u0415\u0441\u043b\u0438 \u0444\u0430\u0439\u043b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043d\u0435 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.\n\n    Args:\n        config_file (str, optional): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n    self.default_config = {\n        # \u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430\n        \"laser\": {\n            \"wavelength\": 10.6e-6,          # \u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b [\u043c]\n            \"rep_rate\": 8000.0,             # \u0427\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f [\u0413\u0446]\n            \"pulse_duration\": 15e-6,        # \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430 FWHM [\u0441]\n            \"avg_power\": 10.0,              # \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c [\u0412\u0442]\n            \"beam_radius\": 62e-6,           # \u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430 [\u043c]\n            \"scan_velocity\": 0.06,          # \u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f [\u043c/\u0441]\n            \"mode\": \"pulsed\",               # \u0420\u0435\u0436\u0438\u043c: \"pulsed\" \u0438\u043b\u0438 \"continuous\"\n            \"continuous_power\": 10.0,       # \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u043b\u0430\u0437\u0435\u0440\u0430 [\u0412\u0442]\n            \"num_pulses\": 8,                # \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 (\u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430)\n            \"simulation_time\": None         # \u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f [\u0441] (None - \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438)\n        },\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n        \"material\": {\n            \"density\": 2200.0,              # \u041f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c [\u043a\u0433/\u043c^3]\n            \"specific_heat\": 670.0,         # \u0423\u0434\u0435\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043f\u043b\u043e\u0435\u043c\u043a\u043e\u0441\u0442\u044c [\u0414\u0436/(\u043a\u0433\u00b7\u041a)]\n            \"conductivity\": 1.4,            # \u0422\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u044c [\u0412\u0442/(\u043c\u00b7\u041a)]\n            \"absorption\": 5000.0,           # \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u044f [1/\u043c]\n            \"reflectivity\": 0.25,           # \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n            \"initial_temperature\": 300.0    # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 [K]\n        },\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN\n        \"pinn\": {\n            \"num_gaussians\": 1,\n            \"gaussian_spacing\": 0.5,\n            \"sigma0\": 0.1,\n            \"laser_amplitude\": 1.0,\n            \"collocation_points\": {\"x\": 20, \"y\": 20, \"z\": 20, \"t\": 20},\n            \"visualization_points\": {\"x\": 30, \"y\": 30, \"z\": 30, \"t\": 20}\n        },\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n        \"training\": {\n            \"num_epochs\": 1000,\n            \"learning_rate\": 1e-3,\n            \"device\": \"auto\",  # \"auto\", \"cpu\", \"cuda\", \"mps\"\n            \"loss_weights\": {\"pde\": 1.0, \"ic\": 1.0, \"bc\": 2.0}\n        }\n    }\n\n    # \u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0435\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d\n    if config_file and os.path.exists(config_file):\n        self.load_from_json(config_file)\n    else:\n        self.config = self.default_config.copy()\n\n    # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    self.calculate_derived_parameters()\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.calculate_derived_parameters","title":"<code>calculate_derived_parameters()</code>","text":"<p>\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0438 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432.</p> <p>\u042d\u0442\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0442 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c, \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430, \u0447\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f), \u0442\u0435\u043f\u043b\u043e\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b \u0434\u043b\u0438\u043d\u044b \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043d\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438.  \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0437\u0430\u0432\u0438\u0441\u044f\u0442 \u043e\u0442 \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0438\u043b\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439) \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u043c\u0443 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0442\u0435\u043f\u043b\u043e\u043f\u0435\u0440\u0435\u043d\u043e\u0441\u0430.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>\u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.</p> required <p>Returns:</p> Type Description <p>None. \u041c\u0435\u0442\u043e\u0434 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig.</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def calculate_derived_parameters(self):\n    \"\"\"\n    \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0438 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u0432.\n\n    \u042d\u0442\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043a\u043b\u044e\u0447\u0430\u044e\u0442 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c, \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430, \u0447\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f), \u0442\u0435\u043f\u043b\u043e\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b \u0434\u043b\u0438\u043d\u044b \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043d\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438.  \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0437\u0430\u0432\u0438\u0441\u044f\u0442 \u043e\u0442 \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430 (\u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0438\u043b\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439) \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u043c\u0443 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0442\u0435\u043f\u043b\u043e\u043f\u0435\u0440\u0435\u043d\u043e\u0441\u0430.\n\n    Args:\n        self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n\n    Returns:\n        None. \u041c\u0435\u0442\u043e\u0434 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig.\n    \"\"\"\n    laser = self.config[\"laser\"]\n    material = self.config[\"material\"]\n\n    # \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0440\u0435\u0436\u0438\u043c\n    self.LASER_MODE = laser[\"mode\"]\n\n    # \u0412\u044b\u0431\u043e\u0440 \u0440\u0435\u0436\u0438\u043c\u0430\n    if self.LASER_MODE == \"continuous\":\n        # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0441\u0440\u0435\u0434\u043d\u044e\u044e \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u043a\u0430\u043a \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u0443\u044e\n        self.LASER_PEAK_POWER = laser[\"continuous_power\"]\n        self.LASER_PULSE_DURATION = 1e-6  # \u043c\u0430\u043b\u0430\u044f \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439\n        self.LASER_REP_RATE = 1.0  # \u0447\u0430\u0441\u0442\u043e\u0442\u0430 1 \u0413\u0446 \u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f\n        self.LASER_AVG_POWER = laser[\"continuous_power\"]\n    else:\n        # \u0414\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.LASER_AVG_POWER = laser[\"avg_power\"]\n        self.LASER_REP_RATE = laser[\"rep_rate\"]\n        self.LASER_PULSE_DURATION = laser[\"pulse_duration\"]\n        self.LASER_PEAK_POWER = laser[\"avg_power\"] / (laser[\"rep_rate\"] * laser[\"pulse_duration\"])\n\n    # \u041e\u0431\u0449\u0438\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\n    self.LASER_PULSE_PERIOD = 1.0 / self.LASER_REP_RATE\n    self.LASER_DUTY_CYCLE = self.LASER_REP_RATE * self.LASER_PULSE_DURATION\n    self.LASER_PEAK_INTENSITY = (2 * self.LASER_PEAK_POWER) / (math.pi * laser[\"beam_radius\"]**2)\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0433\u0430\u0443\u0441\u0441\u043e\u0432\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n    self.LASER_PULSE_SIGMA = self.LASER_PULSE_DURATION / (2 * math.sqrt(2 * math.log(2)))\n\n    # \u0422\u0435\u043f\u043b\u043e\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    self.THERMAL_DIFFUSIVITY = material[\"conductivity\"] / (material[\"density\"] * material[\"specific_heat\"])\n\n    # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b\n    self.CHARACTERISTIC_LENGTH = laser[\"beam_radius\"]\n    self.CHARACTERISTIC_TIME = self.CHARACTERISTIC_LENGTH**2 / self.THERMAL_DIFFUSIVITY\n    self.CHARACTERISTIC_TEMPERATURE = (\n        (1 - material[\"reflectivity\"]) * \n        self.LASER_PEAK_INTENSITY * \n        material[\"absorption\"] * \n        self.CHARACTERISTIC_LENGTH**2 / \n        material[\"conductivity\"]\n    )\n\n    # \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    self.LASER_AMPLITUDE = self.config[\"pinn\"][\"laser_amplitude\"]\n    self.LASER_PULSE_DURATION_NORM = self.LASER_PULSE_DURATION / self.CHARACTERISTIC_TIME\n    self.LASER_PULSE_PERIOD_NORM = self.LASER_PULSE_PERIOD / self.CHARACTERISTIC_TIME\n    self.LASER_PULSE_SIGMA_NORM = self.LASER_PULSE_SIGMA / self.CHARACTERISTIC_TIME\n    self.LASER_SIGMA_NORM = 1.0\n\n    # \u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n    if laser[\"simulation_time\"] is not None:\n        # \u0415\u0441\u043b\u0438 \u0432\u0440\u0435\u043c\u044f \u0437\u0430\u0434\u0430\u043d\u043e \u044f\u0432\u043d\u043e\n        self.SIMULATION_TIME_PHYSICAL = laser[\"simulation_time\"]\n    else:\n        # \u0410\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0440\u0430\u0441\u0447\u0435\u0442\n        if self.LASER_MODE == \"pulsed\":\n            self.SIMULATION_TIME_PHYSICAL = laser[\"num_pulses\"] * self.LASER_PULSE_PERIOD\n            self.NUM_PULSES = laser[\"num_pulses\"]\n        else:\n            # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n            self.SIMULATION_TIME_PHYSICAL = self.CHARACTERISTIC_TIME\n            self.NUM_PULSES = 1\n\n    self.SIMULATION_TIME_NORM = self.SIMULATION_TIME_PHYSICAL / self.CHARACTERISTIC_TIME\n\n    # \u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\n    self.MATERIAL_DENSITY = material[\"density\"]\n    self.MATERIAL_SPECIFIC_HEAT = material[\"specific_heat\"]\n    self.MATERIAL_CONDUCTIVITY = material[\"conductivity\"]\n    self.MATERIAL_ABSORPTION = material[\"absorption\"]\n    self.MATERIAL_REFLECTIVITY = material[\"reflectivity\"]\n    self.INITIAL_TEMPERATURE = material[\"initial_temperature\"]\n\n    # PINN \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    self.NUM_GAUSSIANS = self.config[\"pinn\"][\"num_gaussians\"]\n    self.GAUSSIAN_SPACING = self.config[\"pinn\"][\"gaussian_spacing\"]\n    self.SIGMA0 = self.config[\"pinn\"][\"sigma0\"]\n\n    # \u0414\u0440\u0443\u0433\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u0439 \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u0438\n    self.LASER_WAVELENGTH = laser[\"wavelength\"]\n    self.LASER_BEAM_RADIUS = laser[\"beam_radius\"]\n    self.LASER_SCAN_VELOCITY = laser[\"scan_velocity\"]\n    self.LASER_CONTINUOUS_POWER = laser[\"continuous_power\"]\n\n    # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\n    self.update_globals()\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.deep_update","title":"<code>deep_update(base_dict, update_dict)</code>","text":"<p>Recursively updates a dictionary by merging the contents of another dictionary into it. If both dictionaries have a common key with dictionary values, the function recursively calls itself to merge the nested dictionaries. Otherwise, the value from the update dictionary overwrites the value in the base dictionary. This ensures a deep merge of dictionary structures.</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def deep_update(self, base_dict, update_dict):\n    \"\"\"\n    Recursively updates a dictionary by merging the contents of another dictionary into it. If both dictionaries have a common key with dictionary values, the function recursively calls itself to merge the nested dictionaries. Otherwise, the value from the update dictionary overwrites the value in the base dictionary. This ensures a deep merge of dictionary structures.\n    \"\"\"\n    for key, value in update_dict.items():\n        if key in base_dict and isinstance(base_dict[key], dict) and isinstance(value, dict):\n            base_dict[key] = self.deep_update(base_dict[key], value)\n        else:\n            base_dict[key] = value\n    return base_dict\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.load_from_json","title":"<code>load_from_json(filepath)</code>","text":"<p>\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 JSON \u0444\u0430\u0439\u043b\u0430.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>\u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>\u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 self.config, \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0448\u0438\u0431\u043a\u0438.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e JSON \u0444\u0430\u0439\u043b\u0430, \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u044f \u0435\u0435 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0433\u0438\u0431\u043a\u043e \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445, \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043e\u0434 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0438 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c \u0441 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u043e\u0439 \u0444\u0430\u0439\u043b\u0430. \u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def load_from_json(self, filepath):\n    \"\"\"\n    \u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 JSON \u0444\u0430\u0439\u043b\u0430.\n\n    Args:\n        filepath (str): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439.\n\n    Returns:\n        None: \u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0430\u0442\u0440\u0438\u0431\u0443\u0442 self.config, \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0448\u0438\u0431\u043a\u0438.\n\n    \u041c\u0435\u0442\u043e\u0434 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e JSON \u0444\u0430\u0439\u043b\u0430, \u043e\u0431\u044a\u0435\u0434\u0438\u043d\u044f\u044f \u0435\u0435 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0433\u0438\u0431\u043a\u043e \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445, \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043e\u0434 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0438 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c \u0441 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u043e\u0439 \u0444\u0430\u0439\u043b\u0430. \u041f\u043e\u0441\u043b\u0435 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.\n    \"\"\"\n    try:\n        with open(filepath, 'r', encoding='utf-8') as f:\n            loaded_config = json.load(f)\n\n        # \u0420\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e\n        self.config = self.deep_update(self.default_config.copy(), loaded_config)\n        print(f\"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u0430 \u0438\u0437 {filepath}\")\n\n    except Exception as e:\n        print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438\u0437 {filepath}: {e}\")\n        print(\"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\")\n        self.config = self.default_config.copy()\n\n    # \u041f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438\n    self.calculate_derived_parameters()\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.print_summary","title":"<code>print_summary()</code>","text":"<p>\u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043c\u043e\u0434\u0435\u043b\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>LaserConfig</code> <p>\u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>\u041c\u0435\u0442\u043e\u0434 \u0432\u044b\u0432\u043e\u0434\u0438\u0442 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0438 \u043d\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0438\u043a\u0430\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0443\u0434\u043e\u0431\u043d\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0430 \u0432\u0441\u0435\u0445 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0431\u044b\u0441\u0442\u0440\u043e \u0443\u0431\u0435\u0434\u0438\u0442\u044c\u0441\u044f, \u0447\u0442\u043e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0434\u0430\u043d\u0430 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043f\u0435\u0440\u0435\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def print_summary(self):\n    \"\"\"\n    \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043c\u043e\u0434\u0435\u043b\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430.\n\n    Args:\n        self (LaserConfig): \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfig, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438.\n\n    Returns:\n        None: \u041c\u0435\u0442\u043e\u0434 \u0432\u044b\u0432\u043e\u0434\u0438\u0442 \u0441\u0432\u043e\u0434\u043a\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0438 \u043d\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u0438\u043a\u0430\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.\n\n    \u041c\u0435\u0442\u043e\u0434 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0443\u0434\u043e\u0431\u043d\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0430 \u0432\u0441\u0435\u0445 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN. \u042d\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0431\u044b\u0441\u0442\u0440\u043e \u0443\u0431\u0435\u0434\u0438\u0442\u044c\u0441\u044f, \u0447\u0442\u043e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0437\u0430\u0434\u0430\u043d\u0430 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043f\u0435\u0440\u0435\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u043e\u043c \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"\u041a\u041e\u041d\u0424\u0418\u0413\u0423\u0420\u0410\u0426\u0418\u042f \u041c\u041e\u0414\u0415\u041b\u0418 \u041b\u0410\u0417\u0415\u0420\u041d\u041e\u0413\u041e \u041d\u0410\u0413\u0420\u0415\u0412\u0410\")\n    print(\"=\" * 60)\n    print(f\"\u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430: {self.LASER_MODE.upper()}\")\n    print(f\"\u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b: \u043a\u0432\u0430\u0440\u0446 JS1\")\n    print(f\"\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {self.INITIAL_TEMPERATURE} K\")\n    print()\n\n    print(\"\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b:\")\n    print(f\"  \u0414\u043b\u0438\u043d\u0430: {self.CHARACTERISTIC_LENGTH*1e6:.2f} \u043c\u043a\u043c\")\n    print(f\"  \u0412\u0440\u0435\u043c\u044f: {self.CHARACTERISTIC_TIME*1e3:.2f} \u043c\u0441\")\n    print(f\"  \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {self.CHARACTERISTIC_TEMPERATURE:.1f} K\")\n    print()\n\n    if self.LASER_MODE == \"pulsed\":\n        print(\"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c:\")\n        print(f\"  \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_AVG_POWER} \u0412\u0442\")\n        print(f\"  \u0427\u0430\u0441\u0442\u043e\u0442\u0430: {self.LASER_REP_RATE:.0f} \u0413\u0446\")\n        print(f\"  \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430: {self.LASER_PULSE_DURATION*1e6:.1f} \u043c\u043a\u0441\")\n        print(f\"  \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432: {self.NUM_PULSES}\")\n        print(f\"  \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_POWER:.1f} \u0412\u0442\")\n        print(f\"  \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_INTENSITY/1e6:.1f} \u041c\u0412\u0442/\u043c\u00b2\")\n    else:\n        print(\"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c:\")\n        print(f\"  \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {self.LASER_CONTINUOUS_POWER} \u0412\u0442\")\n        print(f\"  \u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {self.LASER_PEAK_INTENSITY/1e6:.1f} \u041c\u0412\u0442/\u043c\u00b2\")\n\n    print()\n    print(\"\u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f:\")\n    print(f\"  \u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435: {self.SIMULATION_TIME_PHYSICAL*1e6:.1f} \u043c\u043a\u0441\")\n    print(f\"  \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0435: {self.SIMULATION_TIME_NORM:.3f}\")\n    print()\n\n    print(\"\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN:\")\n    print(f\"  \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u0430\u044f \u0430\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u043b\u0430\u0437\u0435\u0440\u0430: {self.LASER_AMPLITUDE}\")\n    print(f\"  \u0422\u043e\u0447\u043a\u0438 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u0438: {self.config['pinn']['collocation_points']}\")\n    print(f\"  \u0422\u043e\u0447\u043a\u0438 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438: {self.config['pinn']['visualization_points']}\")\n    print(\"=\" * 60)\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.save_to_json","title":"<code>save_to_json(filepath)</code>","text":"<p>\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0432 JSON \u0444\u0430\u0439\u043b.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>\u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f.</p> required <p>Returns:</p> Type Description <p>None</p> <p>This method persists the configuration data to a JSON file, ensuring that settings and parameters are saved for later use or to maintain consistency across sessions. It handles potential errors during file writing and provides feedback to the user on success or failure.</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def save_to_json(self, filepath):\n    \"\"\"\n    \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0432 JSON \u0444\u0430\u0439\u043b.\n\n    Args:\n        filepath (str): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f.\n\n    Returns:\n        None\n\n    This method persists the configuration data to a JSON file, ensuring that settings and parameters are saved for later use or to maintain consistency across sessions. It handles potential errors during file writing and provides feedback to the user on success or failure.\n    \"\"\"\n    try:\n        with open(filepath, 'w', encoding='utf-8') as f:\n            json.dump(self.config, f, indent=2, ensure_ascii=False, default=str)\n        print(f\"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u0432 {filepath}\")\n    except Exception as e:\n        print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {e}\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.LaserConfig.update_globals","title":"<code>update_globals()</code>","text":"<p>Updates module-level variables with the current configuration values.</p> <p>This method iterates through the non-private, non-callable attributes of the LaserConfig instance and makes them accessible as module-level variables. This allows external code to access the configuration parameters without directly referencing the LaserConfig object. Additionally, the entire LaserConfig object is exposed as 'CONFIG' within the module for complete configuration access.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfig instance whose attributes are to be updated in the module scope.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def update_globals(self):\n    \"\"\"\n    Updates module-level variables with the current configuration values.\n\n    This method iterates through the non-private, non-callable attributes of the LaserConfig instance and makes them accessible as module-level variables. This allows external code to access the configuration parameters without directly referencing the LaserConfig object. Additionally, the entire LaserConfig object is exposed as 'CONFIG' within the module for complete configuration access.\n\n    Args:\n        self: The LaserConfig instance whose attributes are to be updated in the module scope.\n\n    Returns:\n        None\n    \"\"\"\n    import sys\n    module = sys.modules[__name__]\n\n    for attr_name in dir(self):\n        if not attr_name.startswith('_') and not callable(getattr(self, attr_name)):\n            attr_value = getattr(self, attr_name)\n            if not isinstance(attr_value, dict) and not isinstance(attr_value, list):\n                setattr(module, attr_name, attr_value)\n\n    # \u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0441\u0430\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u043e\u043b\u043d\u043e\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n    setattr(module, 'CONFIG', self)\n</code></pre>"},{"location":"PINN_3D_real_parms/config/#PINN_3D_real_parms.config.export_globals","title":"<code>export_globals()</code>","text":"<p>Expose configuration parameters as global variables for convenient access.</p> <p>This function iterates through the attributes of the <code>config_manager</code> object, identifying non-private, non-callable attributes that are not dictionaries or lists. These attributes are then added to the current module's global namespace, allowing them to be accessed directly.  Additionally, the <code>config_manager</code> object itself is exposed as 'CONFIG' for access to the complete configuration.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config.py</code> <pre><code>def export_globals():\n    \"\"\"\n    Expose configuration parameters as global variables for convenient access.\n\n    This function iterates through the attributes of the `config_manager` object,\n    identifying non-private, non-callable attributes that are not dictionaries or lists.\n    These attributes are then added to the current module's global namespace,\n    allowing them to be accessed directly.  Additionally, the `config_manager`\n    object itself is exposed as 'CONFIG' for access to the complete configuration.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    import sys\n    module = sys.modules[__name__]\n\n    for attr_name in dir(config_manager):\n        if not attr_name.startswith('_') and not callable(getattr(config_manager, attr_name)):\n            attr_value = getattr(config_manager, attr_name)\n            if not isinstance(attr_value, dict) and not isinstance(attr_value, list):\n                setattr(module, attr_name, attr_value)\n\n    # \u042d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0441\u0430\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u043e\u043b\u043d\u043e\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n    setattr(module, 'CONFIG', config_manager)\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/","title":"Config Gui Panel","text":""},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp","title":"<code>LaserConfigApp</code>","text":"<p>               Bases: <code>Parameterized</code></p> <p>\u041a\u043b\u0430\u0441\u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>class LaserConfigApp(param.Parameterized):\n    \"\"\"\n    \u041a\u043b\u0430\u0441\u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430\n    \"\"\"\n\n\n    # === \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b \u041b\u0410\u0417\u0415\u0420\u0410 ===\n    laser_mode = param.Selector(\n        objects=['pulsed', 'continuous'],\n        default='continuous',\n        label=\"\ud83d\udce1 \u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430\"\n    )\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    laser_wavelength = param.Number(\n        10.6e-6,\n        bounds=(0.1e-6, 100e-6),\n        label=\"\ud83d\udccf \u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b (\u043c)\"\n    )\n\n    laser_beam_radius = param.Number(\n        62e-6,\n        bounds=(1e-6, 500e-6),\n        label=\"\ud83c\udfaf \u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430 (\u043c)\"\n    )\n\n    laser_scan_velocity = param.Number(\n        0.06,\n        bounds=(0.0, 10.0),\n        label=\"\u26a1 \u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u043c/\u0441)\"\n    )\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n    laser_rep_rate = param.Number(\n        8000.0,\n        bounds=(1.0, 100000.0),\n        label=\"\u23f1\ufe0f \u0427\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u044f (\u0413\u0446)\"\n    )\n\n    laser_pulse_duration = param.Number(\n        15e-6,\n        bounds=(1e-9, 100e-6),\n        label=\"\u231b \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430 (\u0441)\"\n    )\n\n    laser_avg_power = param.Number(\n        10.0,\n        bounds=(0.1, 1000.0),\n        label=\"\u26a1 \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c (\u0412\u0442)\"\n    )\n\n    num_pulses = param.Integer(\n        8,\n        bounds=(1, 100),\n        label=\"\ud83d\udd22 \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\"\n    )\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n    laser_continuous_power = param.Number(\n        5.0,\n        bounds=(0.1, 1000.0),\n        label=\"\ud83d\udca1 \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u043b\u0430\u0437\u0435\u0440\u0430 (\u0412\u0442)\"\n    )\n\n    simulation_time = param.Number(\n        2e-3,\n        bounds=(1e-6, 10.0),\n        label=\"\u23f0 \u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u0441)\"\n    )\n\n    # === \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b \u041c\u0410\u0422\u0415\u0420\u0418\u0410\u041b\u0410 ===\n    material_density = param.Number(\n        2200.0,\n        bounds=(100.0, 10000.0),\n        label=\"\u2696\ufe0f \u041f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c (\u043a\u0433/\u043c\u00b3)\"\n    )\n\n    material_specific_heat = param.Number(\n        670.0,\n        bounds=(100.0, 5000.0),\n        label=\"\ud83d\udd25 \u0423\u0434\u0435\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043f\u043b\u043e\u0435\u043c\u043a\u043e\u0441\u0442\u044c (\u0414\u0436/(\u043a\u0433\u00b7\u041a))\"\n    )\n\n    material_conductivity = param.Number(\n        1.4,\n        bounds=(0.1, 500.0),\n        label=\"\ud83c\udf21\ufe0f \u0422\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u044c (\u0412\u0442/(\u043c\u00b7\u041a))\"\n    )\n\n    material_absorption = param.Number(\n        5000.0,\n        bounds=(1.0, 100000.0),\n        label=\"\ud83c\udfaf \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u044f (1/\u043c)\"\n    )\n\n    material_reflectivity = param.Number(\n        0.25,\n        bounds=(0.0, 1.0),\n        label=\"\u2728 \u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f\"\n    )\n\n    initial_temperature = param.Number(\n        300.0,\n        bounds=(0.0, 5000.0),\n        label=\"\ud83c\udf21\ufe0f \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)\"\n    )\n\n    # === \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b PINN ===\n    laser_amplitude = param.Number(\n        1.0,\n        bounds=(0.1, 10.0),\n        label=\"\ud83d\udcca \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u0430\u044f \u0430\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u043b\u0430\u0437\u0435\u0440\u0430\"\n    )\n\n    col_x = param.Integer(20, bounds=(5, 100), label=\"\ud83d\udcd0 \u041a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u044f X\")\n    col_y = param.Integer(20, bounds=(5, 100), label=\"\ud83d\udcd0 \u041a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u044f Y\")\n    col_z = param.Integer(20, bounds=(5, 100), label=\"\ud83d\udcd0 \u041a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u044f Z\")\n    col_t = param.Integer(20, bounds=(5, 100), label=\"\u23f1\ufe0f \u041a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u044f T\")\n\n    vis_x = param.Integer(30, bounds=(5, 100), label=\"\ud83d\udc41\ufe0f \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f X\")\n    vis_y = param.Integer(30, bounds=(5, 100), label=\"\ud83d\udc41\ufe0f \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f Y\")\n    vis_z = param.Integer(30, bounds=(5, 100), label=\"\ud83d\udc41\ufe0f \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f Z\")\n    vis_t = param.Integer(20, bounds=(5, 100), label=\"\u23f1\ufe0f \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f T\")\n\n    # === \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b \u041e\u0411\u0423\u0427\u0415\u041d\u0418\u042f ===\n    num_epochs = param.Integer(\n        1000,\n        bounds=(100, 10000),\n        label=\"\ud83c\udfaf \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043f\u043e\u0445\"\n    )\n\n    learning_rate = param.Number(\n        1e-3,\n        bounds=(1e-5, 1e-1),\n        label=\"\ud83d\udcc8 Learning rate\"\n    )\n\n    loss_pde = param.Number(\n        1.0,\n        bounds=(0.1, 10.0),\n        label=\"\ud83d\udcd0 PDE \u0432\u0435\u0441\"\n    )\n\n    loss_ic = param.Number(\n        1.0,\n        bounds=(0.1, 10.0),\n        label=\"\ud83c\udfaf IC \u0432\u0435\u0441\"\n    )\n\n    loss_bc = param.Number(\n        2.0,\n        bounds=(0.1, 10.0),\n        label=\"\ud83d\udd32 BC \u0432\u0435\u0441\"\n    )\n\n    # === \u0421\u0412\u041e\u0419\u0421\u0422\u0412\u0410 \u0412\u042b\u0427\u0418\u0421\u041b\u0415\u041d\u0418\u0419 ===\n    calculated_char_length = param.String(\"0.0 \u043c\u043a\u043c\", label=\"\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430\")\n    calculated_char_time = param.String(\"0.0 \u043c\u0441\", label=\"\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\")\n    calculated_char_temp = param.String(\"0.0 K\", label=\"\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\")\n    calculated_peak_intensity = param.String(\"0.0 \u041c\u0412\u0442/\u043c\u00b2\", label=\"\u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c\")\n\n    # === \u0412\u042b\u0425\u041e\u0414\u041d\u042b\u0415 \u0414\u0410\u041d\u041d\u042b\u0415 ===\n    json_output = param.String(\"\", label=\"JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f\")\n    status_message = param.String(\"\u0413\u043e\u0442\u043e\u0432\u043e\", label=\"\u0421\u0442\u0430\u0442\u0443\u0441\")\n\n    def __init__(self, **params):\n        \"\"\"\n        Initializes the LaserConfigApp object.\n\n        This constructor sets up the application by initializing the base class, \n        loading the configuration, creating the user interface elements, and \n        determining the starting values for calculations. This ensures the application \n        is ready to process laser-related data and simulations.\n\n        Args:\n            self: The LaserConfigApp instance.\n            **params: Keyword arguments passed to the superclass constructor.\n\n        Initializes the following class fields:\n            config: Stores the application's configuration settings.\n            widgets: Stores the GUI widgets for user interaction.\n            initial_parameters: Stores the initial values used in calculations.\n\n        Returns:\n            None\n        \"\"\"\n        super().__init__(**params)\n        self.load_current_config()\n        self.create_widgets()\n        self.calculate_initial_parameters()\n\n    def load_current_config(self):\n        \"\"\"\n        Loads the current configuration parameters for the laser processing simulation.\n\n        This method retrieves and sets the simulation parameters from the configuration file, \n        including laser properties, material properties, and training settings. \n        These parameters are essential for defining the simulation environment and \n        controlling the behavior of the laser-material interaction model.\n\n        Args:\n            self: The LaserConfigApp instance.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            self.laser_mode = config.LASER_MODE\n            self.laser_wavelength = config.LASER_WAVELENGTH\n            self.laser_beam_radius = config.LASER_BEAM_RADIUS\n            self.laser_scan_velocity = config.LASER_SCAN_VELOCITY\n\n            self.laser_rep_rate = config.LASER_REP_RATE\n            self.laser_pulse_duration = config.LASER_PULSE_DURATION\n            self.laser_avg_power = config.LASER_AVG_POWER\n            self.num_pulses = config.NUM_PULSES\n\n            self.laser_continuous_power = config.LASER_CONTINUOUS_POWER\n            self.simulation_time = config.SIMULATION_TIME_PHYSICAL\n\n            self.material_density = config.MATERIAL_DENSITY\n            self.material_specific_heat = config.MATERIAL_SPECIFIC_HEAT\n            self.material_conductivity = config.MATERIAL_CONDUCTIVITY\n            self.material_absorption = config.MATERIAL_ABSORPTION\n            self.material_reflectivity = config.MATERIAL_REFLECTIVITY\n            self.initial_temperature = config.INITIAL_TEMPERATURE\n\n            self.laser_amplitude = config.LASER_AMPLITUDE\n\n            coll_points = config.CONFIG.config[\"pinn\"][\"collocation_points\"]\n            self.col_x = coll_points[\"x\"]\n            self.col_y = coll_points[\"y\"]\n            self.col_z = coll_points[\"z\"]\n            self.col_t = coll_points[\"t\"]\n\n            vis_points = config.CONFIG.config[\"pinn\"][\"visualization_points\"]\n            self.vis_x = vis_points[\"x\"]\n            self.vis_y = vis_points[\"y\"]\n            self.vis_z = vis_points[\"z\"]\n            self.vis_t = vis_points[\"t\"]\n\n            train_config = config.CONFIG.config[\"training\"]\n            self.num_epochs = train_config[\"num_epochs\"]\n            self.learning_rate = train_config[\"learning_rate\"]\n\n            loss_weights = train_config[\"loss_weights\"]\n            self.loss_pde = loss_weights[\"pde\"]\n            self.loss_ic = loss_weights[\"ic\"]\n            self.loss_bc = loss_weights[\"bc\"]\n\n        except Exception as e:\n            print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {e}\")\n            self.update_status(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {str(e)}\", \"danger\")\n\n    # ============================================================================\n    # \u0421\u041e\u0417\u0414\u0410\u041d\u0418\u0415 \u0412\u0418\u0414\u0416\u0415\u0422\u041e\u0412\n    # ============================================================================\n\n    def create_widgets(self):\n        \"\"\"\n        Creates and arranges the user interface widgets for configuring laser processing parameters.\n\n        This method constructs the main layout of the application, including a title pane, tabbed sections for different configuration aspects (laser, material, PINN settings, training parameters, calculations, and controls), and a status bar for displaying messages.  These widgets are organized to allow users to define and adjust the simulation setup.\n\n        Args:\n            self:  The LaserConfigApp instance.\n\n        Returns:\n            None: This method modifies the object's attributes (self.title_pane, self.tabs, self.status_bar, self.layout) directly and doesn't return a value.\n        \"\"\"\n\n        # \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n        self.title_pane = pn.pane.HTML(\"\"\"\n        &lt;div style=\"\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            padding: 40px;\n            border-radius: 10px;\n            color: white;\n            margin-bottom: 20px;\n            text-align: center;\n            box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n        \"&gt;\n            &lt;h1 style=\"margin: 0; font-size: 2.8em; font-weight: 700;\"&gt;\u2699\ufe0f \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043e\u0440 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f&lt;/h1&gt;\n            &lt;p style=\"margin: 10px 0 0 0; font-size: 1.2em; opacity: 0.9;\"&gt;\n                \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0434\u043b\u044f PINN\n            &lt;/p&gt;\n        &lt;/div&gt;\n        \"\"\")\n\n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u043a\u043b\u0430\u0434\u043a\u0438\n        self.tabs = pn.Tabs(\n            ('\u26a1 \u041b\u0430\u0437\u0435\u0440', self.create_laser_tab()),\n            ('\ud83e\uddf1 \u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b', self.create_material_tab()),\n            ('\ud83e\uddee PINN', self.create_pinn_tab()),\n            ('\ud83c\udf93 \u041e\u0431\u0443\u0447\u0435\u043d\u0438\u0435', self.create_training_tab()),\n            ('\ud83d\udcca \u0420\u0430\u0441\u0447\u0435\u0442\u044b', self.create_calculations_tab()),\n            ('\ud83c\udfaf \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435', self.create_controls_tab()),\n            tabs_location='above',\n            sizing_mode='stretch_width'\n        )\n\n        # \u0421\u0442\u0430\u0442\u0443\u0441 \u0431\u0430\u0440\n        self.status_bar = pn.pane.Alert(\n            self.status_message,\n            alert_type=\"info\",\n            margin=(10, 0, 0, 0)\n        )\n\n        # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043b\u0435\u0439\u0430\u0443\u0442\n        self.layout = pn.Column(\n            self.title_pane,\n            self.tabs,\n            self.status_bar,\n            sizing_mode='stretch_width',\n            margin=(0, 20)\n        )\n\n    def create_laser_tab(self):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043a \u043b\u0430\u0437\u0435\u0440\u0430, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0449\u0443\u044e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a \u0440\u0435\u0436\u0438\u043c \u0440\u0430\u0431\u043e\u0442\u044b (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439), \u0434\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b, \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438. \u0412\u043a\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0438 \u0434\u043b\u044f \u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.\n        \"\"\"\n\n        # \u0412\u0438\u0434\u0436\u0435\u0442 \u0432\u044b\u0431\u043e\u0440\u0430 \u0440\u0435\u0436\u0438\u043c\u0430\n        mode_selector = pn.widgets.RadioButtonGroup(\n            name='\u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430',\n            options=['\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439', '\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439'],\n            value='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439' if self.laser_mode == 'pulsed' else '\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439',\n            button_type='success',\n            margin=(0, 0, 20, 0)\n        )\n\n        # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043a \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0443\n        def update_mode(event):\n            self.laser_mode = 'pulsed' if event.new == '\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439' else 'continuous'\n            self.update_status(f\"\u0420\u0435\u0436\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d \u043d\u0430: {event.new}\")\n        mode_selector.param.watch(update_mode, 'value')\n\n        # \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0435\n        basic_card = pn.Card(\n            pn.Row(\n                pn.Column(\n                    pn.widgets.FloatInput.from_param(self.param.laser_wavelength),\n                    pn.widgets.FloatInput.from_param(self.param.laser_beam_radius),\n                    pn.widgets.FloatInput.from_param(self.param.laser_scan_velocity),\n                ),\n                pn.Spacer(width=20),\n                pn.pane.HTML(\"\"\"\n                &lt;div style=\"color: #666; font-size: 0.9em;\"&gt;\n                    &lt;h4&gt;\ud83d\udca1 \u041f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0438:&lt;/h4&gt;\n                    &lt;ul&gt;\n                        &lt;li&gt;\u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b CO\u2082 \u043b\u0430\u0437\u0435\u0440\u0430: 10.6 \u043c\u043a\u043c&lt;/li&gt;\n                        &lt;li&gt;\u0422\u0438\u043f\u0438\u0447\u043d\u044b\u0439 \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430: 50-100 \u043c\u043a\u043c&lt;/li&gt;\n                        &lt;li&gt;\u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: 0.01-0.1 \u043c/\u0441&lt;/li&gt;\n                    &lt;/ul&gt;\n                &lt;/div&gt;\n                \"\"\")\n            ),\n            title=\"\ud83d\udce1 \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430\",\n            collapsed=False,\n            margin=(10, 0)\n        )\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n        pulsed_card = pn.Card(\n            pn.Column(\n                pn.widgets.FloatInput.from_param(self.param.laser_rep_rate),\n                pn.widgets.FloatInput.from_param(self.param.laser_pulse_duration),\n                pn.widgets.FloatInput.from_param(self.param.laser_avg_power),\n                pn.widgets.IntInput.from_param(self.param.num_pulses),\n            ),\n            title=\"\ud83d\udcc8 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\",\n            collapsed=(self.laser_mode != 'pulsed'),\n            margin=(10, 0)\n        )\n\n        # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n        continuous_card = pn.Card(\n            pn.Column(\n                pn.widgets.FloatInput.from_param(self.param.laser_continuous_power),\n                pn.widgets.FloatInput.from_param(self.param.simulation_time),\n            ),\n            title=\"\ud83d\udd06 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\",\n            collapsed=(self.laser_mode != 'continuous'),\n            margin=(10, 0)\n        )\n\n        # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u043a\u0430\u0440\u0442\u043e\u0447\u0435\u043a \u043f\u0440\u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0438 \u0440\u0435\u0436\u0438\u043c\u0430\n        def update_cards_visibility(event):\n            if event.new == 'pulsed':\n                pulsed_card.collapsed = False\n                continuous_card.collapsed = True\n            else:\n                pulsed_card.collapsed = True\n                continuous_card.collapsed = False\n\n        self.param.watch(update_cards_visibility, 'laser_mode')\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\u26a1 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f&lt;/h3&gt;\"),\n            mode_selector,\n            basic_card,\n            pulsed_card,\n            continuous_card,\n            sizing_mode='stretch_width'\n        )\n\n    def create_material_tab(self):\n        \"\"\"\n        Creates a tab for configuring material properties.\n\n        This tab provides a user interface to adjust key material parameters used in laser-material interaction simulations. These parameters define how the material responds to laser heating, influencing the accuracy of thermal modeling.\n\n        Args:\n            self:  The LaserConfigApp instance.\n\n        Returns:\n            A Panel layout representing the material configuration tab. This layout includes input widgets for density, specific heat, thermal conductivity, absorption, reflectivity, and initial temperature, along with reference information about typical material properties.\n        \"\"\"\n\n        # \u0421\u0435\u0442\u043a\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n        material_grid = pn.GridSpec(ncols=2, sizing_mode='stretch_width')\n\n        # \u041f\u0435\u0440\u0432\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430\n        material_grid[0:2, 0] = pn.Column(\n            pn.widgets.FloatInput.from_param(self.param.material_density),\n            pn.widgets.FloatInput.from_param(self.param.material_specific_heat),\n            pn.widgets.FloatInput.from_param(self.param.material_conductivity),\n            margin=(0, 10)\n        )\n\n        # \u0412\u0442\u043e\u0440\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430\n        material_grid[0:2, 1] = pn.Column(\n            pn.widgets.FloatInput.from_param(self.param.material_absorption),\n            pn.widgets.FloatSlider.from_param(self.param.material_reflectivity),\n            pn.widgets.FloatInput.from_param(self.param.initial_temperature),\n            margin=(0, 10)\n        )\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0435\u0439 \u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0435\n        info_card = pn.Card(\n            pn.pane.HTML(\"\"\"\n            &lt;div style=\"color: #666; font-size: 0.95em; line-height: 1.6;\"&gt;\n                &lt;h4&gt;\ud83e\uddf1 \u041a\u0432\u0430\u0440\u0446 JS1 (\u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b):&lt;/h4&gt;\n                &lt;ul&gt;\n                    &lt;li&gt;&lt;strong&gt;\u041f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; 2200-2500 \u043a\u0433/\u043c\u00b3&lt;/li&gt;\n                    &lt;li&gt;&lt;strong&gt;\u0422\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; 1.3-1.5 \u0412\u0442/(\u043c\u00b7\u041a)&lt;/li&gt;\n                    &lt;li&gt;&lt;strong&gt;\u0422\u0435\u043f\u043b\u043e\u0435\u043c\u043a\u043e\u0441\u0442\u044c:&lt;/strong&gt; 670-750 \u0414\u0436/(\u043a\u0433\u00b7\u041a)&lt;/li&gt;\n                    &lt;li&gt;&lt;strong&gt;\u041f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u0435 (10.6 \u043c\u043a\u043c):&lt;/strong&gt; 4000-6000 1/\u043c&lt;/li&gt;\n                    &lt;li&gt;&lt;strong&gt;\u041e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u0435:&lt;/strong&gt; 0.2-0.3&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n            \"\"\"),\n            title=\"\ud83d\udccb \u0421\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\",\n            collapsed=False,\n            margin=(20, 0, 0, 0)\n        )\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\ud83e\uddf1 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430&lt;/h3&gt;\"),\n            pn.Card(material_grid, title=\"\ud83d\udcca \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\", collapsed=False),\n            info_card,\n            sizing_mode='stretch_width'\n        )\n\n    def create_pinn_tab(self):\n        \"\"\"\n        Creates a configuration tab for PINN settings.\n\n        This tab allows users to adjust parameters related to the Physics-Informed Neural Network (PINN) model, including laser amplitude, collocation grid resolution, and visualization grid resolution. These settings are crucial for accurately simulating and analyzing laser-induced heat transfer.\n\n        Args:\n            self:  An instance of the LaserConfigApp class.\n\n        Returns:\n            pn.Column: A Panel layout containing the PINN configuration widgets, \n                       organized into cards for basic parameters, collocation grid, \n                       and visualization grid.\n        \"\"\"\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438 PINN\n        basic_card = pn.Card(\n            pn.Column(\n                pn.widgets.FloatSlider.from_param(self.param.laser_amplitude),\n                margin=(10, 0)\n            ),\n            title=\"\ud83d\udcc8 \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN\",\n            collapsed=False,\n            margin=(10, 0)\n        )\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441\u0435\u0442\u043a\u0438 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u0438\n        collocation_card = pn.Card(\n            pn.GridBox(\n                pn.widgets.IntSlider.from_param(self.param.col_x),\n                pn.widgets.IntSlider.from_param(self.param.col_y),\n                pn.widgets.IntSlider.from_param(self.param.col_z),\n                pn.widgets.IntSlider.from_param(self.param.col_t),\n                ncols=2,\n                align='start'\n            ),\n            title=\"\ud83d\udcd0 \u0421\u0435\u0442\u043a\u0430 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0442\u043e\u0447\u0435\u043a\",\n            collapsed=False,\n            margin=(10, 0)\n        )\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441\u0435\u0442\u043a\u0438 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n        visualization_card = pn.Card(\n            pn.GridBox(\n                pn.widgets.IntSlider.from_param(self.param.vis_x),\n                pn.widgets.IntSlider.from_param(self.param.vis_y),\n                pn.widgets.IntSlider.from_param(self.param.vis_z),\n                pn.widgets.IntSlider.from_param(self.param.vis_t),\n                ncols=2,\n                align='start'\n            ),\n            title=\"\ud83d\udc41\ufe0f \u0421\u0435\u0442\u043a\u0430 \u0442\u043e\u0447\u0435\u043a \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\",\n            collapsed=False,\n            margin=(10, 0)\n        )\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\ud83e\uddee \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 PINN&lt;/h3&gt;\"),\n            basic_card,\n            collocation_card,\n            visualization_card,\n            sizing_mode='stretch_width'\n        )\n\n    def create_training_tab(self):\n        \"\"\"\n        Creates a training settings tab with adjustable parameters for the simulation.\n\n        The tab allows users to configure core training settings like the number of epochs and learning rate, as well as adjust the weights assigned to different loss functions representing physical constraints (PDE, initial conditions, boundary conditions). This configuration is crucial for effectively training models to accurately simulate laser-material interactions.\n\n        Args:\n            self:  The LaserConfigApp instance.\n\n        Returns:\n            pn.Column: A Panel layout representing the training settings tab, \n                       containing widgets for parameter adjustment and informative tooltips.\n        \"\"\"\n\n        # \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n        basic_params = pn.Row(\n            pn.Column(\n                pn.widgets.IntSlider.from_param(self.param.num_epochs),\n                pn.widgets.FloatSlider.from_param(\n                    self.param.learning_rate,\n                    format=\"%.1e\"\n                ),\n                width=300\n            ),\n            pn.Spacer(width=20),\n            pn.pane.HTML(\"\"\"\n            &lt;div style=\"background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #4285f4;\"&gt;\n                &lt;h4&gt;\ud83d\udca1 \u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438:&lt;/h4&gt;\n                &lt;ul style=\"color: #666;\"&gt;\n                    &lt;li&gt;\u0414\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0437\u0430\u0434\u0430\u0447: 1000-2000 \u044d\u043f\u043e\u0445&lt;/li&gt;\n                    &lt;li&gt;\u0414\u043b\u044f \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447: 5000-10000 \u044d\u043f\u043e\u0445&lt;/li&gt;\n                    &lt;li&gt;Learning rate: 1e-4 - 1e-3&lt;/li&gt;\n                    &lt;li&gt;\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 callback \u0434\u043b\u044f \u0440\u0430\u043d\u043d\u0435\u0439 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n            \"\"\")\n        )\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u0432\u0435\u0441\u0430\u043c\u0438 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0439\n        loss_cards = pn.GridBox(\n            self.create_loss_card(\"\ud83d\udcd0 PDE\", \"#4285f4\", self.param.loss_pde, \n                                 \"\u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438\"),\n            self.create_loss_card(\"\ud83c\udfaf IC\", \"#EA4335\", self.param.loss_ic, \n                                 \"\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\"),\n            self.create_loss_card(\"\ud83d\udd32 BC\", \"#34A853\", self.param.loss_bc, \n                                 \"\u0413\u0440\u0430\u043d\u0438\u0447\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\"),\n            ncols=3,\n            align='start'\n        )\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\ud83c\udf93 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f&lt;/h3&gt;\"),\n            pn.Card(basic_params, title=\"\u2699\ufe0f \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\", collapsed=False),\n            pn.Card(loss_cards, title=\"\u2696\ufe0f \u0412\u0435\u0441\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043f\u043e\u0442\u0435\u0440\u044c\", collapsed=False),\n            sizing_mode='stretch_width'\n        )\n\n    def create_loss_card(self, title, color, parameter, description):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430.\n\n        Args:\n            title (str): \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u0432 \u0432\u0435\u0440\u0445\u043d\u0435\u0439 \u0447\u0430\u0441\u0442\u0438.\n            color (str): \u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 \u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f.\n            parameter (pn.param.Parameterized): \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043b\u0430\u0439\u0434\u0435\u0440.\n            description (str): \u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u043e\u0435 \u043f\u043e\u0434 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c.\n\n        Returns:\n            pn.Card: \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 Panel \u0441 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c \u0438 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u043e\u043c \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438.\n\n        \u041c\u0435\u0442\u043e\u0434 \u0441\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u043e\u0442\u0435\u0440\u044c, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430. \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0438 \u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432.\n        \"\"\"\n        return pn.Card(\n            pn.Column(\n                pn.pane.HTML(f\"\"\"\n                &lt;div style=\"text-align: center; margin-bottom: 15px;\"&gt;\n                    &lt;div style=\"color: {color}; font-weight: bold; font-size: 1.2em;\"&gt;\n                        {title}\n                    &lt;/div&gt;\n                    &lt;div style=\"color: #666; font-size: 0.9em; margin-top: 5px;\"&gt;\n                        {description}\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                \"\"\"),\n                pn.widgets.FloatSlider.from_param(parameter),\n                align='center'\n            ),\n            styles={'background': f'{color}10', 'border': f'2px solid {color}'},\n            margin=(5, 5),\n            sizing_mode='stretch_height'\n        )\n\n    def create_calculations_tab(self):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\u043c\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0437\u0443\u044e\u0449\u0438\u0445 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043b\u0430\u0437\u0435\u0440\u0430 \u0441 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u043c.\n\n        Args:\n            self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u043c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c.\n\n        Returns:\n            pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0430\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 (\u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430, \u0432\u0440\u0435\u043c\u044f, \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430, \u043f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c), \u043a\u043d\u043e\u043f\u043a\u0443 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0443\u044e \u043f\u0430\u043d\u0435\u043b\u044c \u0441 \u043f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u044f\u043c\u0438 \u043a \u0440\u0430\u0441\u0447\u0435\u0442\u0430\u043c.\n        \"\"\"\n\n        # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\u043c\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432\n        results_grid = pn.GridBox(\n            self.create_result_card(\"\ud83d\udccf \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430\", self.calculated_char_length, \n                                   \"#667eea\", \"\u043c\u043a\u043c\"),\n            self.create_result_card(\"\u23f1\ufe0f \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\", self.calculated_char_time, \n                                   \"#764ba2\", \"\u043c\u0441\"),\n            self.create_result_card(\"\ud83c\udf21\ufe0f \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\", self.calculated_char_temp, \n                                   \"#ff6b6b\", \"K\"),\n            self.create_result_card(\"\u26a1 \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c\", self.calculated_peak_intensity, \n                                   \"#4ecdc4\", \"\u041c\u0412\u0442/\u043c\u00b2\"),\n            ncols=2,\n            align='start'\n        )\n\n        # \u041a\u043d\u043e\u043f\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442\u0430\n        calc_button = pn.widgets.Button(\n            name=\"\ud83e\uddee \u041f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\",\n            button_type=\"primary\",\n            width=200,\n            margin=(20, 0, 0, 0)\n        )\n        calc_button.on_click(self.calculate_parameters)\n\n        # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n        info_pane = pn.pane.HTML(\"\"\"\n        &lt;div style=\"background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;\"&gt;\n            &lt;h4&gt;\ud83d\udcca \u041f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u044f \u043a \u0440\u0430\u0441\u0447\u0435\u0442\u0430\u043c:&lt;/h4&gt;\n            &lt;ul style=\"color: #666;\"&gt;\n                &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430:&lt;/strong&gt; \u0440\u0430\u0434\u0438\u0443\u0441 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f:&lt;/strong&gt; \u0432\u0440\u0435\u043c\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u043e\u0439 \u0434\u0438\u0444\u0444\u0443\u0437\u0438\u0438 \u0447\u0435\u0440\u0435\u0437 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0443\u044e \u0434\u043b\u0438\u043d\u0443&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430:&lt;/strong&gt; \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432 \u043e\u0442 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u0430&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        \"\"\")\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\ud83d\udcca \u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b&lt;/h3&gt;\"),\n            pn.Card(results_grid, title=\"\ud83d\udd0d \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432\", collapsed=False),\n            pn.Row(calc_button, align='center'),\n            info_pane,\n            sizing_mode='stretch_width'\n        )\n\n    def create_result_card(self, title, value_param, color, unit):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u0439 \u0438\u043b\u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439.\n\n        Args:\n            title (str): \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440.\n            value_param (str): \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f.\n            color (str): \u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u044f.\n            unit (str): \u0415\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430.\n\n        Returns:\n            pn.Card: \u041e\u0431\u044a\u0435\u043a\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 Panel, \u0433\u043e\u0442\u043e\u0432\u044b\u0439 \u043a \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044e.\n        \"\"\"\n        return pn.Card(\n            pn.Column(\n                pn.pane.HTML(f\"\"\"\n                &lt;div style=\"text-align: center; padding: 10px;\"&gt;\n                    &lt;div style=\"color: {color}; font-weight: bold; font-size: 1.1em; margin-bottom: 10px;\"&gt;\n                        {title}\n                    &lt;/div&gt;\n                    &lt;div style=\"font-size: 1.8em; font-weight: 700; color: #2d3748;\"&gt;\n                        {value_param}\n                    &lt;/div&gt;\n                    &lt;div style=\"color: #718096; margin-top: 5px;\"&gt;\n                        {unit}\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                \"\"\"),\n                align='center'\n            ),\n            styles={'background': f'{color}10', 'border': f'2px solid {color}'},\n            margin=(5, 5),\n            sizing_mode='stretch_height'\n        )\n\n    def create_controls_tab(self):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0443\u044e \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0440\u0430\u0441\u0447\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f JSON, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0432 \u0444\u0430\u0439\u043b \u0438 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439. \u0422\u0430\u043a\u0436\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u043f\u0430\u043d\u0435\u043b\u044c \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u043f\u0440\u0435\u0434\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u0432.\n\n        Args:\n            None\n\n        Returns:\n            pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c \u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430.\n        \"\"\"\n\n        # \u041a\u043d\u043e\u043f\u043a\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439\n        buttons_row = pn.Row(\n            pn.widgets.Button(\n                name=\"\ud83e\uddee \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0432\u0441\u0435\",\n                button_type=\"warning\",\n                width=150,\n                margin=(5, 10)\n            ),\n            pn.widgets.Button(\n                name=\"\ud83d\udcbe \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c JSON\",\n                button_type=\"success\",\n                width=150,\n                margin=(5, 10)\n            ),\n            pn.widgets.Button(\n                name=\"\ud83d\udcc1 \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0444\u0430\u0439\u043b\",\n                button_type=\"primary\",\n                width=150,\n                margin=(5, 10)\n            ),\n            pn.widgets.Button(\n                name=\"\ud83d\udd04 \u0421\u0431\u0440\u043e\u0441\u0438\u0442\u044c\",\n                button_type=\"light\",\n                width=150,\n                margin=(5, 10)\n            ),\n            pn.widgets.Button(\n                name=\"\u26a1 \u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c\",\n                button_type=\"success\",\n                width=150,\n                margin=(5, 10)\n            ),\n            align='center'\n        )\n\n        # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438\n        buttons_row[0].on_click(self.calculate_parameters)\n        buttons_row[1].on_click(self.generate_json)\n        buttons_row[2].on_click(self.save_to_file)\n        buttons_row[3].on_click(self.reset_to_defaults)\n        buttons_row[4].on_click(self.apply_config)\n\n        # \u041f\u043e\u043b\u0435 \u0432\u044b\u0432\u043e\u0434\u0430 JSON\n        json_output = pn.widgets.TextAreaInput(\n            name='JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f',\n            value='',\n            height=300,\n            sizing_mode='stretch_width'\n        )\n\n        # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043a \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0443\n        def update_json_output(event):\n            json_output.value = event.new\n\n        self.param.watch(update_json_output, 'json_output')\n\n        # \u041f\u0430\u043d\u0435\u043b\u044c \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439\n        quick_actions = pn.Card(\n            pn.Column(\n                pn.Row(\n                    pn.widgets.Button(\n                        name=\"\ud83d\udd04 \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0448\u0430\u0431\u043b\u043e\u043d\",\n                        button_type=\"light\",\n                        width=200\n                    ),\n                    pn.widgets.Button(\n                        name=\"\ud83d\udd06 \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0448\u0430\u0431\u043b\u043e\u043d\",\n                        button_type=\"light\",\n                        width=200\n                    ),\n                ),\n                pn.pane.HTML(\"\"\"\n                &lt;div style=\"color: #666; font-size: 0.9em; margin-top: 15px;\"&gt;\n                    &lt;strong&gt;\ud83d\udca1 \u0411\u044b\u0441\u0442\u0440\u044b\u0435 \u0448\u0430\u0431\u043b\u043e\u043d\u044b:&lt;/strong&gt;\n                    &lt;ul&gt;\n                        &lt;li&gt;\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439: 8 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, 10 \u0412\u0442&lt;/li&gt;\n                        &lt;li&gt;\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439: 5 \u0412\u0442, 2 \u043c\u0441&lt;/li&gt;\n                    &lt;/ul&gt;\n                &lt;/div&gt;\n                \"\"\")\n            ),\n            title=\"\u26a1 \u0411\u044b\u0441\u0442\u0440\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f\",\n            collapsed=False,\n            margin=(20, 0)\n        )\n\n        return pn.Column(\n            pn.pane.HTML(\"&lt;h3&gt;\ud83c\udfaf \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439&lt;/h3&gt;\"),\n            buttons_row,\n            pn.Card(json_output, title=\"\ud83d\udcdd JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f\", collapsed=False),\n            quick_actions,\n            sizing_mode='stretch_width'\n        )\n\n    # ============================================================================\n    # \u041e\u0411\u0420\u0410\u0411\u041e\u0422\u0427\u0418\u041a\u0418 \u0421\u041e\u0411\u042b\u0422\u0418\u0419\n    # ============================================================================\n\n    def calculate_parameters(self, event=None):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u044b\u0445 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u043c \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0438 \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.\n\n        Args:\n            event (optional):  Event object, likely triggered by a UI element. Not used in the calculation itself. Defaults to None.\n\n        Returns:\n            None: The method updates the object's attributes with calculated values and updates the status message.\n        \"\"\"\n        try:\n            # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\n            if self.laser_mode == 'continuous':\n                peak_power = self.laser_continuous_power\n                rep_rate = 1.0\n                pulse_duration = 1e-6\n            else:\n                peak_power = self.laser_avg_power / (self.laser_rep_rate * self.laser_pulse_duration)\n                rep_rate = self.laser_rep_rate\n                pulse_duration = self.laser_pulse_duration\n\n            # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b\n            char_length = self.laser_beam_radius\n            thermal_diffusivity = self.material_conductivity / (self.material_density * self.material_specific_heat)\n            char_time = char_length**2 / thermal_diffusivity\n\n            # \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c\n            peak_intensity = (2 * peak_power) / (np.pi * self.laser_beam_radius**2)\n\n            # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\n            char_temp = ((1 - self.material_reflectivity) * \n                        peak_intensity * \n                        self.material_absorption * \n                        char_length**2 / \n                        self.material_conductivity)\n\n            # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n            self.calculated_char_length = f\"{char_length*1e6:.2f}\"\n            self.calculated_char_time = f\"{char_time*1e3:.2f}\"\n            self.calculated_char_temp = f\"{char_temp:.1f}\"\n            self.calculated_peak_intensity = f\"{peak_intensity/1e6:.1f}\"\n\n            self.update_status(\"\u2705 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u043d\u044b\")\n\n        except Exception as e:\n            self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0430\u0441\u0447\u0435\u0442\u0430: {str(e)}\", \"danger\")\n\n    def calculate_initial_parameters(self):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0438 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.\n\n        Args:\n            self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438 \u0434\u0430\u043d\u043d\u044b\u0435.\n\n        Returns:\n            None: \u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430, \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u044f \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043d\u0443\u0442\u0440\u0438 \u043d\u0435\u0433\u043e.\n        \"\"\"\n        self.calculate_parameters()\n\n    def generate_json(self, event=None):\n        \"\"\"\n        \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\n        Args:\n            event (optional): Event object, not used in the current implementation. Defaults to None.\n\n        Returns:\n            None: The generated JSON configuration is stored in the `self.json_output` attribute.\n                  Updates the application status to indicate success or failure.\n\n        The method creates a JSON representation of the application's configuration, allowing for easy storage or transfer of settings. This is crucial for reproducibility and sharing of experimental setups or simulation parameters.\n        \"\"\"\n        try:\n            config = self.generate_config_dict()\n            config_str = json.dumps(config, indent=2, default=str)\n            self.json_output = config_str\n            self.update_status(\"\u2705 JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0430\")\n        except Exception as e:\n            self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 JSON: {str(e)}\", \"danger\")\n\n    def generate_config_dict(self):\n        \"\"\"\n        Generates a dictionary containing all the necessary configuration parameters for the laser processing simulation.\n\n        This dictionary encapsulates parameters related to the laser source, material properties, \n        PINN settings, and training configurations, providing a comprehensive setup for the simulation.\n        The structure allows for easy access and modification of individual parameters.\n\n        Args:\n            self: An instance of the LaserConfigApp class, providing access to the configuration attributes.\n\n        Returns:\n            dict: A dictionary containing the complete configuration for the laser processing simulation, \n                  organized into 'laser', 'material', 'pinn', and 'training' sections.\n        \"\"\"\n        return {\n            \"laser\": {\n                \"wavelength\": self.laser_wavelength,\n                \"rep_rate\": self.laser_rep_rate if self.laser_mode == 'pulsed' else 1.0,\n                \"pulse_duration\": self.laser_pulse_duration if self.laser_mode == 'pulsed' else 1e-6,\n                \"avg_power\": self.laser_avg_power if self.laser_mode == 'pulsed' else 0.0,\n                \"beam_radius\": self.laser_beam_radius,\n                \"scan_velocity\": self.laser_scan_velocity,\n                \"mode\": self.laser_mode,\n                \"continuous_power\": self.laser_continuous_power,\n                \"num_pulses\": self.num_pulses if self.laser_mode == 'pulsed' else 1,\n                \"simulation_time\": self.simulation_time if self.laser_mode == 'continuous' else None\n            },\n            \"material\": {\n                \"density\": self.material_density,\n                \"specific_heat\": self.material_specific_heat,\n                \"conductivity\": self.material_conductivity,\n                \"absorption\": self.material_absorption,\n                \"reflectivity\": self.material_reflectivity,\n                \"initial_temperature\": self.initial_temperature\n            },\n            \"pinn\": {\n                \"num_gaussians\": 1,\n                \"gaussian_spacing\": 0.5,\n                \"sigma0\": 0.1,\n                \"laser_amplitude\": self.laser_amplitude,\n                \"collocation_points\": {\n                    \"x\": self.col_x,\n                    \"y\": self.col_y,\n                    \"z\": self.col_z,\n                    \"t\": self.col_t\n                },\n                \"visualization_points\": {\n                    \"x\": self.vis_x,\n                    \"y\": self.vis_y,\n                    \"z\": self.vis_z,\n                    \"t\": self.vis_t\n                }\n            },\n            \"training\": {\n                \"num_epochs\": self.num_epochs,\n                \"learning_rate\": self.learning_rate,\n                \"device\": \"auto\",\n                \"loss_weights\": {\n                    \"pde\": self.loss_pde,\n                    \"ic\": self.loss_ic,\n                    \"bc\": self.loss_bc\n                }\n            }\n        }\n\n    def save_to_file(self, event=None):\n        \"\"\"\n        \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043b\u0430\u0437\u0435\u0440\u0430 \u0432 \u0444\u0430\u0439\u043b.\n\n        Args:\n            event (optional): Event object, likely from a GUI framework. Not used directly in the function's logic. Defaults to None.\n\n        Returns:\n            None\n\n        The method ensures the configuration is in JSON format, generates a unique filename incorporating the laser mode, and then writes the JSON data to the file. This allows for persistent storage and retrieval of laser settings for later use or replication of experiments.\n        \"\"\"\n        try:\n            if not self.json_output:\n                self.generate_json()\n\n            filename = f\"config_{self.laser_mode}_{np.random.randint(1000, 9999)}.json\"\n            filepath = Path(filename)\n\n            with open(filepath, 'w', encoding='utf-8') as f:\n                f.write(self.json_output)\n\n            self.update_status(f\"\u2705 \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u0432 \u0444\u0430\u0439\u043b: {filename}\")\n\n        except Exception as e:\n            self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f: {str(e)}\", \"danger\")\n\n    def reset_to_defaults(self, event=None):\n        \"\"\"\n        \u0421\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0432\u0441\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043a \u043f\u0440\u0435\u0434\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.\n\n        \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043d\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0439.\n        \u041c\u0435\u0442\u043e\u0434 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043a \u0438\u0445 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c,\n        \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u043f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u0430\u0442\u0443\u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\n        Args:\n            event (optional): \u041e\u0431\u044a\u0435\u043a\u0442 \u0441\u043e\u0431\u044b\u0442\u0438\u044f, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0439 \u0441 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043d\u0430\u0436\u0430\u0442\u0438\u0435\u043c \u043a\u043d\u043e\u043f\u043a\u0438).\n                              \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0432 \u043b\u043e\u0433\u0438\u043a\u0435 \u043c\u0435\u0442\u043e\u0434\u0430. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u0430\n            self.laser_mode = 'continuous'\n            self.laser_wavelength = 10.6e-6\n            self.laser_beam_radius = 62e-6\n            self.laser_scan_velocity = 0.06\n\n            # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n            self.material_density = 2200.0\n            self.material_specific_heat = 670.0\n            self.material_conductivity = 1.4\n            self.material_absorption = 5000.0\n            self.material_reflectivity = 0.25\n            self.initial_temperature = 300.0\n\n            # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 PINN\n            self.laser_amplitude = 1.0\n            self.col_x = 20\n            self.col_y = 20\n            self.col_z = 20\n            self.col_t = 20\n            self.vis_x = 30\n            self.vis_y = 30\n            self.vis_z = 30\n            self.vis_t = 20\n\n            # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n            self.num_epochs = 1000\n            self.learning_rate = 1e-3\n            self.loss_pde = 1.0\n            self.loss_ic = 1.0\n            self.loss_bc = 2.0\n\n            # \u041f\u0435\u0440\u0435\u0441\u0447\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n            self.calculate_parameters()\n            self.update_status(\"\u2705 \u0412\u0441\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0431\u0440\u043e\u0448\u0435\u043d\u044b \u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\")\n\n        except Exception as e:\n            self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u0431\u0440\u043e\u0441\u0430: {str(e)}\", \"danger\")\n\n    def apply_config(self, event=None):\n        \"\"\"\n        \u041f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u044f \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044f \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.\n\n        Args:\n            event (optional): Event object, typically used in GUI frameworks. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\n            config_dict = self.generate_config_dict()\n\n            # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u044a\u0435\u043a\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n            config.CONFIG.config = config.CONFIG.deep_update(config.CONFIG.config.copy(), config_dict)\n            config.CONFIG.calculate_derived_parameters()\n\n            self.update_status(f\"\u2705 \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0430. \u0420\u0435\u0436\u0438\u043c: {self.laser_mode}\")\n\n        except Exception as e:\n            self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {str(e)}\", \"danger\")\n\n    def update_status(self, message, alert_type=\"info\"):\n        \"\"\"\n        Updates the status message displayed in the application.\n\n        Args:\n            message (str): The status message to display.\n            alert_type (str, optional): The type of alert for the status message \n                (\"info\", \"warning\", \"error\", etc.). Defaults to \"info\".\n\n        Returns:\n            None\n        \"\"\"\n        self.status_message = message\n        self.status_bar.alert_type = alert_type\n        self.status_bar.object = message\n\n    def show(self):\n        \"\"\"\n        Displays the main user interface layout.\n\n        Args:\n            self:  The LaserConfigApp instance.\n\n        Returns:\n            QtWidgets.QWidget: The main layout of the application, containing the user interface elements.\n        \"\"\"\n        return self.layout\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.__init__","title":"<code>__init__(**params)</code>","text":"<p>Initializes the LaserConfigApp object.</p> <p>This constructor sets up the application by initializing the base class,  loading the configuration, creating the user interface elements, and  determining the starting values for calculations. This ensures the application  is ready to process laser-related data and simulations.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <code>**params</code> <p>Keyword arguments passed to the superclass constructor.</p> <code>{}</code> Initializes the following class fields <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def __init__(self, **params):\n    \"\"\"\n    Initializes the LaserConfigApp object.\n\n    This constructor sets up the application by initializing the base class, \n    loading the configuration, creating the user interface elements, and \n    determining the starting values for calculations. This ensures the application \n    is ready to process laser-related data and simulations.\n\n    Args:\n        self: The LaserConfigApp instance.\n        **params: Keyword arguments passed to the superclass constructor.\n\n    Initializes the following class fields:\n        config: Stores the application's configuration settings.\n        widgets: Stores the GUI widgets for user interaction.\n        initial_parameters: Stores the initial values used in calculations.\n\n    Returns:\n        None\n    \"\"\"\n    super().__init__(**params)\n    self.load_current_config()\n    self.create_widgets()\n    self.calculate_initial_parameters()\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.apply_config","title":"<code>apply_config(event=None)</code>","text":"<p>\u041f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u044f \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044f \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>optional</code> <p>Event object, typically used in GUI frameworks. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def apply_config(self, event=None):\n    \"\"\"\n    \u041f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u044f \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044f \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u044b.\n\n    Args:\n        event (optional): Event object, typically used in GUI frameworks. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\n        config_dict = self.generate_config_dict()\n\n        # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u044a\u0435\u043a\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n        config.CONFIG.config = config.CONFIG.deep_update(config.CONFIG.config.copy(), config_dict)\n        config.CONFIG.calculate_derived_parameters()\n\n        self.update_status(f\"\u2705 \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0430. \u0420\u0435\u0436\u0438\u043c: {self.laser_mode}\")\n\n    except Exception as e:\n        self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.calculate_initial_parameters","title":"<code>calculate_initial_parameters()</code>","text":"<p>\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0438 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>\u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438 \u0434\u0430\u043d\u043d\u044b\u0435.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>\u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430, \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u044f \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043d\u0443\u0442\u0440\u0438 \u043d\u0435\u0433\u043e.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def calculate_initial_parameters(self):\n    \"\"\"\n    \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0438 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f.\n\n    Args:\n        self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0438 \u0434\u0430\u043d\u043d\u044b\u0435.\n\n    Returns:\n        None: \u041c\u0435\u0442\u043e\u0434 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430, \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u044f \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u043d\u0443\u0442\u0440\u0438 \u043d\u0435\u0433\u043e.\n    \"\"\"\n    self.calculate_parameters()\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.calculate_parameters","title":"<code>calculate_parameters(event=None)</code>","text":"<p>\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u044b\u0445 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u043c \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0438 \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>optional</code> <p>Event object, likely triggered by a UI element. Not used in the calculation itself. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <p>The method updates the object's attributes with calculated values and updates the status message.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def calculate_parameters(self, event=None):\n    \"\"\"\n    \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u044b\u0445 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u044e\u0449\u0438\u0445 \u043f\u0440\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u043c \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0438 \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.\n\n    Args:\n        event (optional):  Event object, likely triggered by a UI element. Not used in the calculation itself. Defaults to None.\n\n    Returns:\n        None: The method updates the object's attributes with calculated values and updates the status message.\n    \"\"\"\n    try:\n        # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f\n        if self.laser_mode == 'continuous':\n            peak_power = self.laser_continuous_power\n            rep_rate = 1.0\n            pulse_duration = 1e-6\n        else:\n            peak_power = self.laser_avg_power / (self.laser_rep_rate * self.laser_pulse_duration)\n            rep_rate = self.laser_rep_rate\n            pulse_duration = self.laser_pulse_duration\n\n        # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u044b\u0435 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u044b\n        char_length = self.laser_beam_radius\n        thermal_diffusivity = self.material_conductivity / (self.material_density * self.material_specific_heat)\n        char_time = char_length**2 / thermal_diffusivity\n\n        # \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c\n        peak_intensity = (2 * peak_power) / (np.pi * self.laser_beam_radius**2)\n\n        # \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\n        char_temp = ((1 - self.material_reflectivity) * \n                    peak_intensity * \n                    self.material_absorption * \n                    char_length**2 / \n                    self.material_conductivity)\n\n        # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n        self.calculated_char_length = f\"{char_length*1e6:.2f}\"\n        self.calculated_char_time = f\"{char_time*1e3:.2f}\"\n        self.calculated_char_temp = f\"{char_temp:.1f}\"\n        self.calculated_peak_intensity = f\"{peak_intensity/1e6:.1f}\"\n\n        self.update_status(\"\u2705 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u043d\u044b\")\n\n    except Exception as e:\n        self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0430\u0441\u0447\u0435\u0442\u0430: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_calculations_tab","title":"<code>create_calculations_tab()</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\u043c\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0437\u0443\u044e\u0449\u0438\u0445 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043b\u0430\u0437\u0435\u0440\u0430 \u0441 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u043c.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>\u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u043c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c.</p> required <p>Returns:</p> Type Description <p>pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0430\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 (\u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430, \u0432\u0440\u0435\u043c\u044f, \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430, \u043f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c), \u043a\u043d\u043e\u043f\u043a\u0443 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0443\u044e \u043f\u0430\u043d\u0435\u043b\u044c \u0441 \u043f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u044f\u043c\u0438 \u043a \u0440\u0430\u0441\u0447\u0435\u0442\u0430\u043c.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_calculations_tab(self):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\u043c\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0437\u0443\u044e\u0449\u0438\u0445 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043b\u0430\u0437\u0435\u0440\u0430 \u0441 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u043e\u043c.\n\n    Args:\n        self: \u042d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 LaserConfigApp, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u043c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c.\n\n    Returns:\n        pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0430\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432 (\u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430, \u0432\u0440\u0435\u043c\u044f, \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430, \u043f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c), \u043a\u043d\u043e\u043f\u043a\u0443 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0443\u044e \u043f\u0430\u043d\u0435\u043b\u044c \u0441 \u043f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u044f\u043c\u0438 \u043a \u0440\u0430\u0441\u0447\u0435\u0442\u0430\u043c.\n    \"\"\"\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 \u0441 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\u043c\u0438 \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432\n    results_grid = pn.GridBox(\n        self.create_result_card(\"\ud83d\udccf \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430\", self.calculated_char_length, \n                               \"#667eea\", \"\u043c\u043a\u043c\"),\n        self.create_result_card(\"\u23f1\ufe0f \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\", self.calculated_char_time, \n                               \"#764ba2\", \"\u043c\u0441\"),\n        self.create_result_card(\"\ud83c\udf21\ufe0f \u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\", self.calculated_char_temp, \n                               \"#ff6b6b\", \"K\"),\n        self.create_result_card(\"\u26a1 \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c\", self.calculated_peak_intensity, \n                               \"#4ecdc4\", \"\u041c\u0412\u0442/\u043c\u00b2\"),\n        ncols=2,\n        align='start'\n    )\n\n    # \u041a\u043d\u043e\u043f\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0447\u0435\u0442\u0430\n    calc_button = pn.widgets.Button(\n        name=\"\ud83e\uddee \u041f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\",\n        button_type=\"primary\",\n        width=200,\n        margin=(20, 0, 0, 0)\n    )\n    calc_button.on_click(self.calculate_parameters)\n\n    # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n    info_pane = pn.pane.HTML(\"\"\"\n    &lt;div style=\"background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;\"&gt;\n        &lt;h4&gt;\ud83d\udcca \u041f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u044f \u043a \u0440\u0430\u0441\u0447\u0435\u0442\u0430\u043c:&lt;/h4&gt;\n        &lt;ul style=\"color: #666;\"&gt;\n            &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430:&lt;/strong&gt; \u0440\u0430\u0434\u0438\u0443\u0441 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430&lt;/li&gt;\n            &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f:&lt;/strong&gt; \u0432\u0440\u0435\u043c\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u043e\u0439 \u0434\u0438\u0444\u0444\u0443\u0437\u0438\u0438 \u0447\u0435\u0440\u0435\u0437 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0443\u044e \u0434\u043b\u0438\u043d\u0443&lt;/li&gt;\n            &lt;li&gt;&lt;strong&gt;\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430:&lt;/strong&gt; \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432 \u043e\u0442 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f&lt;/li&gt;\n            &lt;li&gt;&lt;strong&gt;\u041f\u0438\u043a\u043e\u0432\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u0430&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n    \"\"\")\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\ud83d\udcca \u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b&lt;/h3&gt;\"),\n        pn.Card(results_grid, title=\"\ud83d\udd0d \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0440\u0430\u0441\u0447\u0435\u0442\u043e\u0432\", collapsed=False),\n        pn.Row(calc_button, align='center'),\n        info_pane,\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_controls_tab","title":"<code>create_controls_tab()</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0443\u044e \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0440\u0430\u0441\u0447\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f JSON, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0432 \u0444\u0430\u0439\u043b \u0438 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439. \u0422\u0430\u043a\u0436\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u043f\u0430\u043d\u0435\u043b\u044c \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u043f\u0440\u0435\u0434\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u0432.</p> <p>Returns:</p> Type Description <p>pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c \u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_controls_tab(self):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0443\u044e \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0441 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0440\u0430\u0441\u0447\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f JSON, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0432 \u0444\u0430\u0439\u043b \u0438 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439. \u0422\u0430\u043a\u0436\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438 \u043f\u0430\u043d\u0435\u043b\u044c \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u043f\u0440\u0435\u0434\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0448\u0430\u0431\u043b\u043e\u043d\u043e\u0432.\n\n    Args:\n        None\n\n    Returns:\n        pn.Column: \u041f\u0430\u043d\u0435\u043b\u044c \u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439 \u043b\u0430\u0437\u0435\u0440\u0430.\n    \"\"\"\n\n    # \u041a\u043d\u043e\u043f\u043a\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439\n    buttons_row = pn.Row(\n        pn.widgets.Button(\n            name=\"\ud83e\uddee \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0432\u0441\u0435\",\n            button_type=\"warning\",\n            width=150,\n            margin=(5, 10)\n        ),\n        pn.widgets.Button(\n            name=\"\ud83d\udcbe \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c JSON\",\n            button_type=\"success\",\n            width=150,\n            margin=(5, 10)\n        ),\n        pn.widgets.Button(\n            name=\"\ud83d\udcc1 \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0444\u0430\u0439\u043b\",\n            button_type=\"primary\",\n            width=150,\n            margin=(5, 10)\n        ),\n        pn.widgets.Button(\n            name=\"\ud83d\udd04 \u0421\u0431\u0440\u043e\u0441\u0438\u0442\u044c\",\n            button_type=\"light\",\n            width=150,\n            margin=(5, 10)\n        ),\n        pn.widgets.Button(\n            name=\"\u26a1 \u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c\",\n            button_type=\"success\",\n            width=150,\n            margin=(5, 10)\n        ),\n        align='center'\n    )\n\n    # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0438\n    buttons_row[0].on_click(self.calculate_parameters)\n    buttons_row[1].on_click(self.generate_json)\n    buttons_row[2].on_click(self.save_to_file)\n    buttons_row[3].on_click(self.reset_to_defaults)\n    buttons_row[4].on_click(self.apply_config)\n\n    # \u041f\u043e\u043b\u0435 \u0432\u044b\u0432\u043e\u0434\u0430 JSON\n    json_output = pn.widgets.TextAreaInput(\n        name='JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f',\n        value='',\n        height=300,\n        sizing_mode='stretch_width'\n    )\n\n    # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043a \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0443\n    def update_json_output(event):\n        json_output.value = event.new\n\n    self.param.watch(update_json_output, 'json_output')\n\n    # \u041f\u0430\u043d\u0435\u043b\u044c \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439\n    quick_actions = pn.Card(\n        pn.Column(\n            pn.Row(\n                pn.widgets.Button(\n                    name=\"\ud83d\udd04 \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0448\u0430\u0431\u043b\u043e\u043d\",\n                    button_type=\"light\",\n                    width=200\n                ),\n                pn.widgets.Button(\n                    name=\"\ud83d\udd06 \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0448\u0430\u0431\u043b\u043e\u043d\",\n                    button_type=\"light\",\n                    width=200\n                ),\n            ),\n            pn.pane.HTML(\"\"\"\n            &lt;div style=\"color: #666; font-size: 0.9em; margin-top: 15px;\"&gt;\n                &lt;strong&gt;\ud83d\udca1 \u0411\u044b\u0441\u0442\u0440\u044b\u0435 \u0448\u0430\u0431\u043b\u043e\u043d\u044b:&lt;/strong&gt;\n                &lt;ul&gt;\n                    &lt;li&gt;\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439: 8 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, 10 \u0412\u0442&lt;/li&gt;\n                    &lt;li&gt;\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439: 5 \u0412\u0442, 2 \u043c\u0441&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n            \"\"\")\n        ),\n        title=\"\u26a1 \u0411\u044b\u0441\u0442\u0440\u044b\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f\",\n        collapsed=False,\n        margin=(20, 0)\n    )\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\ud83c\udfaf \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0435\u0439&lt;/h3&gt;\"),\n        buttons_row,\n        pn.Card(json_output, title=\"\ud83d\udcdd JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f\", collapsed=False),\n        quick_actions,\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_laser_tab","title":"<code>create_laser_tab()</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043a \u043b\u0430\u0437\u0435\u0440\u0430, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0449\u0443\u044e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a \u0440\u0435\u0436\u0438\u043c \u0440\u0430\u0431\u043e\u0442\u044b (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439), \u0434\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b, \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438. \u0412\u043a\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0438 \u0434\u043b\u044f \u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_laser_tab(self):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u043a\u043b\u0430\u0434\u043a\u0443 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043a \u043b\u0430\u0437\u0435\u0440\u0430, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0449\u0443\u044e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a \u0440\u0435\u0436\u0438\u043c \u0440\u0430\u0431\u043e\u0442\u044b (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439), \u0434\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b, \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438. \u0412\u043a\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0438 \u0434\u043b\u044f \u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439.\n    \"\"\"\n\n    # \u0412\u0438\u0434\u0436\u0435\u0442 \u0432\u044b\u0431\u043e\u0440\u0430 \u0440\u0435\u0436\u0438\u043c\u0430\n    mode_selector = pn.widgets.RadioButtonGroup(\n        name='\u0420\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430',\n        options=['\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439', '\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439'],\n        value='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439' if self.laser_mode == 'pulsed' else '\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439',\n        button_type='success',\n        margin=(0, 0, 20, 0)\n    )\n\n    # \u041f\u0440\u0438\u0432\u044f\u0437\u044b\u0432\u0430\u0435\u043c \u043a \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0443\n    def update_mode(event):\n        self.laser_mode = 'pulsed' if event.new == '\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439' else 'continuous'\n        self.update_status(f\"\u0420\u0435\u0436\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d \u043d\u0430: {event.new}\")\n    mode_selector.param.watch(update_mode, 'value')\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0435\n    basic_card = pn.Card(\n        pn.Row(\n            pn.Column(\n                pn.widgets.FloatInput.from_param(self.param.laser_wavelength),\n                pn.widgets.FloatInput.from_param(self.param.laser_beam_radius),\n                pn.widgets.FloatInput.from_param(self.param.laser_scan_velocity),\n            ),\n            pn.Spacer(width=20),\n            pn.pane.HTML(\"\"\"\n            &lt;div style=\"color: #666; font-size: 0.9em;\"&gt;\n                &lt;h4&gt;\ud83d\udca1 \u041f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0438:&lt;/h4&gt;\n                &lt;ul&gt;\n                    &lt;li&gt;\u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b CO\u2082 \u043b\u0430\u0437\u0435\u0440\u0430: 10.6 \u043c\u043a\u043c&lt;/li&gt;\n                    &lt;li&gt;\u0422\u0438\u043f\u0438\u0447\u043d\u044b\u0439 \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430: 50-100 \u043c\u043a\u043c&lt;/li&gt;\n                    &lt;li&gt;\u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0441\u043a\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: 0.01-0.1 \u043c/\u0441&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n            \"\"\")\n        ),\n        title=\"\ud83d\udce1 \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430\",\n        collapsed=False,\n        margin=(10, 0)\n    )\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n    pulsed_card = pn.Card(\n        pn.Column(\n            pn.widgets.FloatInput.from_param(self.param.laser_rep_rate),\n            pn.widgets.FloatInput.from_param(self.param.laser_pulse_duration),\n            pn.widgets.FloatInput.from_param(self.param.laser_avg_power),\n            pn.widgets.IntInput.from_param(self.param.num_pulses),\n        ),\n        title=\"\ud83d\udcc8 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\",\n        collapsed=(self.laser_mode != 'pulsed'),\n        margin=(10, 0)\n    )\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n    continuous_card = pn.Card(\n        pn.Column(\n            pn.widgets.FloatInput.from_param(self.param.laser_continuous_power),\n            pn.widgets.FloatInput.from_param(self.param.simulation_time),\n        ),\n        title=\"\ud83d\udd06 \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\",\n        collapsed=(self.laser_mode != 'continuous'),\n        margin=(10, 0)\n    )\n\n    # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u043a\u0430\u0440\u0442\u043e\u0447\u0435\u043a \u043f\u0440\u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0438 \u0440\u0435\u0436\u0438\u043c\u0430\n    def update_cards_visibility(event):\n        if event.new == 'pulsed':\n            pulsed_card.collapsed = False\n            continuous_card.collapsed = True\n        else:\n            pulsed_card.collapsed = True\n            continuous_card.collapsed = False\n\n    self.param.watch(update_cards_visibility, 'laser_mode')\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\u26a1 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f&lt;/h3&gt;\"),\n        mode_selector,\n        basic_card,\n        pulsed_card,\n        continuous_card,\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_loss_card","title":"<code>create_loss_card(title, color, parameter, description)</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u0432 \u0432\u0435\u0440\u0445\u043d\u0435\u0439 \u0447\u0430\u0441\u0442\u0438.</p> required <code>color</code> <code>str</code> <p>\u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 \u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f.</p> required <code>parameter</code> <code>Parameterized</code> <p>\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043b\u0430\u0439\u0434\u0435\u0440.</p> required <code>description</code> <code>str</code> <p>\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u043e\u0435 \u043f\u043e\u0434 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c.</p> required <p>Returns:</p> Type Description <p>pn.Card: \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 Panel \u0441 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c \u0438 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u043e\u043c \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0441\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u043e\u0442\u0435\u0440\u044c, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430. \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0438 \u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_loss_card(self, title, color, parameter, description):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430.\n\n    Args:\n        title (str): \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u0432 \u0432\u0435\u0440\u0445\u043d\u0435\u0439 \u0447\u0430\u0441\u0442\u0438.\n        color (str): \u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 \u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f.\n        parameter (pn.param.Parameterized): \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u043b\u0430\u0439\u0434\u0435\u0440.\n        description (str): \u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u043e\u0435 \u043f\u043e\u0434 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c.\n\n    Returns:\n        pn.Card: \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 Panel \u0441 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u043c, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c \u0438 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u043e\u043c \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0438.\n\n    \u041c\u0435\u0442\u043e\u0434 \u0441\u043e\u0437\u0434\u0430\u0435\u0442 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432\u0435\u0441\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u043e\u0442\u0435\u0440\u044c, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430. \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0438 \u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432.\n    \"\"\"\n    return pn.Card(\n        pn.Column(\n            pn.pane.HTML(f\"\"\"\n            &lt;div style=\"text-align: center; margin-bottom: 15px;\"&gt;\n                &lt;div style=\"color: {color}; font-weight: bold; font-size: 1.2em;\"&gt;\n                    {title}\n                &lt;/div&gt;\n                &lt;div style=\"color: #666; font-size: 0.9em; margin-top: 5px;\"&gt;\n                    {description}\n                &lt;/div&gt;\n            &lt;/div&gt;\n            \"\"\"),\n            pn.widgets.FloatSlider.from_param(parameter),\n            align='center'\n        ),\n        styles={'background': f'{color}10', 'border': f'2px solid {color}'},\n        margin=(5, 5),\n        sizing_mode='stretch_height'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_material_tab","title":"<code>create_material_tab()</code>","text":"<p>Creates a tab for configuring material properties.</p> <p>This tab provides a user interface to adjust key material parameters used in laser-material interaction simulations. These parameters define how the material responds to laser heating, influencing the accuracy of thermal modeling.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <p>Returns:</p> Type Description <p>A Panel layout representing the material configuration tab. This layout includes input widgets for density, specific heat, thermal conductivity, absorption, reflectivity, and initial temperature, along with reference information about typical material properties.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_material_tab(self):\n    \"\"\"\n    Creates a tab for configuring material properties.\n\n    This tab provides a user interface to adjust key material parameters used in laser-material interaction simulations. These parameters define how the material responds to laser heating, influencing the accuracy of thermal modeling.\n\n    Args:\n        self:  The LaserConfigApp instance.\n\n    Returns:\n        A Panel layout representing the material configuration tab. This layout includes input widgets for density, specific heat, thermal conductivity, absorption, reflectivity, and initial temperature, along with reference information about typical material properties.\n    \"\"\"\n\n    # \u0421\u0435\u0442\u043a\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n    material_grid = pn.GridSpec(ncols=2, sizing_mode='stretch_width')\n\n    # \u041f\u0435\u0440\u0432\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430\n    material_grid[0:2, 0] = pn.Column(\n        pn.widgets.FloatInput.from_param(self.param.material_density),\n        pn.widgets.FloatInput.from_param(self.param.material_specific_heat),\n        pn.widgets.FloatInput.from_param(self.param.material_conductivity),\n        margin=(0, 10)\n    )\n\n    # \u0412\u0442\u043e\u0440\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430\n    material_grid[0:2, 1] = pn.Column(\n        pn.widgets.FloatInput.from_param(self.param.material_absorption),\n        pn.widgets.FloatSlider.from_param(self.param.material_reflectivity),\n        pn.widgets.FloatInput.from_param(self.param.initial_temperature),\n        margin=(0, 10)\n    )\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0435\u0439 \u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0435\n    info_card = pn.Card(\n        pn.pane.HTML(\"\"\"\n        &lt;div style=\"color: #666; font-size: 0.95em; line-height: 1.6;\"&gt;\n            &lt;h4&gt;\ud83e\uddf1 \u041a\u0432\u0430\u0440\u0446 JS1 (\u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b):&lt;/h4&gt;\n            &lt;ul&gt;\n                &lt;li&gt;&lt;strong&gt;\u041f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; 2200-2500 \u043a\u0433/\u043c\u00b3&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u0422\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u044c:&lt;/strong&gt; 1.3-1.5 \u0412\u0442/(\u043c\u00b7\u041a)&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u0422\u0435\u043f\u043b\u043e\u0435\u043c\u043a\u043e\u0441\u0442\u044c:&lt;/strong&gt; 670-750 \u0414\u0436/(\u043a\u0433\u00b7\u041a)&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u041f\u043e\u0433\u043b\u043e\u0449\u0435\u043d\u0438\u0435 (10.6 \u043c\u043a\u043c):&lt;/strong&gt; 4000-6000 1/\u043c&lt;/li&gt;\n                &lt;li&gt;&lt;strong&gt;\u041e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u0435:&lt;/strong&gt; 0.2-0.3&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        \"\"\"),\n        title=\"\ud83d\udccb \u0421\u043f\u0440\u0430\u0432\u043e\u0447\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\",\n        collapsed=False,\n        margin=(20, 0, 0, 0)\n    )\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\ud83e\uddf1 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430&lt;/h3&gt;\"),\n        pn.Card(material_grid, title=\"\ud83d\udcca \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\", collapsed=False),\n        info_card,\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_pinn_tab","title":"<code>create_pinn_tab()</code>","text":"<p>Creates a configuration tab for PINN settings.</p> <p>This tab allows users to adjust parameters related to the Physics-Informed Neural Network (PINN) model, including laser amplitude, collocation grid resolution, and visualization grid resolution. These settings are crucial for accurately simulating and analyzing laser-induced heat transfer.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>An instance of the LaserConfigApp class.</p> required <p>Returns:</p> Type Description <p>pn.Column: A Panel layout containing the PINN configuration widgets,         organized into cards for basic parameters, collocation grid,         and visualization grid.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_pinn_tab(self):\n    \"\"\"\n    Creates a configuration tab for PINN settings.\n\n    This tab allows users to adjust parameters related to the Physics-Informed Neural Network (PINN) model, including laser amplitude, collocation grid resolution, and visualization grid resolution. These settings are crucial for accurately simulating and analyzing laser-induced heat transfer.\n\n    Args:\n        self:  An instance of the LaserConfigApp class.\n\n    Returns:\n        pn.Column: A Panel layout containing the PINN configuration widgets, \n                   organized into cards for basic parameters, collocation grid, \n                   and visualization grid.\n    \"\"\"\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438 PINN\n    basic_card = pn.Card(\n        pn.Column(\n            pn.widgets.FloatSlider.from_param(self.param.laser_amplitude),\n            margin=(10, 0)\n        ),\n        title=\"\ud83d\udcc8 \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b PINN\",\n        collapsed=False,\n        margin=(10, 0)\n    )\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441\u0435\u0442\u043a\u0438 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u0438\n    collocation_card = pn.Card(\n        pn.GridBox(\n            pn.widgets.IntSlider.from_param(self.param.col_x),\n            pn.widgets.IntSlider.from_param(self.param.col_y),\n            pn.widgets.IntSlider.from_param(self.param.col_z),\n            pn.widgets.IntSlider.from_param(self.param.col_t),\n            ncols=2,\n            align='start'\n        ),\n        title=\"\ud83d\udcd0 \u0421\u0435\u0442\u043a\u0430 \u043a\u043e\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0442\u043e\u0447\u0435\u043a\",\n        collapsed=False,\n        margin=(10, 0)\n    )\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441\u0435\u0442\u043a\u0438 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n    visualization_card = pn.Card(\n        pn.GridBox(\n            pn.widgets.IntSlider.from_param(self.param.vis_x),\n            pn.widgets.IntSlider.from_param(self.param.vis_y),\n            pn.widgets.IntSlider.from_param(self.param.vis_z),\n            pn.widgets.IntSlider.from_param(self.param.vis_t),\n            ncols=2,\n            align='start'\n        ),\n        title=\"\ud83d\udc41\ufe0f \u0421\u0435\u0442\u043a\u0430 \u0442\u043e\u0447\u0435\u043a \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\",\n        collapsed=False,\n        margin=(10, 0)\n    )\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\ud83e\uddee \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 PINN&lt;/h3&gt;\"),\n        basic_card,\n        collocation_card,\n        visualization_card,\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_result_card","title":"<code>create_result_card(title, value_param, color, unit)</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u0439 \u0438\u043b\u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440.</p> required <code>value_param</code> <code>str</code> <p>\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f.</p> required <code>color</code> <code>str</code> <p>\u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u044f.</p> required <code>unit</code> <code>str</code> <p>\u0415\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430.</p> required <p>Returns:</p> Type Description <p>pn.Card: \u041e\u0431\u044a\u0435\u043a\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 Panel, \u0433\u043e\u0442\u043e\u0432\u044b\u0439 \u043a \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044e.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_result_card(self, title, value_param, color, unit):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0443 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u0439 \u0438\u043b\u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439.\n\n    Args:\n        title (str): \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u043e\u043f\u0438\u0441\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440.\n        value_param (str): \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0434\u043b\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f.\n        color (str): \u0426\u0432\u0435\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0439 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u044f.\n        unit (str): \u0415\u0434\u0438\u043d\u0438\u0446\u0430 \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430.\n\n    Returns:\n        pn.Card: \u041e\u0431\u044a\u0435\u043a\u0442 \u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438 Panel, \u0433\u043e\u0442\u043e\u0432\u044b\u0439 \u043a \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044e.\n    \"\"\"\n    return pn.Card(\n        pn.Column(\n            pn.pane.HTML(f\"\"\"\n            &lt;div style=\"text-align: center; padding: 10px;\"&gt;\n                &lt;div style=\"color: {color}; font-weight: bold; font-size: 1.1em; margin-bottom: 10px;\"&gt;\n                    {title}\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 1.8em; font-weight: 700; color: #2d3748;\"&gt;\n                    {value_param}\n                &lt;/div&gt;\n                &lt;div style=\"color: #718096; margin-top: 5px;\"&gt;\n                    {unit}\n                &lt;/div&gt;\n            &lt;/div&gt;\n            \"\"\"),\n            align='center'\n        ),\n        styles={'background': f'{color}10', 'border': f'2px solid {color}'},\n        margin=(5, 5),\n        sizing_mode='stretch_height'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_training_tab","title":"<code>create_training_tab()</code>","text":"<p>Creates a training settings tab with adjustable parameters for the simulation.</p> <p>The tab allows users to configure core training settings like the number of epochs and learning rate, as well as adjust the weights assigned to different loss functions representing physical constraints (PDE, initial conditions, boundary conditions). This configuration is crucial for effectively training models to accurately simulate laser-material interactions.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <p>Returns:</p> Type Description <p>pn.Column: A Panel layout representing the training settings tab,         containing widgets for parameter adjustment and informative tooltips.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_training_tab(self):\n    \"\"\"\n    Creates a training settings tab with adjustable parameters for the simulation.\n\n    The tab allows users to configure core training settings like the number of epochs and learning rate, as well as adjust the weights assigned to different loss functions representing physical constraints (PDE, initial conditions, boundary conditions). This configuration is crucial for effectively training models to accurately simulate laser-material interactions.\n\n    Args:\n        self:  The LaserConfigApp instance.\n\n    Returns:\n        pn.Column: A Panel layout representing the training settings tab, \n                   containing widgets for parameter adjustment and informative tooltips.\n    \"\"\"\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n    basic_params = pn.Row(\n        pn.Column(\n            pn.widgets.IntSlider.from_param(self.param.num_epochs),\n            pn.widgets.FloatSlider.from_param(\n                self.param.learning_rate,\n                format=\"%.1e\"\n            ),\n            width=300\n        ),\n        pn.Spacer(width=20),\n        pn.pane.HTML(\"\"\"\n        &lt;div style=\"background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #4285f4;\"&gt;\n            &lt;h4&gt;\ud83d\udca1 \u0420\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438:&lt;/h4&gt;\n            &lt;ul style=\"color: #666;\"&gt;\n                &lt;li&gt;\u0414\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0437\u0430\u0434\u0430\u0447: 1000-2000 \u044d\u043f\u043e\u0445&lt;/li&gt;\n                &lt;li&gt;\u0414\u043b\u044f \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447: 5000-10000 \u044d\u043f\u043e\u0445&lt;/li&gt;\n                &lt;li&gt;Learning rate: 1e-4 - 1e-3&lt;/li&gt;\n                &lt;li&gt;\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 callback \u0434\u043b\u044f \u0440\u0430\u043d\u043d\u0435\u0439 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        \"\"\")\n    )\n\n    # \u041a\u0430\u0440\u0442\u043e\u0447\u043a\u0430 \u0441 \u0432\u0435\u0441\u0430\u043c\u0438 loss \u0444\u0443\u043d\u043a\u0446\u0438\u0439\n    loss_cards = pn.GridBox(\n        self.create_loss_card(\"\ud83d\udcd0 PDE\", \"#4285f4\", self.param.loss_pde, \n                             \"\u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438\"),\n        self.create_loss_card(\"\ud83c\udfaf IC\", \"#EA4335\", self.param.loss_ic, \n                             \"\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\"),\n        self.create_loss_card(\"\ud83d\udd32 BC\", \"#34A853\", self.param.loss_bc, \n                             \"\u0413\u0440\u0430\u043d\u0438\u0447\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\"),\n        ncols=3,\n        align='start'\n    )\n\n    return pn.Column(\n        pn.pane.HTML(\"&lt;h3&gt;\ud83c\udf93 \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f&lt;/h3&gt;\"),\n        pn.Card(basic_params, title=\"\u2699\ufe0f \u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\", collapsed=False),\n        pn.Card(loss_cards, title=\"\u2696\ufe0f \u0412\u0435\u0441\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043f\u043e\u0442\u0435\u0440\u044c\", collapsed=False),\n        sizing_mode='stretch_width'\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Creates and arranges the user interface widgets for configuring laser processing parameters.</p> <p>This method constructs the main layout of the application, including a title pane, tabbed sections for different configuration aspects (laser, material, PINN settings, training parameters, calculations, and controls), and a status bar for displaying messages.  These widgets are organized to allow users to define and adjust the simulation setup.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>This method modifies the object's attributes (self.title_pane, self.tabs, self.status_bar, self.layout) directly and doesn't return a value.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def create_widgets(self):\n    \"\"\"\n    Creates and arranges the user interface widgets for configuring laser processing parameters.\n\n    This method constructs the main layout of the application, including a title pane, tabbed sections for different configuration aspects (laser, material, PINN settings, training parameters, calculations, and controls), and a status bar for displaying messages.  These widgets are organized to allow users to define and adjust the simulation setup.\n\n    Args:\n        self:  The LaserConfigApp instance.\n\n    Returns:\n        None: This method modifies the object's attributes (self.title_pane, self.tabs, self.status_bar, self.layout) directly and doesn't return a value.\n    \"\"\"\n\n    # \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    self.title_pane = pn.pane.HTML(\"\"\"\n    &lt;div style=\"\n        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n        padding: 40px;\n        border-radius: 10px;\n        color: white;\n        margin-bottom: 20px;\n        text-align: center;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    \"&gt;\n        &lt;h1 style=\"margin: 0; font-size: 2.8em; font-weight: 700;\"&gt;\u2699\ufe0f \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043e\u0440 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f&lt;/h1&gt;\n        &lt;p style=\"margin: 10px 0 0 0; font-size: 1.2em; opacity: 0.9;\"&gt;\n            \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0434\u043b\u044f PINN\n        &lt;/p&gt;\n    &lt;/div&gt;\n    \"\"\")\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u043a\u043b\u0430\u0434\u043a\u0438\n    self.tabs = pn.Tabs(\n        ('\u26a1 \u041b\u0430\u0437\u0435\u0440', self.create_laser_tab()),\n        ('\ud83e\uddf1 \u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b', self.create_material_tab()),\n        ('\ud83e\uddee PINN', self.create_pinn_tab()),\n        ('\ud83c\udf93 \u041e\u0431\u0443\u0447\u0435\u043d\u0438\u0435', self.create_training_tab()),\n        ('\ud83d\udcca \u0420\u0430\u0441\u0447\u0435\u0442\u044b', self.create_calculations_tab()),\n        ('\ud83c\udfaf \u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435', self.create_controls_tab()),\n        tabs_location='above',\n        sizing_mode='stretch_width'\n    )\n\n    # \u0421\u0442\u0430\u0442\u0443\u0441 \u0431\u0430\u0440\n    self.status_bar = pn.pane.Alert(\n        self.status_message,\n        alert_type=\"info\",\n        margin=(10, 0, 0, 0)\n    )\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043b\u0435\u0439\u0430\u0443\u0442\n    self.layout = pn.Column(\n        self.title_pane,\n        self.tabs,\n        self.status_bar,\n        sizing_mode='stretch_width',\n        margin=(0, 20)\n    )\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.generate_config_dict","title":"<code>generate_config_dict()</code>","text":"<p>Generates a dictionary containing all the necessary configuration parameters for the laser processing simulation.</p> <p>This dictionary encapsulates parameters related to the laser source, material properties,  PINN settings, and training configurations, providing a comprehensive setup for the simulation. The structure allows for easy access and modification of individual parameters.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>An instance of the LaserConfigApp class, providing access to the configuration attributes.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the complete configuration for the laser processing simulation,    organized into 'laser', 'material', 'pinn', and 'training' sections.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def generate_config_dict(self):\n    \"\"\"\n    Generates a dictionary containing all the necessary configuration parameters for the laser processing simulation.\n\n    This dictionary encapsulates parameters related to the laser source, material properties, \n    PINN settings, and training configurations, providing a comprehensive setup for the simulation.\n    The structure allows for easy access and modification of individual parameters.\n\n    Args:\n        self: An instance of the LaserConfigApp class, providing access to the configuration attributes.\n\n    Returns:\n        dict: A dictionary containing the complete configuration for the laser processing simulation, \n              organized into 'laser', 'material', 'pinn', and 'training' sections.\n    \"\"\"\n    return {\n        \"laser\": {\n            \"wavelength\": self.laser_wavelength,\n            \"rep_rate\": self.laser_rep_rate if self.laser_mode == 'pulsed' else 1.0,\n            \"pulse_duration\": self.laser_pulse_duration if self.laser_mode == 'pulsed' else 1e-6,\n            \"avg_power\": self.laser_avg_power if self.laser_mode == 'pulsed' else 0.0,\n            \"beam_radius\": self.laser_beam_radius,\n            \"scan_velocity\": self.laser_scan_velocity,\n            \"mode\": self.laser_mode,\n            \"continuous_power\": self.laser_continuous_power,\n            \"num_pulses\": self.num_pulses if self.laser_mode == 'pulsed' else 1,\n            \"simulation_time\": self.simulation_time if self.laser_mode == 'continuous' else None\n        },\n        \"material\": {\n            \"density\": self.material_density,\n            \"specific_heat\": self.material_specific_heat,\n            \"conductivity\": self.material_conductivity,\n            \"absorption\": self.material_absorption,\n            \"reflectivity\": self.material_reflectivity,\n            \"initial_temperature\": self.initial_temperature\n        },\n        \"pinn\": {\n            \"num_gaussians\": 1,\n            \"gaussian_spacing\": 0.5,\n            \"sigma0\": 0.1,\n            \"laser_amplitude\": self.laser_amplitude,\n            \"collocation_points\": {\n                \"x\": self.col_x,\n                \"y\": self.col_y,\n                \"z\": self.col_z,\n                \"t\": self.col_t\n            },\n            \"visualization_points\": {\n                \"x\": self.vis_x,\n                \"y\": self.vis_y,\n                \"z\": self.vis_z,\n                \"t\": self.vis_t\n            }\n        },\n        \"training\": {\n            \"num_epochs\": self.num_epochs,\n            \"learning_rate\": self.learning_rate,\n            \"device\": \"auto\",\n            \"loss_weights\": {\n                \"pde\": self.loss_pde,\n                \"ic\": self.loss_ic,\n                \"bc\": self.loss_bc\n            }\n        }\n    }\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.generate_json","title":"<code>generate_json(event=None)</code>","text":"<p>\u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>optional</code> <p>Event object, not used in the current implementation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <p>The generated JSON configuration is stored in the <code>self.json_output</code> attribute.   Updates the application status to indicate success or failure.</p> <p>The method creates a JSON representation of the application's configuration, allowing for easy storage or transfer of settings. This is crucial for reproducibility and sharing of experimental setups or simulation parameters.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def generate_json(self, event=None):\n    \"\"\"\n    \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\n    Args:\n        event (optional): Event object, not used in the current implementation. Defaults to None.\n\n    Returns:\n        None: The generated JSON configuration is stored in the `self.json_output` attribute.\n              Updates the application status to indicate success or failure.\n\n    The method creates a JSON representation of the application's configuration, allowing for easy storage or transfer of settings. This is crucial for reproducibility and sharing of experimental setups or simulation parameters.\n    \"\"\"\n    try:\n        config = self.generate_config_dict()\n        config_str = json.dumps(config, indent=2, default=str)\n        self.json_output = config_str\n        self.update_status(\"\u2705 JSON \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0430\")\n    except Exception as e:\n        self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 JSON: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.load_current_config","title":"<code>load_current_config()</code>","text":"<p>Loads the current configuration parameters for the laser processing simulation.</p> <p>This method retrieves and sets the simulation parameters from the configuration file,  including laser properties, material properties, and training settings.  These parameters are essential for defining the simulation environment and  controlling the behavior of the laser-material interaction model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def load_current_config(self):\n    \"\"\"\n    Loads the current configuration parameters for the laser processing simulation.\n\n    This method retrieves and sets the simulation parameters from the configuration file, \n    including laser properties, material properties, and training settings. \n    These parameters are essential for defining the simulation environment and \n    controlling the behavior of the laser-material interaction model.\n\n    Args:\n        self: The LaserConfigApp instance.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        self.laser_mode = config.LASER_MODE\n        self.laser_wavelength = config.LASER_WAVELENGTH\n        self.laser_beam_radius = config.LASER_BEAM_RADIUS\n        self.laser_scan_velocity = config.LASER_SCAN_VELOCITY\n\n        self.laser_rep_rate = config.LASER_REP_RATE\n        self.laser_pulse_duration = config.LASER_PULSE_DURATION\n        self.laser_avg_power = config.LASER_AVG_POWER\n        self.num_pulses = config.NUM_PULSES\n\n        self.laser_continuous_power = config.LASER_CONTINUOUS_POWER\n        self.simulation_time = config.SIMULATION_TIME_PHYSICAL\n\n        self.material_density = config.MATERIAL_DENSITY\n        self.material_specific_heat = config.MATERIAL_SPECIFIC_HEAT\n        self.material_conductivity = config.MATERIAL_CONDUCTIVITY\n        self.material_absorption = config.MATERIAL_ABSORPTION\n        self.material_reflectivity = config.MATERIAL_REFLECTIVITY\n        self.initial_temperature = config.INITIAL_TEMPERATURE\n\n        self.laser_amplitude = config.LASER_AMPLITUDE\n\n        coll_points = config.CONFIG.config[\"pinn\"][\"collocation_points\"]\n        self.col_x = coll_points[\"x\"]\n        self.col_y = coll_points[\"y\"]\n        self.col_z = coll_points[\"z\"]\n        self.col_t = coll_points[\"t\"]\n\n        vis_points = config.CONFIG.config[\"pinn\"][\"visualization_points\"]\n        self.vis_x = vis_points[\"x\"]\n        self.vis_y = vis_points[\"y\"]\n        self.vis_z = vis_points[\"z\"]\n        self.vis_t = vis_points[\"t\"]\n\n        train_config = config.CONFIG.config[\"training\"]\n        self.num_epochs = train_config[\"num_epochs\"]\n        self.learning_rate = train_config[\"learning_rate\"]\n\n        loss_weights = train_config[\"loss_weights\"]\n        self.loss_pde = loss_weights[\"pde\"]\n        self.loss_ic = loss_weights[\"ic\"]\n        self.loss_bc = loss_weights[\"bc\"]\n\n    except Exception as e:\n        print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {e}\")\n        self.update_status(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.reset_to_defaults","title":"<code>reset_to_defaults(event=None)</code>","text":"<p>\u0421\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0432\u0441\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043a \u043f\u0440\u0435\u0434\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.</p> <p>\u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043d\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0439. \u041c\u0435\u0442\u043e\u0434 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043a \u0438\u0445 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c, \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u043f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u0430\u0442\u0443\u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>optional</code> <p>\u041e\u0431\u044a\u0435\u043a\u0442 \u0441\u043e\u0431\u044b\u0442\u0438\u044f, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0439 \u0441 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043d\u0430\u0436\u0430\u0442\u0438\u0435\u043c \u043a\u043d\u043e\u043f\u043a\u0438).               \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0432 \u043b\u043e\u0433\u0438\u043a\u0435 \u043c\u0435\u0442\u043e\u0434\u0430. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def reset_to_defaults(self, event=None):\n    \"\"\"\n    \u0421\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0432\u0441\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043a \u043f\u0440\u0435\u0434\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.\n\n    \u042d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043d\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0439.\n    \u041c\u0435\u0442\u043e\u0434 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043b\u0430\u0437\u0435\u0440\u0430, \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430, PINN \u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f \u043a \u0438\u0445 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c,\n    \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u043f\u0435\u0440\u0435\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u0430\u0442\u0443\u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\n    Args:\n        event (optional): \u041e\u0431\u044a\u0435\u043a\u0442 \u0441\u043e\u0431\u044b\u0442\u0438\u044f, \u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0439 \u0441 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f (\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043d\u0430\u0436\u0430\u0442\u0438\u0435\u043c \u043a\u043d\u043e\u043f\u043a\u0438).\n                          \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e \u0432 \u043b\u043e\u0433\u0438\u043a\u0435 \u043c\u0435\u0442\u043e\u0434\u0430. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u0430\n        self.laser_mode = 'continuous'\n        self.laser_wavelength = 10.6e-6\n        self.laser_beam_radius = 62e-6\n        self.laser_scan_velocity = 0.06\n\n        # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430\n        self.material_density = 2200.0\n        self.material_specific_heat = 670.0\n        self.material_conductivity = 1.4\n        self.material_absorption = 5000.0\n        self.material_reflectivity = 0.25\n        self.initial_temperature = 300.0\n\n        # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 PINN\n        self.laser_amplitude = 1.0\n        self.col_x = 20\n        self.col_y = 20\n        self.col_z = 20\n        self.col_t = 20\n        self.vis_x = 30\n        self.vis_y = 30\n        self.vis_z = 30\n        self.vis_t = 20\n\n        # \u0421\u0431\u0440\u043e\u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n        self.num_epochs = 1000\n        self.learning_rate = 1e-3\n        self.loss_pde = 1.0\n        self.loss_ic = 1.0\n        self.loss_bc = 2.0\n\n        # \u041f\u0435\u0440\u0435\u0441\u0447\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n        self.calculate_parameters()\n        self.update_status(\"\u2705 \u0412\u0441\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0431\u0440\u043e\u0448\u0435\u043d\u044b \u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\")\n\n    except Exception as e:\n        self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u0431\u0440\u043e\u0441\u0430: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.save_to_file","title":"<code>save_to_file(event=None)</code>","text":"<p>\u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043b\u0430\u0437\u0435\u0440\u0430 \u0432 \u0444\u0430\u0439\u043b.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>optional</code> <p>Event object, likely from a GUI framework. Not used directly in the function's logic. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>The method ensures the configuration is in JSON format, generates a unique filename incorporating the laser mode, and then writes the JSON data to the file. This allows for persistent storage and retrieval of laser settings for later use or replication of experiments.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def save_to_file(self, event=None):\n    \"\"\"\n    \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u043b\u0430\u0437\u0435\u0440\u0430 \u0432 \u0444\u0430\u0439\u043b.\n\n    Args:\n        event (optional): Event object, likely from a GUI framework. Not used directly in the function's logic. Defaults to None.\n\n    Returns:\n        None\n\n    The method ensures the configuration is in JSON format, generates a unique filename incorporating the laser mode, and then writes the JSON data to the file. This allows for persistent storage and retrieval of laser settings for later use or replication of experiments.\n    \"\"\"\n    try:\n        if not self.json_output:\n            self.generate_json()\n\n        filename = f\"config_{self.laser_mode}_{np.random.randint(1000, 9999)}.json\"\n        filepath = Path(filename)\n\n        with open(filepath, 'w', encoding='utf-8') as f:\n            f.write(self.json_output)\n\n        self.update_status(f\"\u2705 \u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430 \u0432 \u0444\u0430\u0439\u043b: {filename}\")\n\n    except Exception as e:\n        self.update_status(f\"\u274c \u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f: {str(e)}\", \"danger\")\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.show","title":"<code>show()</code>","text":"<p>Displays the main user interface layout.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The LaserConfigApp instance.</p> required <p>Returns:</p> Type Description <p>QtWidgets.QWidget: The main layout of the application, containing the user interface elements.</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def show(self):\n    \"\"\"\n    Displays the main user interface layout.\n\n    Args:\n        self:  The LaserConfigApp instance.\n\n    Returns:\n        QtWidgets.QWidget: The main layout of the application, containing the user interface elements.\n    \"\"\"\n    return self.layout\n</code></pre>"},{"location":"PINN_3D_real_parms/config_gui_panel/#PINN_3D_real_parms.config_gui_panel.LaserConfigApp.update_status","title":"<code>update_status(message, alert_type='info')</code>","text":"<p>Updates the status message displayed in the application.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The status message to display.</p> required <code>alert_type</code> <code>str</code> <p>The type of alert for the status message  (\"info\", \"warning\", \"error\", etc.). Defaults to \"info\".</p> <code>'info'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/config_gui_panel.py</code> <pre><code>def update_status(self, message, alert_type=\"info\"):\n    \"\"\"\n    Updates the status message displayed in the application.\n\n    Args:\n        message (str): The status message to display.\n        alert_type (str, optional): The type of alert for the status message \n            (\"info\", \"warning\", \"error\", etc.). Defaults to \"info\".\n\n    Returns:\n        None\n    \"\"\"\n    self.status_message = message\n    self.status_bar.alert_type = alert_type\n    self.status_bar.object = message\n</code></pre>"},{"location":"PINN_3D_real_parms/main/","title":"Main","text":""},{"location":"PINN_3D_real_parms/main/#PINN_3D_real_parms.main.run_simulation","title":"<code>run_simulation(config_file=None, laser_mode=None)</code>","text":"<p>\u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u0430 \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439 (CPU, CUDA, MPS), \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u043f\u0440\u043e\u0444\u0438\u043b\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, \u043e\u0431\u0443\u0447\u0430\u0435\u0442 \u043c\u043e\u0434\u0435\u043b\u044c PINN \u0434\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u044f \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438 \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e\u0442\u0441\u044f \u0432 \u0432\u0438\u0434\u0435 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u0438 \u0438 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>\u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438. Defaults to None.</p> <code>None</code> <code>laser_mode</code> <code>str</code> <p>\u042f\u0432\u043d\u043e\u0435 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430 (\"pulsed\" \u0438\u043b\u0438 \"continuous\"). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>\u041a\u043e\u0440\u0442\u0435\u0436, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043e\u0431\u0443\u0447\u0435\u043d\u043d\u0443\u044e \u043c\u043e\u0434\u0435\u043b\u044c PINN, \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0438 \u0438\u0441\u0442\u043e\u0440\u0438\u044e \u043f\u043e\u0442\u0435\u0440\u044c.</p> Source code in <code>PINN_3D_real_parms/main.py</code> <pre><code>def run_simulation(config_file=None, laser_mode=None):\n    \"\"\"\n    \u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u0432\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u0430 \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.\n\n    \u041c\u0435\u0442\u043e\u0434 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439 (CPU, CUDA, MPS),\n    \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u043f\u0440\u043e\u0444\u0438\u043b\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, \u043e\u0431\u0443\u0447\u0430\u0435\u0442 \u043c\u043e\u0434\u0435\u043b\u044c PINN \u0434\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u044f \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438\n    \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e\u0442\u0441\u044f \u0432 \u0432\u0438\u0434\u0435 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u0438 \u0438 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.\n\n    Args:\n        config_file (str, optional): \u041f\u0443\u0442\u044c \u043a JSON \u0444\u0430\u0439\u043b\u0443 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438. Defaults to None.\n        laser_mode (str, optional): \u042f\u0432\u043d\u043e\u0435 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435 \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430 (\"pulsed\" \u0438\u043b\u0438 \"continuous\"). Defaults to None.\n\n    Returns:\n        tuple: \u041a\u043e\u0440\u0442\u0435\u0436, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043e\u0431\u0443\u0447\u0435\u043d\u043d\u0443\u044e \u043c\u043e\u0434\u0435\u043b\u044c PINN, \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0438 \u0438\u0441\u0442\u043e\u0440\u0438\u044e \u043f\u043e\u0442\u0435\u0440\u044c.\n    \"\"\"\n    # \u041f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043c \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0435\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d \u0444\u0430\u0439\u043b\n    if config_file:\n        print(f\"\u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438\u0437 {config_file}\")\n        config.CONFIG.load_from_json(config_file)\n        config.CONFIG.calculate_derived_parameters()\n        config.CONFIG.print_summary()\n\n    # \u0415\u0441\u043b\u0438 \u044f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u0430\u043d \u0440\u0435\u0436\u0438\u043c, \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e\n    if laser_mode is not None:\n        config.CONFIG.config[\"laser\"][\"mode\"] = laser_mode\n        config.CONFIG.calculate_derived_parameters()\n        print(f\"\u0420\u0435\u0436\u0438\u043c \u044f\u0432\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d \u043d\u0430: {laser_mode}\")\n\n    # \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e\n    try:\n        if config.CONFIG.config[\"training\"][\"device\"] == \"auto\":\n            device = torch.device(\"mps\" if torch.backends.mps.is_available() else \n                                 \"cuda\" if torch.backends.cuda.is_built() else \"cpu\")\n        else:\n            device = torch.device(config.CONFIG.config[\"training\"][\"device\"])\n    except:\n        device = torch.device(\"cuda\" if torch.backends.cuda.is_built() else \"cpu\")\n\n    print(f\"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e: {device}\")\n\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0440\u0435\u0436\u0438\u043c\n    mode = config.LASER_MODE\n    print(f\"\u0422\u0435\u043a\u0443\u0449\u0438\u0439 \u0440\u0435\u0436\u0438\u043c \u043b\u0430\u0437\u0435\u0440\u0430: {mode}\")\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0430\u043f\u043a\u0443 \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n    output_dir = f'results/{mode}'\n    os.makedirs(output_dir, exist_ok=True)\n    os.makedirs('animations', exist_ok=True)\n\n    # \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0444\u0438\u043b\u0435\u0439\n    print(\"\\n\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432...\")\n    visualize_laser_pulses()\n    visualize_laser_spatial_profile()\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0438 \u043e\u0431\u0443\u0447\u0430\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u044c\n    model = PINN([4, 128, 128, 128, 1]).to(device)\n    diff_coef = 1.0  # \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 = 1\n\n    print(f\"\\n\u041e\u0431\u0443\u0447\u0435\u043d\u0438\u0435 3D PINN \u0432 \u0440\u0435\u0436\u0438\u043c\u0435 {mode}...\")\n    loss_hist = train_pinn(\n        model, \n        diff_coef, \n        num_epochs=config.CONFIG.config[\"training\"][\"num_epochs\"],\n        lr=config.CONFIG.config[\"training\"][\"learning_rate\"],\n        device=device,\n        laser_mode=mode\n    )\n\n    # \u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u044f\n    viz_points = config.CONFIG.config[\"pinn\"][\"visualization_points\"]\n    nx_plot, ny_plot, nz_plot, nt_plot = (\n        viz_points[\"x\"], viz_points[\"y\"], viz_points[\"z\"], viz_points[\"t\"]\n    )\n\n    x_plot = np.linspace(-1, 1, nx_plot)  \n    y_plot = np.linspace(-1, 1, ny_plot)  \n    z_plot = np.linspace(0, 1, nz_plot)   \n    t_plot = np.linspace(0, config.SIMULATION_TIME_NORM, nt_plot)  \n\n    print(\"\u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0430\u043d\u0438\u0439 PINN...\")\n    with torch.no_grad():\n        Xp, Yp, Zp, Tp = np.meshgrid(x_plot, y_plot, z_plot, t_plot, indexing='ij')\n        x_t = torch.tensor(Xp.flatten(), dtype=torch.float32, device=device)\n        y_t = torch.tensor(Yp.flatten(), dtype=torch.float32, device=device)\n        z_t = torch.tensor(Zp.flatten(), dtype=torch.float32, device=device)\n        t_t = torch.tensor(Tp.flatten(), dtype=torch.float32, device=device)\n\n        U_pred_norm = model(x_t, y_t, z_t, t_t).cpu().numpy().reshape(\n            nx_plot, ny_plot, nz_plot, nt_plot\n        )\n\n        # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u044b\n        U_pred_physical = convert_to_physical_temperature(U_pred_norm)\n\n    print(\"\\n\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u0439...\")\n    mode_title = \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439\" if mode == \"continuous\" else \"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439\"\n    title = f'PINN Solution: \u041d\u0430\u0433\u0440\u0435\u0432 \u043a\u0432\u0430\u0440\u0446\u0430 \u043b\u0430\u0437\u0435\u0440\u043e\u043c\\n{mode_title} \u0440\u0435\u0436\u0438\u043c, \u0421\u0422\u0410\u0422\u0418\u0427\u041d\u042b\u0419 \u043f\u0443\u0447\u043e\u043a'\n    filename = f'animations/pinn_solution_{mode}.gif'\n\n    create_animation(U_pred_norm, x_plot, y_plot, z_plot, t_plot, title, filename)\n\n    # \u0413\u0440\u0430\u0444\u0438\u043a \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f\n    plt.figure(figsize=(8,5))\n    plt.plot(loss_hist)\n    plt.yscale('log')\n    plt.title(f'\u041a\u0440\u0438\u0432\u0430\u044f \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f ({mode.capitalize()} \u0440\u0435\u0436\u0438\u043c)')\n    plt.xlabel('\u042d\u043f\u043e\u0445\u0430')\n    plt.ylabel('Loss')\n    plt.grid(True)\n    plt.tight_layout()\n    plt.savefig(f'{output_dir}/learning_curve_{mode}.png')\n    plt.show()\n\n    print(f\"\\n\u0412\u0441\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u044b \u0432 \u043f\u0430\u043f\u043a\u0435 '{output_dir}/'\")\n    print(f\"\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {np.max(U_pred_physical):.1f} K\")\n    print(f\"\u041f\u0435\u0440\u0435\u0433\u0440\u0435\u0432: {np.max(U_pred_physical) - config.INITIAL_TEMPERATURE:.1f} K\")\n    print(f\"\u0424\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: {config.SIMULATION_TIME_PHYSICAL*1e6:.1f} \u043c\u043a\u0441\")\n\n    # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b\n    np.save(f'{output_dir}/temperature_field_{mode}.npy', U_pred_physical)\n    np.save(f'{output_dir}/loss_history_{mode}.npy', loss_hist)\n\n    return model, U_pred_physical, loss_hist\n</code></pre>"},{"location":"PINN_3D_real_parms/pinn/","title":"Inn","text":""},{"location":"PINN_3D_real_parms/pinn/#PINN_3D_real_parms.pinn.PINN","title":"<code>PINN</code>","text":"<p>               Bases: <code>Module</code></p> <p>Physics-Informed Neural Network (PINN) class for solving partial differential equations.</p> <pre><code>Attributes:\n    network: The neural network used to approximate the solution.\n    layers_sizes: The sizes of the layers in the neural network.\n\nClass Methods:\n- __init__:\n</code></pre> Source code in <code>PINN_3D_real_parms/pinn.py</code> <pre><code>class PINN(nn.Module):\n    \"\"\"\n    Physics-Informed Neural Network (PINN) class for solving partial differential equations.\n\n        Attributes:\n            network: The neural network used to approximate the solution.\n            layers_sizes: The sizes of the layers in the neural network.\n\n        Class Methods:\n        - __init__:\n    \"\"\"\n\n    def __init__(self, layers_sizes):\n        \"\"\"\n        Initializes the neural network.\n\n        Args:\n            layers_sizes (list[int]): A list of integers representing the size of each layer in the network.\n\n        Initializes the following class fields:\n            network (nn.Sequential): The sequential neural network module, constructed from the provided layer sizes.\n                     It consists of linear layers and Tanh activations.\n\n        Returns:\n            None\n\n        The network is initialized to learn complex relationships within data, enabling the model to approximate functions \n        and ultimately solve the underlying physical problems related to laser processing.\n        \"\"\"\n        super().__init__()\n        layers = []\n        for i in range(len(layers_sizes) - 1):\n            layers.append(nn.Linear(layers_sizes[i], layers_sizes[i + 1]))\n            if i &lt; len(layers_sizes) - 2:\n                layers.append(nn.Tanh())\n        self.network = nn.Sequential(*layers)\n\n    def forward(self, x_tensor, y_tensor, z_tensor, t_tensor):\n        \"\"\"\n        Passes input tensors through the network to obtain a prediction.\n\n        Combines the input tensors into a single tensor and uses it as input for the neural network. This allows the network to consider all input variables simultaneously when making a prediction.\n\n        Args:\n            x_tensor (torch.Tensor): The first input tensor representing one of the input variables.\n            y_tensor (torch.Tensor): The second input tensor representing one of the input variables.\n            z_tensor (torch.Tensor): The third input tensor representing one of the input variables.\n            t_tensor (torch.Tensor): The fourth input tensor representing one of the input variables.\n\n        Returns:\n            torch.Tensor: The output of the network, representing the prediction based on the combined input.\n        \"\"\"\n        inputs = torch.stack([x_tensor, y_tensor, z_tensor, t_tensor], dim=1)\n        return self.network(inputs)\n</code></pre>"},{"location":"PINN_3D_real_parms/pinn/#PINN_3D_real_parms.pinn.PINN.__init__","title":"<code>__init__(layers_sizes)</code>","text":"<p>Initializes the neural network.</p> <p>Parameters:</p> Name Type Description Default <code>layers_sizes</code> <code>list[int]</code> <p>A list of integers representing the size of each layer in the network.</p> required Initializes the following class fields <p>network (nn.Sequential): The sequential neural network module, constructed from the provided layer sizes.          It consists of linear layers and Tanh activations.</p> <p>Returns:</p> Type Description <p>None</p> <p>The network is initialized to learn complex relationships within data, enabling the model to approximate functions  and ultimately solve the underlying physical problems related to laser processing.</p> Source code in <code>PINN_3D_real_parms/pinn.py</code> <pre><code>def __init__(self, layers_sizes):\n    \"\"\"\n    Initializes the neural network.\n\n    Args:\n        layers_sizes (list[int]): A list of integers representing the size of each layer in the network.\n\n    Initializes the following class fields:\n        network (nn.Sequential): The sequential neural network module, constructed from the provided layer sizes.\n                 It consists of linear layers and Tanh activations.\n\n    Returns:\n        None\n\n    The network is initialized to learn complex relationships within data, enabling the model to approximate functions \n    and ultimately solve the underlying physical problems related to laser processing.\n    \"\"\"\n    super().__init__()\n    layers = []\n    for i in range(len(layers_sizes) - 1):\n        layers.append(nn.Linear(layers_sizes[i], layers_sizes[i + 1]))\n        if i &lt; len(layers_sizes) - 2:\n            layers.append(nn.Tanh())\n    self.network = nn.Sequential(*layers)\n</code></pre>"},{"location":"PINN_3D_real_parms/pinn/#PINN_3D_real_parms.pinn.PINN.forward","title":"<code>forward(x_tensor, y_tensor, z_tensor, t_tensor)</code>","text":"<p>Passes input tensors through the network to obtain a prediction.</p> <p>Combines the input tensors into a single tensor and uses it as input for the neural network. This allows the network to consider all input variables simultaneously when making a prediction.</p> <p>Parameters:</p> Name Type Description Default <code>x_tensor</code> <code>Tensor</code> <p>The first input tensor representing one of the input variables.</p> required <code>y_tensor</code> <code>Tensor</code> <p>The second input tensor representing one of the input variables.</p> required <code>z_tensor</code> <code>Tensor</code> <p>The third input tensor representing one of the input variables.</p> required <code>t_tensor</code> <code>Tensor</code> <p>The fourth input tensor representing one of the input variables.</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The output of the network, representing the prediction based on the combined input.</p> Source code in <code>PINN_3D_real_parms/pinn.py</code> <pre><code>def forward(self, x_tensor, y_tensor, z_tensor, t_tensor):\n    \"\"\"\n    Passes input tensors through the network to obtain a prediction.\n\n    Combines the input tensors into a single tensor and uses it as input for the neural network. This allows the network to consider all input variables simultaneously when making a prediction.\n\n    Args:\n        x_tensor (torch.Tensor): The first input tensor representing one of the input variables.\n        y_tensor (torch.Tensor): The second input tensor representing one of the input variables.\n        z_tensor (torch.Tensor): The third input tensor representing one of the input variables.\n        t_tensor (torch.Tensor): The fourth input tensor representing one of the input variables.\n\n    Returns:\n        torch.Tensor: The output of the network, representing the prediction based on the combined input.\n    \"\"\"\n    inputs = torch.stack([x_tensor, y_tensor, z_tensor, t_tensor], dim=1)\n    return self.network(inputs)\n</code></pre>"},{"location":"PINN_3D_real_parms/pinn/#PINN_3D_real_parms.pinn.compute_pinn_loss","title":"<code>compute_pinn_loss(model, x_coll, y_coll, z_coll, t_coll, diff_coef, laser_mode=None)</code>","text":"<p>Computes the loss for a Physics-Informed Neural Network (PINN) model simulating laser-induced heat transfer.</p> <p>The loss function incorporates terms for the partial differential equation (PDE) representing heat conduction, initial conditions, and boundary conditions. It calculates gradients of the model's output with respect to space and time to enforce the PDE.  The loss is minimized during training to find a model that accurately represents the temperature distribution within the material.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The PINN model being trained.</p> required <code>x_coll</code> <code>Tensor</code> <p>Tensor of x-coordinates for collocation points.</p> required <code>y_coll</code> <code>Tensor</code> <p>Tensor of y-coordinates for collocation points.</p> required <code>z_coll</code> <code>Tensor</code> <p>Tensor of z-coordinates for collocation points.</p> required <code>t_coll</code> <code>Tensor</code> <p>Tensor of time values for collocation points.</p> required <code>diff_coef</code> <p>Diffusion coefficient for the heat equation.</p> required <code>laser_mode</code> <p>Specifies the laser operation mode (\"pulsed\" or \"continuous\"). If None, the mode is taken from the configuration.</p> <code>None</code> <p>Returns:</p> Type Description <p>The computed loss value (a scalar tensor).</p> Source code in <code>PINN_3D_real_parms/pinn.py</code> <pre><code>def compute_pinn_loss(model, x_coll: torch.Tensor, y_coll: torch.Tensor, z_coll: torch.Tensor, \n                     t_coll: torch.Tensor, diff_coef, laser_mode=None):\n    \"\"\"\n    Computes the loss for a Physics-Informed Neural Network (PINN) model simulating laser-induced heat transfer.\n\n    The loss function incorporates terms for the partial differential equation (PDE) representing heat conduction, initial conditions, and boundary conditions. It calculates gradients of the model's output with respect to space and time to enforce the PDE.  The loss is minimized during training to find a model that accurately represents the temperature distribution within the material.\n\n    Args:\n        model: The PINN model being trained.\n        x_coll: Tensor of x-coordinates for collocation points.\n        y_coll: Tensor of y-coordinates for collocation points.\n        z_coll: Tensor of z-coordinates for collocation points.\n        t_coll: Tensor of time values for collocation points.\n        diff_coef: Diffusion coefficient for the heat equation.\n        laser_mode:  Specifies the laser operation mode (\"pulsed\" or \"continuous\"). If None, the mode is taken from the configuration.\n\n    Returns:\n        The computed loss value (a scalar tensor).\n    \"\"\"\n    coef_tensor = torch.tensor(diff_coef, dtype=x_coll.dtype, device=x_coll.device)\n\n    if laser_mode is None:\n        laser_mode = config.LASER_MODE\n\n    x_coll.requires_grad_(True)\n    y_coll.requires_grad_(True)\n    z_coll.requires_grad_(True)\n    t_coll.requires_grad_(True)\n\n    u = model(x_coll, y_coll, z_coll, t_coll)\n\n    u_t = torch.autograd.grad(u, t_coll, grad_outputs=torch.ones_like(u), create_graph=True)[0]\n\n    u_x = torch.autograd.grad(u, x_coll, grad_outputs=torch.ones_like(u), create_graph=True)[0]\n    u_xx = torch.autograd.grad(u_x, x_coll, grad_outputs=torch.ones_like(u_x), create_graph=True)[0]\n\n    u_y = torch.autograd.grad(u, y_coll, grad_outputs=torch.ones_like(u), create_graph=True)[0]\n    u_yy = torch.autograd.grad(u_y, y_coll, grad_outputs=torch.ones_like(u_y), create_graph=True)[0]\n\n    u_z = torch.autograd.grad(u, z_coll, grad_outputs=torch.ones_like(u), create_graph=True)[0]\n    u_zz = torch.autograd.grad(u_z, z_coll, grad_outputs=torch.ones_like(u_z), create_graph=True)[0]    \n\n    # \u0418\u0441\u0442\u043e\u0447\u043d\u0438\u043a \u0442\u0435\u043f\u043b\u0430 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0430 \u043b\u0430\u0437\u0435\u0440\u0430\n    source_term = laser_source_term(x_coll, y_coll, z_coll, t_coll, laser_mode=laser_mode)\n\n    # \u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0435 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438\n    loss_pde = torch.mean((u_t - coef_tensor * (u_xx + u_yy + u_zz) - source_term) ** 2)\n\n    # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u0435\n    t0 = torch.zeros_like(x_coll)\n    u_ic = model(x_coll, y_coll, z_coll, t0)\n    u_ic_true = torch.zeros_like(u_ic)\n    loss_ic = torch.mean((u_ic - u_ic_true) ** 2)\n\n    loss_bc = 0.0\n    # \u0413\u0440\u0430\u043d\u0438\u0447\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f \u041d\u0435\u0439\u043c\u0430\u043d\u0430 (\u043d\u0443\u043b\u0435\u0432\u043e\u0439 \u043f\u043e\u0442\u043e\u043a) \u043d\u0430 \u0432\u0441\u0435\u0445 \u0433\u0440\u0430\u043d\u0438\u0446\u0430\u0445\n\n    # \u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e x (\u043b\u0435\u0432\u0430\u044f \u0438 \u043f\u0440\u0430\u0432\u0430\u044f)\n    x_left = -torch.ones_like(x_coll).requires_grad_(True)\n    x_right = torch.ones_like(x_coll).requires_grad_(True)\n\n    u_left = model(x_left, y_coll, z_coll, t_coll)\n    u_right = model(x_right, y_coll, z_coll, t_coll)\n\n    u_left_x = torch.autograd.grad(u_left, x_left, \n                                 grad_outputs=torch.ones_like(u_left), \n                                 create_graph=True, retain_graph=True)[0]\n    u_right_x = torch.autograd.grad(u_right, x_right, \n                                  grad_outputs=torch.ones_like(u_right), \n                                  create_graph=True, retain_graph=True)[0]\n\n    loss_bc += torch.mean(u_left_x ** 2) + torch.mean(u_right_x ** 2)  # \u2202u/\u2202x = 0\n\n    # \u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e y (\u043d\u0438\u0436\u043d\u044f\u044f \u0438 \u0432\u0435\u0440\u0445\u043d\u044f\u044f)\n    y_bottom = -torch.ones_like(y_coll).requires_grad_(True)\n    y_top = torch.ones_like(y_coll).requires_grad_(True)\n\n    u_bottom = model(x_coll, y_bottom, z_coll, t_coll)\n    u_top = model(x_coll, y_top, z_coll, t_coll)\n\n    u_bottom_y = torch.autograd.grad(u_bottom, y_bottom, \n                                   grad_outputs=torch.ones_like(u_bottom), \n                                   create_graph=True, retain_graph=True)[0]\n    u_top_y = torch.autograd.grad(u_top, y_top, \n                                grad_outputs=torch.ones_like(u_top), \n                                create_graph=True, retain_graph=True)[0]\n\n    loss_bc += torch.mean(u_bottom_y ** 2) + torch.mean(u_top_y ** 2)  # \u2202u/\u2202y = 0\n\n    # \u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e z (\u043d\u0438\u0436\u043d\u044f\u044f \u0438 \u0432\u0435\u0440\u0445\u043d\u044f\u044f)\n    z_bottom = torch.zeros_like(z_coll).requires_grad_(True)\n    z_top = torch.ones_like(z_coll).requires_grad_(True)\n\n    u_bottom_z = model(x_coll, y_coll, z_bottom, t_coll)\n    u_top_z = model(x_coll, y_coll, z_top, t_coll)\n\n    u_bottom_z_deriv = torch.autograd.grad(u_bottom_z, z_bottom, \n                                         grad_outputs=torch.ones_like(u_bottom_z), \n                                         create_graph=True, retain_graph=True)[0]\n    u_top_z_deriv = torch.autograd.grad(u_top_z, z_top, \n                                      grad_outputs=torch.ones_like(u_top_z), \n                                      create_graph=True, retain_graph=True)[0]\n\n    loss_bc += torch.mean(u_bottom_z_deriv ** 2) + torch.mean(u_top_z_deriv ** 2)  # \u2202u/\u2202z = 0\n\n    w_pde, w_ic, w_bc = 1.0, 1.0, 2.0\n\n    return w_pde * loss_pde + w_ic * loss_ic + w_bc * loss_bc\n</code></pre>"},{"location":"PINN_3D_real_parms/pinn/#PINN_3D_real_parms.pinn.train_pinn","title":"<code>train_pinn(model, diff_coef, num_epochs=200, lr=0.001, device='cpu', laser_mode=None)</code>","text":"<p>Trains a Physics-Informed Neural Network (PINN) to model laser-induced heat transfer.</p> <p>This method performs the training of the PINN model using an optimization process  to minimize the discrepancy between the model's predictions and the underlying  physical equations governing heat transfer. It iterates through a specified  number of epochs, calculating the loss and updating the model's parameters  accordingly. The training process considers the chosen laser mode to accurately  simulate the heat distribution.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The PINN model to be trained.</p> required <code>diff_coef</code> <p>Diffusion coefficient used in the heat transfer equation.</p> required <code>num_epochs</code> <code>int</code> <p>The number of training epochs. Defaults to 200.</p> <code>200</code> <code>lr</code> <code>float</code> <p>The learning rate for the optimizer. Defaults to 1e-3.</p> <code>0.001</code> <code>device</code> <code>str</code> <p>The device to use for training ('cpu' or 'cuda'). Defaults to 'cpu'.</p> <code>'cpu'</code> <code>laser_mode</code> <code>str</code> <p>The laser mode (\"pulsed\" or \"continuous\").                           If None, the mode is taken from the configuration.                           Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list containing the loss value for each epoch during training.</p> Source code in <code>PINN_3D_real_parms/pinn.py</code> <pre><code>def train_pinn(model, diff_coef, num_epochs=200, lr=1e-3, device='cpu', laser_mode=None):\n    \"\"\"\n    Trains a Physics-Informed Neural Network (PINN) to model laser-induced heat transfer.\n\n    This method performs the training of the PINN model using an optimization process \n    to minimize the discrepancy between the model's predictions and the underlying \n    physical equations governing heat transfer. It iterates through a specified \n    number of epochs, calculating the loss and updating the model's parameters \n    accordingly. The training process considers the chosen laser mode to accurately \n    simulate the heat distribution.\n\n    Args:\n        model: The PINN model to be trained.\n        diff_coef: Diffusion coefficient used in the heat transfer equation.\n        num_epochs (int, optional): The number of training epochs. Defaults to 200.\n        lr (float, optional): The learning rate for the optimizer. Defaults to 1e-3.\n        device (str, optional): The device to use for training ('cpu' or 'cuda'). Defaults to 'cpu'.\n        laser_mode (str, optional): The laser mode (\"pulsed\" or \"continuous\"). \n                                     If None, the mode is taken from the configuration. \n                                     Defaults to None.\n\n    Returns:\n        list: A list containing the loss value for each epoch during training.\n    \"\"\"\n    model.to(device)\n    optimizer = optim.Adam(model.parameters(), lr=lr)\n\n    if laser_mode is None:\n        laser_mode = config.LASER_MODE\n\n    # \u041e\u0431\u043b\u0430\u0441\u0442\u044c \u0432 \u0431\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u044b\u0445 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u0445\n    nx, ny, nz, nt = 20, 20, 20, 20\n    x = torch.linspace(-1, 1, nx, device=device)  # \u00b11 \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430\n    y = torch.linspace(-1, 1, ny, device=device)  # \u00b11 \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430  \n    z = torch.linspace(0, 1, nz, device=device) \n    t = torch.linspace(0, config.SIMULATION_TIME_NORM, nt, device=device)  \n\n    X, Y, Z, T = torch.meshgrid(x, y, z, t, indexing='ij')\n    x_coll = X.flatten()\n    y_coll = Y.flatten()\n    z_coll = Z.flatten()\n    t_coll = T.flatten()\n\n    history = []\n    for epoch in tqdm(range(1, num_epochs+1)):\n        optimizer.zero_grad()\n        loss = compute_pinn_loss(model, x_coll, y_coll, z_coll, t_coll, \n                                diff_coef, laser_mode=laser_mode)\n        loss.backward()\n        optimizer.step()\n        history.append(loss.item())\n        if epoch % 100 == 0:\n            print(f\"Epoch {epoch}/{num_epochs}, Loss={loss:.3e}, Mode={laser_mode}\")\n    return history\n</code></pre>"},{"location":"PINN_3D_real_parms/saving_models/","title":"Saving Models","text":""},{"location":"PINN_3D_real_parms/saving_models/#PINN_3D_real_parms.saving_models.load_model","title":"<code>load_model(path='model.pth', device='cpu', optimizer=None)</code>","text":"<p>Loads a pre-trained model and associated information from a checkpoint file.</p> <p>This method reconstructs the model architecture, loads the trained weights, and optionally restores the optimizer state, allowing for resuming training or performing inference with a previously saved model.  It facilitates  reusing and continuing work from saved states, avoiding redundant training.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the checkpoint file (e.g., 'model.pth').</p> <code>'model.pth'</code> <code>device</code> <code>str</code> <p>The device to load the model onto (e.g., 'cpu', 'cuda').</p> <code>'cpu'</code> <code>optimizer</code> <code>Optimizer</code> <p>An optimizer instance.  If provided and the checkpoint contains optimizer state, the  optimizer's state is loaded. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - model: The loaded PyTorch model. - checkpoint: The complete checkpoint dictionary loaded from the file,   containing model architecture, state dictionary, and potentially   optimizer state, epoch number, and loss value.</p> Source code in <code>PINN_3D_real_parms/saving_models.py</code> <pre><code>def load_model(path='model.pth', device='cpu', optimizer=None):\n    \"\"\"\n    Loads a pre-trained model and associated information from a checkpoint file.\n\n    This method reconstructs the model architecture, loads the trained weights,\n    and optionally restores the optimizer state, allowing for resuming training\n    or performing inference with a previously saved model.  It facilitates \n    reusing and continuing work from saved states, avoiding redundant training.\n\n    Args:\n        path (str): The path to the checkpoint file (e.g., 'model.pth').\n        device (str): The device to load the model onto (e.g., 'cpu', 'cuda').\n        optimizer (torch.optim.Optimizer, optional): An optimizer instance. \n            If provided and the checkpoint contains optimizer state, the \n            optimizer's state is loaded. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing:\n            - model: The loaded PyTorch model.\n            - checkpoint: The complete checkpoint dictionary loaded from the file,\n              containing model architecture, state dictionary, and potentially\n              optimizer state, epoch number, and loss value.\n    \"\"\"\n    checkpoint = torch.load(path, map_location=device)\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u043e\u0434\u0435\u043b\u044c \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043d\u043e\u0439 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u043e\u0439\n    model = PINN(checkpoint['model_architecture'])\n    model.load_state_dict(checkpoint['model_state_dict'])\n    model.to(device)\n    model.eval()\n\n    # \u0412\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0442\u043e\u0440\u0430 \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\n    if optimizer is not None and 'optimizer_state_dict' in checkpoint:\n        optimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n\n    print(f\"\u041c\u043e\u0434\u0435\u043b\u044c \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u0430: {path}\")\n    if 'epoch' in checkpoint:\n        print(f\"\u042d\u043f\u043e\u0445\u0430: {checkpoint['epoch']}\")\n    if 'loss' in checkpoint:\n        print(f\"Loss: {checkpoint['loss']:.4e}\")\n\n    return model, checkpoint\n</code></pre>"},{"location":"PINN_3D_real_parms/saving_models/#PINN_3D_real_parms.saving_models.save_model","title":"<code>save_model(model, path='model.pth', optimizer=None, epoch=None, loss=None)</code>","text":"<p>Saves the model and related training information to a file.</p> <p>This allows resuming training from a specific point or using a pre-trained model. The model's architecture is also saved to ensure consistent reconstruction.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The PyTorch model instance to be saved.</p> required <code>path</code> <code>str</code> <p>The file path to save the model checkpoint. Defaults to 'model.pth'.</p> <code>'model.pth'</code> <code>optimizer</code> <code>Optimizer</code> <p>The optimizer instance used during training.                                           If provided, its state is also saved. Defaults to None.</p> <code>None</code> <code>epoch</code> <code>int</code> <p>The current epoch number. If provided, it's saved in the checkpoint. Defaults to None.</p> <code>None</code> <code>loss</code> <code>float</code> <p>The current loss value. If provided, it's saved in the checkpoint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/saving_models.py</code> <pre><code>def save_model(model, path='model.pth', optimizer=None, epoch=None, loss=None):\n    \"\"\"\n    Saves the model and related training information to a file.\n\n    This allows resuming training from a specific point or using a pre-trained model.\n    The model's architecture is also saved to ensure consistent reconstruction.\n\n    Args:\n        model: The PyTorch model instance to be saved.\n        path (str, optional): The file path to save the model checkpoint. Defaults to 'model.pth'.\n        optimizer (torch.optim.Optimizer, optional): The optimizer instance used during training. \n                                                     If provided, its state is also saved. Defaults to None.\n        epoch (int, optional): The current epoch number. If provided, it's saved in the checkpoint. Defaults to None.\n        loss (float, optional): The current loss value. If provided, it's saved in the checkpoint. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    checkpoint = {\n        'model_state_dict': model.state_dict(),\n        'model_architecture': [4, 128, 128, 128, 1]  # \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0443\n    }\n\n    if optimizer is not None:\n        checkpoint['optimizer_state_dict'] = optimizer.state_dict()\n    if epoch is not None:\n        checkpoint['epoch'] = epoch\n    if loss is not None:\n        checkpoint['loss'] = loss\n\n    torch.save(checkpoint, path)\n    print(f\"\u041c\u043e\u0434\u0435\u043b\u044c \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430: {path}\")\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/","title":"Visual","text":""},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.add_isotherm_plot","title":"<code>add_isotherm_plot(ax, U_physical, x_phys, y_phys, z_phys, time_idx, isotherm_temp=1900, mode_text='', power_text='', beam_radius_um=None)</code>","text":"<p>Plots an isotherm on the depth and width of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>The axes object to draw on.</p> required <code>U_physical</code> <p>The physical temperature field.</p> required <code>x_phys</code> <p>Physical x coordinates (\u00b5m).</p> required <code>y_phys</code> <p>Physical y coordinates (\u00b5m).</p> required <code>z_phys</code> <p>Physical z coordinates (depth, \u00b5m).</p> required <code>time_idx</code> <p>The time index.</p> required <code>isotherm_temp</code> <p>The temperature of the isotherm (K). Defaults to 1900.</p> <code>1900</code> <code>mode_text</code> <p>Text describing the mode. Defaults to \"\".</p> <code>''</code> <code>power_text</code> <p>Text describing the power. Defaults to \"\".</p> <code>''</code> <code>beam_radius_um</code> <p>The beam radius in \u00b5m. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def add_isotherm_plot(ax, U_physical, x_phys, y_phys, z_phys, time_idx, \n                     isotherm_temp=1900, mode_text=\"\", power_text=\"\", \n                     beam_radius_um=None):\n    \"\"\"\n    Plots an isotherm on the depth and width of the simulation.\n\n    Args:\n        ax: The axes object to draw on.\n        U_physical: The physical temperature field.\n        x_phys: Physical x coordinates (\u00b5m).\n        y_phys: Physical y coordinates (\u00b5m).\n        z_phys: Physical z coordinates (depth, \u00b5m).\n        time_idx: The time index.\n        isotherm_temp: The temperature of the isotherm (K). Defaults to 1900.\n        mode_text: Text describing the mode. Defaults to \"\".\n        power_text: Text describing the power. Defaults to \"\".\n        beam_radius_um: The beam radius in \u00b5m. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # \u0426\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b\n    center_x = len(x_phys) // 2\n    center_y = len(y_phys) // 2\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438 (z = max)\n    surface_z_idx = -1\n    temp_surface = U_physical[:, :, surface_z_idx, time_idx]\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0443\u0440\u044b \u0434\u043b\u044f \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n    X_surf, Y_surf = np.meshgrid(x_phys, y_phys)\n\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043a\u043e\u043d\u0442\u0443\u0440 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n    if np.max(temp_surface) &gt;= isotherm_temp:\n        contour_levels = [isotherm_temp]\n        cs = ax.contour(X_surf, Y_surf, temp_surface.T, levels=contour_levels, \n                       colors='white', linewidths=2.5, linestyles='-', alpha=0.9)\n\n        # \u0415\u0441\u043b\u0438 \u043a\u043e\u043d\u0442\u0443\u0440 \u043d\u0430\u0439\u0434\u0435\u043d, \u0437\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044e\u044e \u043e\u0431\u043b\u0430\u0441\u0442\u044c\n        # \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 API \u0434\u043b\u044f matplotlib\n        paths = cs.get_paths()\n        if len(paths) &gt; 0:\n            for path in paths:\n                vertices = path.vertices\n                if len(vertices) &gt; 2:\n                    # \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u043e\u043d\u0442\u0443\u0440\u0430\n                    polygon = Polygon(vertices, closed=True, fill=True, \n                                     facecolor='lime', alpha=0.3, \n                                     edgecolor='lime', linewidth=1)\n                    ax.add_patch(polygon)\n\n                    # \u041f\u043e\u0434\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0443\n                    if len(vertices) &gt; 10:\n                        # \u0411\u0435\u0440\u0435\u043c \u0442\u043e\u0447\u043a\u0443 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u043f\u043e\u0441\u0435\u0440\u0435\u0434\u0438\u043d\u0435 \u043a\u043e\u043d\u0442\u0443\u0440\u0430\n                        mid_idx = len(vertices) // 2\n                        x_mid, y_mid = vertices[mid_idx]\n                        ax.text(x_mid, y_mid, f'{isotherm_temp} K', \n                               color='lime', fontsize=9, fontweight='bold',\n                               ha='center', va='center',\n                               bbox=dict(boxstyle=\"round,pad=0.2\", \n                                        facecolor=\"black\", alpha=0.5))\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    temp_profile = U_physical[center_x, center_y, :, time_idx]\n\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0433\u043b\u0443\u0431\u0438\u043d\u0443, \u0433\u0434\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0434\u043e\u0441\u0442\u0438\u0433\u0430\u0435\u0442 isotherm_temp\n    depth_at_isotherm = None\n    for i in range(len(z_phys)-1, -1, -1):\n        if temp_profile[i] &gt;= isotherm_temp:\n            depth_at_isotherm = z_phys[i]\n            break\n\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0448\u0438\u0440\u0438\u043d\u0443 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438, \u0433\u0434\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0434\u043e\u0441\u0442\u0438\u0433\u0430\u0435\u0442 isotherm_temp\n    width_at_isotherm = None\n    if np.max(temp_surface) &gt;= isotherm_temp:\n        # \u041f\u0440\u043e\u0445\u043e\u0434\u0438\u043c \u043e\u0442 \u0446\u0435\u043d\u0442\u0440\u0430 \u043a \u043a\u0440\u0430\u044e\n        for i in range(center_x, len(x_phys)):\n            if temp_surface[i, center_y] &lt; isotherm_temp:\n                width_at_isotherm = abs(x_phys[i])\n                break\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0435\n    info_text = f\"\u0418\u0417\u041e\u0422\u0415\u0420\u041c\u0410 {isotherm_temp} K:\\n\"\n    if depth_at_isotherm is not None:\n        info_text += f\"\u0413\u043b\u0443\u0431\u0438\u043d\u0430: {depth_at_isotherm:.1f} \u043c\u043a\u043c\\n\"\n    else:\n        info_text += f\"\u0413\u043b\u0443\u0431\u0438\u043d\u0430: \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\\n\"\n\n    if width_at_isotherm is not None:\n        info_text += f\"\u0428\u0438\u0440\u0438\u043d\u0430: {width_at_isotherm:.1f} \u043c\u043a\u043c\"\n    else:\n        info_text += f\"\u0428\u0438\u0440\u0438\u043d\u0430: \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\"\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e\n    ax.text(0.02, 0.98, info_text, transform=ax.transAxes,\n            fontsize=10, verticalalignment='top',\n            bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"black\", alpha=0.7,\n                     edgecolor='lime'))\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u043a\u0440\u0435\u0441\u0442\u0438\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax.axhline(y=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n    ax.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n    ax.plot(0, 0, 'w+', markersize=10, markeredgewidth=1.5)\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a\u0440\u0443\u0433 \u0440\u0430\u0434\u0438\u0443\u0441\u0430 \u043f\u0443\u0447\u043a\u0430 \u0435\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d\n    if beam_radius_um is not None:\n        circle = Circle((0, 0), beam_radius_um, fill=False, color='cyan', \n                       linestyle='-', linewidth=1.5, alpha=0.7)\n        ax.add_patch(circle)\n\n    # \u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\n    ax.set_title(f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 {isotherm_temp} K \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\\n\u0413\u043b\u0443\u0431\u0438\u043d\u0430/\u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b \u043d\u0430\u0433\u0440\u0435\u0432\u0430', fontsize=11)\n    ax.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n    ax.set_ylabel('y (\u043c\u043a\u043c)', fontsize=10)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.create_animation","title":"<code>create_animation(U_data, x_plot, y_plot, z_plot, t_plot, title, filename)</code>","text":"<p>\u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u044e, \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044e\u0449\u0443\u044e \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u043e\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435,  \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u043c \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b.  \u0410\u043d\u0438\u043c\u0430\u0446\u0438\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0441\u0440\u0435\u0437\u044b \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044f\u0445 \u0438 \u043d\u0430 \u0440\u0430\u0437\u043d\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445,  \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0430\u043d\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0443 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0438 \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438. \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043a\u0430\u043a \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e, \u0442\u0430\u043a \u0438 \u0434\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def create_animation(U_data, x_plot, y_plot, z_plot, t_plot, title, filename):\n    \"\"\"\n    \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u044e, \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044e\u0449\u0443\u044e \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u043e\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435, \n    \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u043c \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043d\u0430 \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b. \n    \u0410\u043d\u0438\u043c\u0430\u0446\u0438\u044f \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0441\u0440\u0435\u0437\u044b \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044f\u0445 \u0438 \u043d\u0430 \u0440\u0430\u0437\u043d\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445, \n    \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0430\u043d\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0443 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0438 \u0442\u0435\u043f\u043b\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u043d\u043e\u0441\u0442\u0438.\n    \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043a\u0430\u043a \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e, \u0442\u0430\u043a \u0438 \u0434\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f.\n    \"\"\"\n    # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u044b\n    U_physical = convert_to_physical_temperature(U_data)\n    (x_phys_min, x_phys_max), (y_phys_min, y_phys_max), (z_phys_min, z_phys_max) = get_physical_extent(\n        [x_plot[0], x_plot[-1]], [y_plot[0], y_plot[-1]], [z_plot[0], z_plot[-1]]\n    )\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u044b \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\n    x_phys = np.linspace(x_phys_min, x_phys_max, len(x_plot))\n    y_phys = np.linspace(y_phys_min, y_phys_max, len(y_plot))\n    z_phys = np.linspace(z_phys_min, z_phys_max, len(z_plot))\n\n    t_phys = t_plot * config.CHARACTERISTIC_TIME * 1e6  # \u043c\u043a\u0441\n\n    # \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u0434\u043b\u044f \u0441\u0440\u0435\u0437\u043e\u0432 \u043d\u0430 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445 10, 20, 30 \u043c\u043a\u043c\n    z_phys_values = np.array(z_plot) * config.CHARACTERISTIC_LENGTH * 1e6  # \u0432\u0441\u0435 \u0433\u043b\u0443\u0431\u0438\u043d\u044b \u0432 \u043c\u043a\u043c\n    target_depths = [10, 20, 30]  # \u0446\u0435\u043b\u0435\u0432\u044b\u0435 \u0433\u043b\u0443\u0431\u0438\u043d\u044b \u0432 \u043c\u043a\u043c\n\n    depth_indices = []\n    actual_depths = []\n    for depth in target_depths:\n        idx = np.argmin(np.abs(z_phys_values - depth))\n        depth_indices.append(idx)\n        actual_depths.append(z_phys_values[idx])\n\n    fig = plt.figure(figsize=(25, 14))  # \u0423\u0432\u0435\u043b\u0438\u0447\u0438\u043b\u0438 \u0432\u044b\u0441\u043e\u0442\u0443 \u0434\u043b\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0433\u0440\u0430\u0444\u0438\u043a\u0430\n\n    def update(frame):\n        fig.clear()\n\n        current_time_phys = t_phys[frame]\n\n        # 1. XY \u0441\u0440\u0435\u0437 (\u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c)\n        ax1 = fig.add_subplot(3, 5, 1)\n        slice_idx_xy = len(z_plot) - 1  # \u041f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c (z = max)\n        data_xy = U_physical[:, :, slice_idx_xy, frame].T\n\n        im1 = ax1.imshow(data_xy, extent=[x_phys_min, x_phys_max, y_phys_min, y_phys_max], \n                        origin='lower', aspect='auto', cmap='hot', \n                        vmin=config.INITIAL_TEMPERATURE, vmax=np.max(U_physical))\n        ax1.set_title('XY \u0441\u0440\u0435\u0437 (\u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c)', fontsize=11)\n        ax1.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n        ax1.set_ylabel('y (\u043c\u043a\u043c)', fontsize=10)\n\n        # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043f\u0435\u0440\u0435\u043a\u0440\u0435\u0441\u0442\u0438\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n        ax1.axhline(y=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n        ax1.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n        ax1.plot(0, 0, 'w+', markersize=10, markeredgewidth=1.5)\n\n        # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u0440\u0443\u0433 \u0440\u0430\u0434\u0438\u0443\u0441\u0430 \u043f\u0443\u0447\u043a\u0430\n        beam_radius_um = config.LASER_BEAM_RADIUS * 1e6\n        circle = Circle((0, 0), beam_radius_um, fill=False, color='cyan', \n                       linestyle='-', linewidth=1.5, alpha=0.7)\n        ax1.add_patch(circle)\n\n        plt.colorbar(im1, ax=ax1, shrink=0.8, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n        # 2. XZ \u0441\u0440\u0435\u0437\n        ax2 = fig.add_subplot(3, 5, 2)\n        slice_idx_xz = len(y_plot) // 2\n        data_xz = U_physical[:, slice_idx_xz, :, frame].T\n\n        im2 = ax2.imshow(data_xz, extent=[x_phys_min, x_phys_max, z_phys_min, z_phys_max], \n                        origin='lower', aspect='auto', cmap='hot',\n                        vmin=config.INITIAL_TEMPERATURE, vmax=np.max(U_physical))\n        ax2.set_title('XZ \u0441\u0440\u0435\u0437 (\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u044b\u0439)', fontsize=11)\n        ax2.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n        ax2.set_ylabel('z (\u043c\u043a\u043c)', fontsize=10)\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043b\u0438\u043d\u0438\u0438 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n        for depth, color in zip(actual_depths, ['cyan', 'lime', 'yellow']):\n            ax2.axhline(y=depth, color=color, linestyle='--', alpha=0.7, linewidth=1)\n\n        # \u0412\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u0430\u044f \u043b\u0438\u043d\u0438\u044f \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n        ax2.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n        plt.colorbar(im2, ax=ax2, shrink=0.8, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n        # 3. YZ \u0441\u0440\u0435\u0437\n        ax3 = fig.add_subplot(3, 5, 3)\n        slice_idx_yz = len(x_plot) // 2\n        data_yz = U_physical[slice_idx_yz, :, :, frame].T\n\n        im3 = ax3.imshow(data_yz, extent=[y_phys_min, y_phys_max, z_phys_min, z_phys_max], \n                        origin='lower', aspect='auto', cmap='hot',\n                        vmin=config.INITIAL_TEMPERATURE, vmax=np.max(U_physical))\n        ax3.set_title('YZ \u0441\u0440\u0435\u0437 (\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u044b\u0439)', fontsize=11)\n        ax3.set_xlabel('y (\u043c\u043a\u043c)', fontsize=10)\n        ax3.set_ylabel('z (\u043c\u043a\u043c)', fontsize=10)\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043b\u0438\u043d\u0438\u0438 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n        for depth, color in zip(actual_depths, ['cyan', 'lime', 'yellow']):\n            ax3.axhline(y=depth, color=color, linestyle='--', alpha=0.7, linewidth=1)\n\n        # \u0412\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u0430\u044f \u043b\u0438\u043d\u0438\u044f \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n        ax3.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n        plt.colorbar(im3, ax=ax3, shrink=0.8, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n        # 4-6. XY \u0441\u0440\u0435\u0437\u044b \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n        colors = ['cyan', 'lime', 'yellow']\n        for i, (depth_idx, depth, color) in enumerate(zip(depth_indices, actual_depths, colors)):\n            ax = fig.add_subplot(3, 5, 4 + i)\n            data_depth = U_physical[:, :, depth_idx, frame].T\n\n            im = ax.imshow(data_depth, extent=[x_phys_min, x_phys_max, y_phys_min, y_phys_max], \n                          origin='lower', aspect='auto', cmap='hot',\n                          vmin=config.INITIAL_TEMPERATURE, vmax=np.max(U_physical))\n            ax.set_title(f'XY \u0441\u0440\u0435\u0437 (z = {depth:.1f} \u043c\u043a\u043c)', fontsize=11)\n            ax.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n            ax.set_ylabel('y (\u043c\u043a\u043c)', fontsize=10)\n\n            # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u043a\u0440\u0435\u0441\u0442\u0438\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n            ax.axhline(y=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n            ax.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n\n            # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0440\u0430\u043c\u043a\u0443 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0446\u0432\u0435\u0442\u0430\n            for spine in ax.spines.values():\n                spine.set_color(color)\n                spine.set_linewidth(2)\n\n            plt.colorbar(im, ax=ax, shrink=0.8, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n        # 7. \u0413\u0440\u0430\u0444\u0438\u043a \u0441 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u043e\u0439 1900 K\n        ax7 = fig.add_subplot(3, 5, 7)\n\n        # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0440\u0435\u0436\u0438\u043c\u0430 \u0438 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438\n        mode_text = \"\u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\"\n        power_text = f\"{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\" if config.LASER_MODE == \"pulsed\" else f\"{config.LASER_CONTINUOUS_POWER} \u0412\u0442\"\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0433\u0440\u0430\u0444\u0438\u043a \u0441 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u043e\u0439\n        add_isotherm_plot(ax7, U_physical, x_phys, y_phys, z_phys, frame, \n                         isotherm_temp=1900, mode_text=mode_text, power_text=power_text,\n                         beam_radius_um=beam_radius_um)\n\n        # 8. \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043b\u0430\u0437\u0435\u0440\u0430 (\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f)\n        ax8 = fig.add_subplot(3, 5, 8)\n\n        if config.LASER_MODE == \"pulsed\":\n            # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n            t_range_norm = np.linspace(0, config.SIMULATION_TIME_NORM, 1000)\n            t_range_phys = t_range_norm * config.CHARACTERISTIC_TIME * 1e6  # \u043c\u043a\u0441\n            laser_profile = np.zeros_like(t_range_norm)\n\n            for i, t_val in enumerate(t_range_norm):\n                t_mod = t_val % config.LASER_PULSE_PERIOD_NORM\n                # \u0413\u0430\u0443\u0441\u0441\u043e\u0432 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\n                laser_profile[i] = config.LASER_AMPLITUDE * np.exp(\n                    -(t_mod - config.LASER_PULSE_PERIOD_NORM/2)**2 / \n                    (2 * config.LASER_PULSE_SIGMA_NORM**2))\n\n            ax8.plot(t_range_phys, laser_profile, 'r-', linewidth=1.5)\n            ax8.axvline(x=current_time_phys, color='blue', linestyle='--', alpha=0.8, linewidth=2)\n\n            # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0432\u0441\u0435 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u043b\u0438\u043d\u0438\u044f\u043c\u0438\n            for i in range(config.NUM_PULSES + 1):\n                impulse_time = i * config.LASER_PULSE_PERIOD_NORM * config.CHARACTERISTIC_TIME * 1e6\n                ax8.axvline(x=impulse_time, color='gray', linestyle=':', alpha=0.5, linewidth=0.8)\n                if i &lt; config.NUM_PULSES:\n                    ax8.text(impulse_time + 2, 0.8, f'{i+1}', fontsize=8, ha='left')\n\n            ax8.set_title(f'\u041b\u0430\u0437\u0435\u0440\u043d\u044b\u0435 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b ({config.NUM_PULSES} \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432)', fontsize=11)\n            ax8.set_ylim(0, 1.1)\n\n        else:\n            # \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c - \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n            t_range_norm = np.linspace(0, config.SIMULATION_TIME_NORM, 1000)\n            t_range_phys = t_range_norm * config.CHARACTERISTIC_TIME * 1e6\n            laser_profile = np.ones_like(t_range_norm) * config.LASER_AMPLITUDE\n\n            ax8.plot(t_range_phys, laser_profile, 'b-', linewidth=2)\n            ax8.axvline(x=current_time_phys, color='red', linestyle='--', alpha=0.8, linewidth=2)\n            ax8.fill_between(t_range_phys, 0, laser_profile, alpha=0.3, color='blue')\n\n            ax8.set_title('\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0439 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a', fontsize=11)\n            ax8.set_ylim(0, config.LASER_AMPLITUDE * 1.1)\n\n        ax8.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=10)\n        ax8.set_ylabel('\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=10)\n        ax8.grid(True, alpha=0.3)\n        ax8.set_xlim(0, max(t_phys))\n\n        # 9. \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0441\u0438\u0441\u0442\u0435\u043c\u0435\n        ax9 = fig.add_subplot(3, 5, 9)\n        ax9.axis('off')\n\n        if config.LASER_MODE == \"pulsed\":\n            pulse_number = min(int(t_plot[frame] // config.LASER_PULSE_PERIOD_NORM) + 1, config.NUM_PULSES)\n            time_in_pulse_norm = t_plot[frame] % config.LASER_PULSE_PERIOD_NORM\n            time_in_pulse_phys = time_in_pulse_norm * config.CHARACTERISTIC_TIME * 1e6\n        else:\n            pulse_number = 1\n            time_in_pulse_norm = t_plot[frame]\n            time_in_pulse_phys = current_time_phys\n\n        max_temp = np.max(U_physical[:, :, :, frame])\n        min_temp = np.min(U_physical[:, :, :, frame])\n\n        # \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430 \u0440\u0430\u0437\u043d\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n        temp_at_depths = []\n        for depth_idx, depth in zip(depth_indices, actual_depths):\n            temp = np.max(U_physical[:, :, depth_idx, frame])\n            temp_at_depths.append((depth, temp))\n\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n        isotherm_reached = max_temp &gt;= 1900\n        isotherm_status = \"\u0414\u0410\" if isotherm_reached else \"\u041d\u0415\u0422\"\n        isotherm_color = \"lime\" if isotherm_reached else \"red\"\n\n        info_text = f\"\u0412\u0420\u0415\u041c\u042f: {current_time_phys:.1f} \u043c\u043a\u0441\\n\"\n        info_text += \"=\" * 30 + \"\\n\"\n\n        if config.LASER_MODE == \"pulsed\":\n            info_text += f\"\u0418\u043c\u043f\u0443\u043b\u044c\u0441: {pulse_number}/{config.NUM_PULSES}\\n\"\n            info_text += f\"\u0412 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0435: {time_in_pulse_phys:.1f} \u043c\u043a\u0441\\n\"\n        else:\n            info_text += f\"\u0420\u0435\u0436\u0438\u043c: \u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\\n\"\n            info_text += f\"\u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_CONTINUOUS_POWER} \u0412\u0442\\n\"\n\n        info_text += f\"\\n\u0422\u0415\u041c\u041f\u0415\u0420\u0410\u0422\u0423\u0420\u0410:\\n\"\n        info_text += f\"\u041c\u0430\u043a\u0441: {max_temp:.1f} K\\n\"\n        info_text += f\"\u041c\u0438\u043d: {min_temp:.1f} K\\n\"\n        info_text += f\"\u041f\u0435\u0440\u0435\u0433\u0440\u0435\u0432: {max_temp - config.INITIAL_TEMPERATURE:.1f} K\\n\"\n        info_text += f\"\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f: {config.INITIAL_TEMPERATURE} K\\n\"\n\n        info_text += f\"\\n\u0418\u0417\u041e\u0422\u0415\u0420\u041c\u0410 1900 K:\\n\"\n        info_text += f\"\u0414\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430: {isotherm_status}\\n\"\n\n        info_text += f\"\\n\u041d\u0410 \u0413\u041b\u0423\u0411\u0418\u041d\u0410\u0425:\\n\"\n        for depth, temp in temp_at_depths:\n            info_text += f\"  {depth:.1f} \u043c\u043a\u043c: {temp:.1f} K\\n\"\n\n        if config.LASER_MODE == \"pulsed\":\n            if time_in_pulse_norm &lt;= config.LASER_PULSE_DURATION_NORM * 2:\n                info_text += \"\\n\u041b\u0430\u0437\u0435\u0440: \u0410\u041a\u0422\u0418\u0412\u0415\u041d\"\n            else:\n                info_text += \"\\n\u041b\u0430\u0437\u0435\u0440: \u0412\u042b\u041a\u041b\"\n        else:\n            info_text += \"\\n\u041b\u0430\u0437\u0435\u0440: \u041f\u041e\u0421\u0422\u041e\u042f\u041d\u041d\u041e \u0412\u041a\u041b\"\n\n        ax9.text(0.1, 0.5, info_text, fontsize=10, va='center', linespacing=1.4,\n                bbox=dict(boxstyle=\"round,pad=0.5\", facecolor=\"lightgray\", alpha=0.8))\n\n        # 10. \u041f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043b\u0430\u0437\u0435\u0440\u0430 (\u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b)\n        ax10 = fig.add_subplot(3, 5, 11)\n        x_profile_norm = np.linspace(-1, 1, 100)\n        x_profile_phys = x_profile_norm * config.CHARACTERISTIC_LENGTH * 1e6\n        laser_spatial = config.LASER_AMPLITUDE * np.exp(-x_profile_norm**2 / (config.LASER_SIGMA_NORM**2))\n\n        ax10.plot(x_profile_phys, laser_spatial, 'g-', linewidth=2.5)\n        ax10.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n        ax10.set_ylabel('\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=10)\n\n        beam_radius_um = config.LASER_BEAM_RADIUS * 1e6\n        ax10.set_title(f'\u041f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043f\u0443\u0447\u043a\u0430\\n(\u0440\u0430\u0434\u0438\u0443\u0441 {beam_radius_um:.0f} \u043c\u043a\u043c)', fontsize=11)\n\n        ax10.grid(True, alpha=0.3)\n        ax10.set_xlim(x_phys_min, x_phys_max)\n        ax10.set_ylim(0, 1.1)\n\n        # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430\n        ax10.axvline(x=beam_radius_um, color='cyan', linestyle='--', alpha=0.7, linewidth=1)\n        ax10.axvline(x=-beam_radius_um, color='cyan', linestyle='--', alpha=0.7, linewidth=1)\n        ax10.text(beam_radius_um, 0.5, f'{beam_radius_um:.0f} \u043c\u043a\u043c', \n                fontsize=9, color='cyan', ha='left')\n\n        # 11. \u0413\u0440\u0430\u0444\u0438\u043a \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435\n        ax11 = fig.add_subplot(3, 5, 12)\n        center_x = len(x_plot) // 2\n        center_y = len(y_plot) // 2\n        temp_vs_depth = U_physical[center_x, center_y, :, frame]\n\n        ax11.plot(temp_vs_depth, z_phys_values, 'b-', linewidth=2.5)\n        ax11.set_xlabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=10)\n        ax11.set_ylabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 z (\u043c\u043a\u043c)', fontsize=10)\n        ax11.set_title('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435\\n(\u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043f\u0443\u0447\u043a\u0430)', fontsize=11)\n        ax11.grid(True, alpha=0.3)\n        ax11.set_ylim(z_phys_min, z_phys_max)\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u0443\u044e \u043b\u0438\u043d\u0438\u044e \u0434\u043b\u044f \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n        ax11.axhline(y=0, color='lime', linestyle='-', alpha=0.5, linewidth=1)\n        ax11.axvline(x=1900, color='lime', linestyle='-', alpha=0.5, linewidth=1, \n                    label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043c\u0430\u0440\u043a\u0435\u0440\u044b \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n        for depth, color in zip(actual_depths, ['cyan', 'lime', 'yellow']):\n            depth_idx = np.argmin(np.abs(z_phys_values - depth))\n            temp = temp_vs_depth[depth_idx]\n            ax11.plot(temp, depth, 'o', color=color, markersize=8, markeredgecolor='black')\n            ax11.text(temp + 5, depth, f'{temp:.0f}K', fontsize=9, va='center')\n\n        ax11.legend(fontsize=9)\n\n        # 12. \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a: \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432\u0434\u043e\u043b\u044c X \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        ax12 = fig.add_subplot(3, 5, 13)\n        y_center_idx = len(y_plot) // 2\n        x_profile = U_physical[:, y_center_idx, -1, frame]\n\n        ax12.plot(x_phys, x_profile, 'r-', linewidth=2.5, label='\u041f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c')\n        ax12.fill_between(x_phys, config.INITIAL_TEMPERATURE, x_profile, alpha=0.2, color='red')\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u0443\u044e \u043b\u0438\u043d\u0438\u044e \u0434\u043b\u044f \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n        ax12.axhline(y=1900, color='lime', linestyle='-', alpha=0.7, linewidth=2, \n                    label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n        ax12.set_xlabel('x (\u043c\u043a\u043c)', fontsize=10)\n        ax12.set_ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=10)\n        ax12.set_title('\u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432\u0434\u043e\u043b\u044c X\\n(\u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c, y=0)', fontsize=11)\n        ax12.grid(True, alpha=0.3)\n        ax12.legend(fontsize=9)\n\n        # 13. \u0413\u0440\u0430\u0444\u0438\u043a \u0448\u0438\u0440\u0438\u043d\u044b \u0437\u043e\u043d\u044b \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0432\u044b\u0448\u0435 1900 K\n        ax13 = fig.add_subplot(3, 5, 14)\n\n        # \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0448\u0438\u0440\u0438\u043d\u0443 \u0437\u043e\u043d\u044b \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0432\u044b\u0448\u0435 1900 K \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        width_1900 = None\n        depth_1900 = None\n\n        # \u0428\u0438\u0440\u0438\u043d\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        surface_temp = U_physical[:, center_y, -1, frame]\n        left_idx = None\n        right_idx = None\n\n        for i in range(center_x, len(x_phys)):\n            if surface_temp[i] &gt;= 1900 and right_idx is None:\n                right_idx = i\n            if surface_temp[center_x - (i-center_x)] &gt;= 1900 and left_idx is None:\n                left_idx = center_x - (i-center_x)\n\n        if left_idx is not None and right_idx is not None:\n            width_1900 = x_phys[right_idx] - x_phys[left_idx]\n\n        # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f 1900 K\n        center_temp_profile = U_physical[center_x, center_y, :, frame]\n        for i in range(len(z_phys)):\n            if center_temp_profile[i] &gt;= 1900:\n                depth_1900 = z_phys[i]\n                break\n\n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u0442\u0443\u044e \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e\n        if width_1900 is not None and depth_1900 is not None:\n            # \u0420\u0438\u0441\u0443\u0435\u043c \u044d\u043b\u043b\u0438\u043f\u0441 \u0437\u043e\u043d\u044b \u043d\u0430\u0433\u0440\u0435\u0432\u0430\n            ellipse = Ellipse((0, -depth_1900/2), width=width_1900, height=depth_1900,\n                             edgecolor='lime', facecolor='lime', alpha=0.3, \n                             linewidth=2, label=f'\u0417\u043e\u043d\u0430 &gt;1900 K')\n            ax13.add_patch(ellipse)\n\n            # \u041f\u043e\u0434\u043f\u0438\u0441\u0438\n            ax13.text(0, -depth_1900/2, f'\u0428: {width_1900:.1f} \u043c\u043a\u043c\\n\u0413: {depth_1900:.1f} \u043c\u043a\u043c',\n                     ha='center', va='center', fontsize=10, fontweight='bold',\n                     bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"white\", alpha=0.8))\n\n        ax13.set_xlim(-beam_radius_um*2, beam_radius_um*2)\n        ax13.set_ylim(-z_phys_max, 0)\n        ax13.set_xlabel('\u0428\u0438\u0440\u0438\u043d\u0430 (\u043c\u043a\u043c)', fontsize=10)\n        ax13.set_ylabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 (\u043c\u043a\u043c)', fontsize=10)\n        ax13.set_title('\u0417\u043e\u043d\u0430 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 &gt;1900 K', fontsize=11)\n        ax13.grid(True, alpha=0.3)\n        ax13.set_aspect('equal')\n        ax13.invert_yaxis()  # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u043d\u0438\u0437\n\n        if width_1900 is not None and depth_1900 is not None:\n            ax13.legend(fontsize=9)\n\n        # 15. \u041f\u0443\u0441\u0442\u0430\u044f \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0434\u043b\u044f \u0431\u0430\u043b\u0430\u043d\u0441\u0430 \u0438\u043b\u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\n        ax15 = fig.add_subplot(3, 5, 15)\n        ax15.axis('off')\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0432\u043e\u0434\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0435\n        summary_text = \"\u0421\u0412\u041e\u0414\u041a\u0410 \u041f\u041e \u0418\u0417\u041e\u0422\u0415\u0420\u041c\u0415 1900 K\\n\"\n        summary_text += \"=\" * 25 + \"\\n\\n\"\n\n        if width_1900 is not None:\n            summary_text += f\"\u2022 \u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b: {width_1900:.1f} \u043c\u043a\u043c\\n\"\n        else:\n            summary_text += \"\u2022 \u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b: \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\\n\"\n\n        if depth_1900 is not None:\n            summary_text += f\"\u2022 \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f: {depth_1900:.1f} \u043c\u043a\u043c\\n\"\n        else:\n            summary_text += \"\u2022 \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f: \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\\n\"\n\n        summary_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {max_temp:.1f} K\\n\"\n        summary_text += f\"\u2022 \u041f\u0435\u0440\u0435\u0433\u0440\u0435\u0432: {max_temp - config.INITIAL_TEMPERATURE:.1f} K\\n\"\n\n        # \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0435 \u0448\u0438\u0440\u0438\u043d\u044b \u043a \u0433\u043b\u0443\u0431\u0438\u043d\u0435\n        if width_1900 is not None and depth_1900 is not None:\n            aspect_ratio = width_1900 / depth_1900\n            summary_text += f\"\u2022 \u041e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0435 \u0428/\u0413: {aspect_ratio:.2f}\"\n\n        ax15.text(0.1, 0.5, summary_text, fontsize=10, va='center', linespacing=1.5,\n                 bbox=dict(boxstyle=\"round,pad=0.5\", facecolor=\"lightgreen\", alpha=0.8))\n\n        # \u0421\u0443\u043f\u0435\u0440-\u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\n        mode_text = \"\u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\"\n        suptitle = f'{title}\\n\u0420\u0435\u0436\u0438\u043c: {mode_text}, \u0412\u0440\u0435\u043c\u044f: {current_time_phys:.1f} \u043c\u043a\u0441'\n        if config.LASER_MODE == \"pulsed\":\n            suptitle += f' (\u0418\u043c\u043f\u0443\u043b\u044c\u0441 {pulse_number}/{config.NUM_PULSES})'\n\n        plt.suptitle(suptitle, fontsize=14, y=0.98)\n        plt.tight_layout()\n\n        return fig,\n\n    ani = FuncAnimation(fig, update, frames=len(t_plot), interval=500, blit=False, repeat=True)\n\n    writer = PillowWriter(fps=2)\n    ani.save(filename, writer=writer, dpi=100)\n    plt.close(fig)\n    print(f\"\u0410\u043d\u0438\u043c\u0430\u0446\u0438\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0430: {filename}\")\n    return ani\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_comparison_pulse_vs_continuous","title":"<code>plot_comparison_pulse_vs_continuous(temp_pulsed, temp_continuous, t_plot, pulsed_params=None, continuous_params=None)</code>","text":"<p>Generates a plot comparing temperature profiles for pulsed and continuous laser heating modes.</p> <p>The plot visualizes the temperature evolution over time for both modes,  highlights key parameters like maximum temperatures and the time at which they occur, and indicates whether the 1900 K isotherm is reached.  It also provides a detailed comparison of the two modes, including temperature differences and efficiency assessments.</p> <p>Parameters:</p> Name Type Description Default <code>temp_pulsed</code> <code>array</code> <p>Temperature data for the pulsed mode.</p> required <code>temp_continuous</code> <code>array</code> <p>Temperature data for the continuous mode.</p> required <code>t_plot</code> <code>array</code> <p>Time axis data (dimensionless).</p> required <code>pulsed_params</code> <code>dict</code> <p>Parameters for the pulsed mode. Defaults to {\"num_pulses\": 8, \"avg_power\": 10.0, \"rep_rate\": 8000.0}.</p> <code>None</code> <code>continuous_params</code> <code>dict</code> <p>Parameters for the continuous mode. Defaults to {\"power\": 5.0}.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Displays and saves the generated plot as 'comparison_pulse_vs_continuous.png'. Prints a message if data for both modes is not provided.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_comparison_pulse_vs_continuous(temp_pulsed, temp_continuous, t_plot, \n                                        pulsed_params=None, continuous_params=None):\n    \"\"\"\n    Generates a plot comparing temperature profiles for pulsed and continuous laser heating modes.\n\n    The plot visualizes the temperature evolution over time for both modes, \n    highlights key parameters like maximum temperatures and the time at which they occur,\n    and indicates whether the 1900 K isotherm is reached. \n    It also provides a detailed comparison of the two modes, including temperature differences and efficiency assessments.\n\n    Args:\n        temp_pulsed (array): Temperature data for the pulsed mode.\n        temp_continuous (array): Temperature data for the continuous mode.\n        t_plot (array): Time axis data (dimensionless).\n        pulsed_params (dict, optional): Parameters for the pulsed mode. Defaults to {\"num_pulses\": 8, \"avg_power\": 10.0, \"rep_rate\": 8000.0}.\n        continuous_params (dict, optional): Parameters for the continuous mode. Defaults to {\"power\": 5.0}.\n\n    Returns:\n        None: Displays and saves the generated plot as 'comparison_pulse_vs_continuous.png'. Prints a message if data for both modes is not provided.\n    \"\"\"\n    if temp_pulsed is None or temp_continuous is None:\n        print(\"\u0414\u043b\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u043d\u0443\u0436\u043d\u044b \u0434\u0430\u043d\u043d\u044b\u0435 \u043e\u0431\u043e\u0438\u0445 \u0440\u0435\u0436\u0438\u043c\u043e\u0432!\")\n        return\n\n    t_phys = t_plot * config.CHARACTERISTIC_TIME * 1e6  # \u043c\u043a\u0441\n\n    plt.figure(figsize=(15, 8))\n\n    # \u0413\u0440\u0430\u0444\u0438\u043a\u0438 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b\n    line_pulsed, = plt.plot(t_phys, temp_pulsed, 'r-', linewidth=3, alpha=0.8, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c')\n    line_continuous, = plt.plot(t_phys, temp_continuous, 'b-', linewidth=3, alpha=0.8, label='\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c')\n\n    # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\n    plt.axhline(y=config.INITIAL_TEMPERATURE, color='gray', linestyle='--', linewidth=2,\n                alpha=0.5, label=f'\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f ({config.INITIAL_TEMPERATURE} K)')\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n    plt.axhline(y=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.8,\n                label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    # \u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u043a\u0440\u0438\u0432\u044b\u043c\u0438 \u0434\u043b\u044f \u043d\u0430\u0433\u043b\u044f\u0434\u043d\u043e\u0441\u0442\u0438\n    plt.fill_between(t_phys, temp_pulsed, temp_continuous, \n                     where=temp_pulsed &gt;= temp_continuous, \n                     color='red', alpha=0.15, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 &gt; \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439')\n    plt.fill_between(t_phys, temp_pulsed, temp_continuous, \n                     where=temp_pulsed &lt; temp_continuous, \n                     color='blue', alpha=0.15, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 &lt; \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439')\n\n    # \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n    max_pulsed = np.max(temp_pulsed)\n    max_continuous = np.max(temp_continuous)\n    max_time_pulsed = t_phys[np.argmax(temp_pulsed)]\n    max_time_continuous = t_phys[np.argmax(temp_continuous)]\n\n    # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n    isotherm_pulsed = np.any(temp_pulsed &gt;= 1900)\n    isotherm_continuous = np.any(temp_continuous &gt;= 1900)\n\n    # \u0422\u043e\u0447\u043a\u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u043e\u0432\n    plt.scatter([max_time_pulsed], [max_pulsed], color='red', s=150, zorder=5,\n                edgecolor='black', linewidth=2, label=f'\u041c\u0430\u043a\u0441. \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439: {max_pulsed:.1f} K')\n    plt.scatter([max_time_continuous], [max_continuous], color='blue', s=150, zorder=5,\n                edgecolor='black', linewidth=2, label=f'\u041c\u0430\u043a\u0441. \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439: {max_continuous:.1f} K')\n\n    # \u0412\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u043b\u0438\u043d\u0438\u0438 \u0432 \u0442\u043e\u0447\u043a\u0430\u0445 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u043e\u0432\n    plt.axvline(x=max_time_pulsed, color='red', linestyle=':', alpha=0.7, linewidth=1.5)\n    plt.axvline(x=max_time_continuous, color='blue', linestyle=':', alpha=0.7, linewidth=1.5)\n\n    # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0433\u043e \u0431\u043b\u043e\u043a\u0430\n    if pulsed_params is None:\n        pulsed_params = {\"num_pulses\": 8, \"avg_power\": 10.0, \"rep_rate\": 8000.0}\n    if continuous_params is None:\n        continuous_params = {\"power\": 5.0}\n\n    # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0432 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u043c \u0431\u043b\u043e\u043a\u0435\n    info_text = \"\u0421\u0420\u0410\u0412\u041d\u0415\u041d\u0418\u0415 \u0420\u0415\u0416\u0418\u041c\u041e\u0412 \u041b\u0410\u0417\u0415\u0420\u041d\u041e\u0413\u041e \u041d\u0410\u0413\u0420\u0415\u0412\u0410\\n\"\n    info_text += \"=\" * 40 + \"\\n\\n\"\n\n    info_text += \"\u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419 \u0420\u0415\u0416\u0418\u041c:\\n\"\n    info_text += f\"\u2022 \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432: {pulsed_params.get('num_pulses', 8)}\\n\"\n    info_text += f\"\u2022 \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {pulsed_params.get('avg_power', 10.0)} \u0412\u0442 (\u0441\u0440.)\\n\"\n    info_text += f\"\u2022 \u0427\u0430\u0441\u0442\u043e\u0442\u0430: {pulsed_params.get('rep_rate', 8000.0):.0f} \u0413\u0446\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0442\u0435\u043c\u043f.: {max_pulsed:.1f} K\\n\"\n    info_text += f\"\u2022 \u0412\u0440\u0435\u043c\u044f \u043c\u0430\u043a\u0441.: {max_time_pulsed:.0f} \u043c\u043a\u0441\\n\"\n    info_text += f\"\u2022 \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K: {'\u0414\u0410' if isotherm_pulsed else '\u041d\u0415\u0422'}\\n\\n\"\n\n    info_text += \"\u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419 \u0420\u0415\u0416\u0418\u041c:\\n\"\n    info_text += f\"\u2022 \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {continuous_params.get('power', 5.0)} \u0412\u0442\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0442\u0435\u043c\u043f.: {max_continuous:.1f} K\\n\"\n    info_text += f\"\u2022 \u0412\u0440\u0435\u043c\u044f \u043c\u0430\u043a\u0441.: {max_time_continuous:.0f} \u043c\u043a\u0441\\n\"\n    info_text += f\"\u2022 \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K: {'\u0414\u0410' if isotherm_continuous else '\u041d\u0415\u0422'}\\n\\n\"\n\n    info_text += \"\u0421\u0420\u0410\u0412\u041d\u0415\u041d\u0418\u0415:\\n\"\n    info_text += f\"\u2022 \u0420\u0430\u0437\u043d\u0438\u0446\u0430: {abs(max_pulsed - max_continuous):.1f} K\\n\"\n\n    if max_pulsed &gt; max_continuous:\n        percent_diff = (max_pulsed/max_continuous - 1) * 100\n        info_text += f\"\u2022 \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0433\u043e\u0440\u044f\u0447\u0435\u0435 \u043d\u0430 {percent_diff:.1f}%\\n\"\n        info_text += \"\u2022 \u0411\u043e\u043b\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u0439 \u043d\u0430\u0433\u0440\u0435\u0432\\n\"\n    else:\n        percent_diff = (max_continuous/max_pulsed - 1) * 100\n        info_text += f\"\u2022 \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0433\u043e\u0440\u044f\u0447\u0435\u0435 \u043d\u0430 {percent_diff:.1f}%\\n\"\n        info_text += \"\u2022 \u0411\u043e\u043b\u0435\u0435 \u0441\u0442\u0430\u0431\u0438\u043b\u044c\u043d\u044b\u0439 \u043d\u0430\u0433\u0440\u0435\u0432\\n\"\n\n    info_text += f\"\u2022 \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f.: {config.INITIAL_TEMPERATURE} K\"\n\n    plt.text(0.02, 0.98, info_text, transform=plt.gca().transAxes,\n             fontsize=10, verticalalignment='top', linespacing=1.5,\n             bbox=dict(boxstyle=\"round,pad=0.5\", facecolor=\"lightyellow\", alpha=0.9))\n\n    plt.xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    plt.ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=12)\n    plt.title('\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u044b\u0445 \u043f\u0440\u043e\u0444\u0438\u043b\u0435\u0439: \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 vs \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', fontsize=14)\n    plt.grid(True, alpha=0.3)\n\n    # \u0412\u0442\u043e\u0440\u0430\u044f \u043b\u0435\u0433\u0435\u043d\u0434\u0430 \u0434\u043b\u044f \u0437\u0430\u043b\u0438\u0432\u043a\u0438\n    from matplotlib.patches import Patch\n    legend_elements = [\n        line_pulsed,\n        line_continuous,\n        Patch(facecolor='red', alpha=0.15, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 &gt; \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439'),\n        Patch(facecolor='blue', alpha=0.15, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 &lt; \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439')\n    ]\n\n    plt.legend(handles=legend_elements, loc='lower right', fontsize=10)\n    plt.tight_layout()\n    plt.savefig('animations/comparison_pulse_vs_continuous.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_depth_temperature_profiles","title":"<code>plot_depth_temperature_profiles(U_data, x_plot, y_plot, z_plot, t_plot)</code>","text":"<p>Generates depth temperature profiles at different points in time. Supports both laser modes (pulsed and continuous).</p> <p>Parameters:</p> Name Type Description Default <code>U_data</code> <code>ndarray</code> <p>Temperature data.</p> required <code>x_plot</code> <code>list</code> <p>X-axis coordinates for plotting.</p> required <code>y_plot</code> <code>list</code> <p>Y-axis coordinates for plotting.</p> required <code>z_plot</code> <code>list</code> <p>Z-axis coordinates for plotting (depth).</p> required <code>t_plot</code> <code>list</code> <p>Time points for plotting.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Displays and saves the plot.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_depth_temperature_profiles(U_data, x_plot, y_plot, z_plot, t_plot):\n    \"\"\"\n    Generates depth temperature profiles at different points in time.\n    Supports both laser modes (pulsed and continuous).\n\n    Args:\n        U_data (numpy.ndarray): Temperature data.\n        x_plot (list): X-axis coordinates for plotting.\n        y_plot (list): Y-axis coordinates for plotting.\n        z_plot (list): Z-axis coordinates for plotting (depth).\n        t_plot (list): Time points for plotting.\n\n    Returns:\n        None: Displays and saves the plot.\n    \"\"\"\n    U_physical = convert_to_physical_temperature(U_data)\n    z_phys = np.array(z_plot) * config.CHARACTERISTIC_LENGTH * 1e6  # \u043c\u043a\u043c\n\n    center_x = len(x_plot) // 2\n    center_y = len(y_plot) // 2\n\n    if config.LASER_MODE == \"pulsed\":\n        # \u0414\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 - \u043c\u043e\u043c\u0435\u043d\u0442\u044b \u043f\u043e\u0441\u043b\u0435 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n        key_frames = []\n        frame_labels = []\n\n        for i in range(min(config.NUM_PULSES, 8)):  # \u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 8 \u043a\u0440\u0438\u0432\u044b\u0445\n            # \u041c\u043e\u043c\u0435\u043d\u0442 \u0432 \u0441\u0435\u0440\u0435\u0434\u0438\u043d\u0435 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n            frame_idx = int((i + 0.5) * len(t_plot) / min(config.NUM_PULSES, 8))\n            frame_idx = min(frame_idx, len(t_plot) - 1)\n            key_frames.append(frame_idx)\n            frame_labels.append(f'\u0412\u043e \u0432\u0440\u0435\u043c\u044f {i+1} \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430')\n\n        title_suffix = f'\u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432'\n    else:\n        # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 - \u0440\u0430\u0432\u043d\u043e\u043c\u0435\u0440\u043d\u044b\u0435 \u043c\u043e\u043c\u0435\u043d\u0442\u044b \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n        key_frames = np.linspace(0, len(t_plot)-1, min(8, len(t_plot)), dtype=int)\n        frame_labels = [f'\u041c\u043e\u043c\u0435\u043d\u0442 {i+1}' for i in range(len(key_frames))]\n        title_suffix = '\u0432 \u0440\u0430\u0437\u043d\u044b\u0435 \u043c\u043e\u043c\u0435\u043d\u0442\u044b \u0432\u0440\u0435\u043c\u0435\u043d\u0438'\n\n    plt.figure(figsize=(12, 9))\n\n    colors = plt.cm.viridis(np.linspace(0, 1, len(key_frames)))\n\n    for i, (frame_idx, label) in enumerate(zip(key_frames, frame_labels)):\n        temp_profile = U_physical[center_x, center_y, :, frame_idx]\n        t_phys = t_plot[frame_idx] * config.CHARACTERISTIC_TIME * 1e6\n\n        if config.LASER_MODE == \"pulsed\":\n            pulse_num = int(t_plot[frame_idx] // config.LASER_PULSE_PERIOD_NORM) + 1\n            label = f'\u0418\u043c\u043f\u0443\u043b\u044c\u0441 {pulse_num} ({t_phys:.0f} \u043c\u043a\u0441)'\n        else:\n            label = f'{t_phys:.0f} \u043c\u043a\u0441'\n\n        plt.plot(temp_profile, z_phys, color=colors[i], linewidth=2.5, label=label)\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0443 1900 K\n    plt.axvline(x=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.7,\n                label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    plt.xlabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=12)\n    plt.ylabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 (\u043c\u043a\u043c)', fontsize=12)\n\n    mode_text = \"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439\"\n    power_text = f\"{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\" if config.LASER_MODE == \"pulsed\" else f\"{config.LASER_CONTINUOUS_POWER} \u0412\u0442\"\n\n    title = f'\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 {title_suffix}\\n'\n    title += f'\u0420\u0435\u0436\u0438\u043c: {mode_text}, \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {power_text}'\n    plt.title(title, fontsize=13)\n\n    plt.grid(True, alpha=0.3)\n    plt.legend(fontsize=10)\n    plt.gca().invert_yaxis()  # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u043d\u0438\u0437\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043b\u0438\u043d\u0438\u0438 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n    target_depths = [10, 20, 30]\n    for depth in target_depths:\n        plt.axhline(y=depth, color='gray', linestyle=':', alpha=0.5, linewidth=1)\n        plt.text(config.INITIAL_TEMPERATURE + 10, depth, f'{depth} \u043c\u043a\u043c', \n                fontsize=9, color='gray', va='center')\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0438 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n    max_temp_all = np.max(U_physical[center_x, center_y, :, :])\n    if max_temp_all &gt;= 1900:\n        # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u0433\u043b\u0443\u0431\u0438\u043d\u0443 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n        max_depth_1900 = 0\n        for frame_idx in key_frames:\n            temp_profile = U_physical[center_x, center_y, :, frame_idx]\n            for i in range(len(temp_profile)):\n                if temp_profile[i] &gt;= 1900 and z_phys[i] &gt; max_depth_1900:\n                    max_depth_1900 = z_phys[i]\n\n        plt.text(1900 + 50, max_depth_1900, f'\u041c\u0430\u043a\u0441. \u0433\u043b\u0443\u0431\u0438\u043d\u0430: {max_depth_1900:.1f} \u043c\u043a\u043c',\n                fontsize=10, color='lime', va='center',\n                bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"black\", alpha=0.5))\n\n    plt.tight_layout()\n\n    mode = config.LASER_MODE\n    plt.savefig(f'animations/depth_temperature_profiles_{mode}.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_heating_dynamics_comparison","title":"<code>plot_heating_dynamics_comparison(U_data_pulsed, U_data_continuous, x_plot, y_plot, z_plot, t_plot)</code>","text":"<p>\u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u0442 \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0443 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0432 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u043c \u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0430\u0445, \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043e\u0431\u0440\u0430\u0437\u0446\u0430, \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b, \u043e\u0431\u044a\u0435\u043c \u043d\u0430\u0433\u0440\u0435\u0442\u043e\u0433\u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 \u0438 \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u044c\u043d\u0443\u044e \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0443 \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432\u0430.</p> <p>Parameters:</p> Name Type Description Default <code>U_data_pulsed</code> <p>\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.</p> required <code>U_data_continuous</code> <p>\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.</p> required <code>x_plot</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b x \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.</p> required <code>y_plot</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b y \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.</p> required <code>z_plot</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b z \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.</p> required <code>t_plot</code> <p>\u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.</p> required <p>Returns:</p> Type Description <p>None. \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0438 \u043d\u0430\u0433\u0440\u0435\u0432\u0430.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_heating_dynamics_comparison(U_data_pulsed, U_data_continuous, \n                                    x_plot, y_plot, z_plot, t_plot):\n    \"\"\"\n    \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u0442 \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0443 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0432 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u043c \u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0430\u0445, \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044f \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043e\u0431\u0440\u0430\u0437\u0446\u0430, \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b, \u043e\u0431\u044a\u0435\u043c \u043d\u0430\u0433\u0440\u0435\u0442\u043e\u0433\u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 \u0438 \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u044c\u043d\u0443\u044e \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0443 \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432\u0430.\n\n    Args:\n        U_data_pulsed: \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.\n        U_data_continuous: \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0434\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.\n        x_plot: \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b x \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.\n        y_plot: \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b y \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.\n        z_plot: \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b z \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.\n        t_plot: \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432.\n\n    Returns:\n        None. \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0438 \u043d\u0430\u0433\u0440\u0435\u0432\u0430.\n    \"\"\"\n    U_phys_pulsed = convert_to_physical_temperature(U_data_pulsed)\n    U_phys_continuous = convert_to_physical_temperature(U_data_continuous)\n    t_phys = t_plot * config.CHARACTERISTIC_TIME * 1e6\n\n    center_x = len(x_plot) // 2\n    center_y = len(y_plot) // 2\n    surface_z = len(z_plot) - 1\n\n    # \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    temp_center_pulsed = U_phys_pulsed[center_x, center_y, surface_z, :]\n    temp_center_continuous = U_phys_continuous[center_x, center_y, surface_z, :]\n\n    fig = plt.figure(figsize=(18, 12))\n\n    # 1. \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax1 = fig.add_subplot(2, 2, 1)\n    ax1.plot(t_phys, temp_center_pulsed, 'r-', linewidth=3, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n    ax1.plot(t_phys, temp_center_continuous, 'b-', linewidth=3, label='\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n    ax1.axhline(y=config.INITIAL_TEMPERATURE, color='gray', linestyle='--', \n                linewidth=2, alpha=0.5, label=f'\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f ({config.INITIAL_TEMPERATURE} K)')\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n    ax1.axhline(y=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.8,\n                label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    ax1.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    ax1.set_ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=12)\n    ax1.set_title('\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043f\u0443\u0447\u043a\u0430', fontsize=13)\n    ax1.grid(True, alpha=0.3)\n    ax1.legend(fontsize=10)\n\n    # 2. \u0413\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b\n    ax2 = fig.add_subplot(2, 2, 2)\n\n    # \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b (\u0440\u0430\u0437\u043d\u0438\u0446\u0430 \u043c\u0435\u0436\u0434\u0443 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0433\u043b\u0443\u0431\u0438\u043d\u043e\u0439 30 \u043c\u043a\u043c)\n    depth_idx = np.argmin(np.abs(np.array(z_plot) * config.CHARACTERISTIC_LENGTH * 1e6 - 30))\n\n    temp_surface_pulsed = U_phys_pulsed[center_x, center_y, surface_z, :]\n    temp_depth_pulsed = U_phys_pulsed[center_x, center_y, depth_idx, :]\n    gradient_pulsed = temp_surface_pulsed - temp_depth_pulsed\n\n    temp_surface_continuous = U_phys_continuous[center_x, center_y, surface_z, :]\n    temp_depth_continuous = U_phys_continuous[center_x, center_y, depth_idx, :]\n    gradient_continuous = temp_surface_continuous - temp_depth_continuous\n\n    ax2.plot(t_phys, gradient_pulsed, 'r-', linewidth=2.5, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n    ax2.plot(t_phys, gradient_continuous, 'b-', linewidth=2.5, label='\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n\n    ax2.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    ax2.set_ylabel('\u0413\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b (K)', fontsize=12)\n    ax2.set_title('\u0413\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b (\u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c - \u0433\u043b\u0443\u0431\u0438\u043d\u0430 30 \u043c\u043a\u043c)', fontsize=13)\n    ax2.grid(True, alpha=0.3)\n    ax2.legend(fontsize=10)\n\n    # 3. \u041e\u0431\u044a\u0435\u043c \u043d\u0430\u0433\u0440\u0435\u0442\u043e\u0433\u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 \u0432\u044b\u0448\u0435 1900 K\n    ax3 = fig.add_subplot(2, 2, 3)\n\n    # \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u043c \u043e\u0431\u044a\u0435\u043c \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 \u0441 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043e\u0439 \u0432\u044b\u0448\u0435 1900 K\n    threshold_temp = 1900  # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n\n    heated_volume_pulsed = []\n    heated_volume_continuous = []\n\n    for t_idx in range(len(t_plot)):\n        # \u0414\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n        above_threshold_pulsed = np.sum(U_phys_pulsed[:, :, :, t_idx] &gt; threshold_temp)\n        heated_volume_pulsed.append(above_threshold_pulsed)\n\n        # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430\n        above_threshold_continuous = np.sum(U_phys_continuous[:, :, :, t_idx] &gt; threshold_temp)\n        heated_volume_continuous.append(above_threshold_continuous)\n\n    heated_volume_pulsed = np.array(heated_volume_pulsed)\n    heated_volume_continuous = np.array(heated_volume_continuous)\n\n    # \u041d\u043e\u0440\u043c\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u043a \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n    max_volume = max(np.max(heated_volume_pulsed), np.max(heated_volume_continuous))\n    if max_volume &gt; 0:\n        heated_volume_pulsed = heated_volume_pulsed / max_volume * 100\n        heated_volume_continuous = heated_volume_continuous / max_volume * 100\n\n    ax3.plot(t_phys, heated_volume_pulsed, 'r-', linewidth=2.5, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n    ax3.plot(t_phys, heated_volume_continuous, 'b-', linewidth=2.5, label='\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n\n    ax3.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    ax3.set_ylabel('\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u044a\u0435\u043c \u043d\u0430\u0433\u0440\u0435\u0442\u043e\u0433\u043e \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 (%)', fontsize=12)\n    ax3.set_title(f'\u041e\u0431\u044a\u0435\u043c \u043c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u0430 \u0441 T &gt; 1900K (\u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0430)', fontsize=13)\n    ax3.grid(True, alpha=0.3)\n    ax3.legend(fontsize=10)\n    ax3.set_ylim(0, 105)\n\n    # 4. \u0418\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430 \u043d\u0430\u0433\u0440\u0435\u0432\u0430 \u0432\u044b\u0448\u0435 1900 K\n    ax4 = fig.add_subplot(2, 2, 4)\n\n    # \u0418\u043d\u0442\u0435\u0433\u0440\u0430\u043b \u043e\u0442 \u043f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430\u0434 1900 K (\u0435\u0441\u043b\u0438 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430)\n    integral_pulsed = np.zeros_like(t_phys)\n    integral_continuous = np.zeros_like(t_phys)\n\n    for t_idx in range(len(t_plot)):\n        if temp_center_pulsed[t_idx] &gt; 1900:\n            integral_pulsed[t_idx] = np.sum(temp_center_pulsed[:t_idx+1] - 1900)\n        if temp_center_continuous[t_idx] &gt; 1900:\n            integral_continuous[t_idx] = np.sum(temp_center_continuous[:t_idx+1] - 1900)\n\n    ax4.plot(t_phys, integral_pulsed, 'r-', linewidth=2.5, label='\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n    ax4.plot(t_phys, integral_continuous, 'b-', linewidth=2.5, label='\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c', alpha=0.8)\n\n    ax4.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    ax4.set_ylabel('\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u043b \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432\u0430 (K\u00b7\u043c\u043a\u0441)', fontsize=12)\n    ax4.set_title('\u041d\u0430\u043a\u043e\u043f\u043b\u0435\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0435\u0433\u0440\u0435\u0432 \u0432\u044b\u0448\u0435 1900K (\u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430)', fontsize=13)\n    ax4.grid(True, alpha=0.3)\n    ax4.legend(fontsize=10)\n\n    plt.suptitle('\u0421\u0440\u0430\u0432\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0434\u0438\u043d\u0430\u043c\u0438\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043d\u0430\u0433\u0440\u0435\u0432\u0430: \u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 vs \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c\u044b', \n                fontsize=15, y=0.98)\n\n    plt.tight_layout()\n    plt.savefig('animations/heating_dynamics_comparison.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_isotherm_1900_analysis","title":"<code>plot_isotherm_1900_analysis(U_data, x_plot, y_plot, z_plot, t_plot, time_idx=-1)</code>","text":"<p>Generates a detailed analysis of the 1900 K isotherm, visualizing temperature distribution and key parameters over time.</p> <p>This function creates several plots to understand the thermal behavior of the material under laser irradiation,  including surface temperature contours, temperature profiles, 3D visualization of the heated zone, and the evolution  of zone characteristics over time. It provides insights into the extent and dynamics of the heated area.</p> <p>Parameters:</p> Name Type Description Default <code>U_data</code> <code>ndarray</code> <p>4D array containing temperature data.</p> required <code>x_plot</code> <code>ndarray</code> <p>1D array representing x-coordinates.</p> required <code>y_plot</code> <code>ndarray</code> <p>1D array representing y-coordinates.</p> required <code>z_plot</code> <code>ndarray</code> <p>1D array representing z-coordinates.</p> required <code>t_plot</code> <code>ndarray</code> <p>1D array representing time points.</p> required <code>time_idx</code> <code>int</code> <p>Index of the time point to analyze. Defaults to -1 (last time point).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Displays the generated plots and saves them as PNG images.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_isotherm_1900_analysis(U_data, x_plot, y_plot, z_plot, t_plot, time_idx=-1):\n    \"\"\"\n    Generates a detailed analysis of the 1900 K isotherm, visualizing temperature distribution and key parameters over time.\n\n    This function creates several plots to understand the thermal behavior of the material under laser irradiation, \n    including surface temperature contours, temperature profiles, 3D visualization of the heated zone, and the evolution \n    of zone characteristics over time. It provides insights into the extent and dynamics of the heated area.\n\n    Args:\n        U_data (numpy.ndarray): 4D array containing temperature data.\n        x_plot (numpy.ndarray): 1D array representing x-coordinates.\n        y_plot (numpy.ndarray): 1D array representing y-coordinates.\n        z_plot (numpy.ndarray): 1D array representing z-coordinates.\n        t_plot (numpy.ndarray): 1D array representing time points.\n        time_idx (int, optional): Index of the time point to analyze. Defaults to -1 (last time point).\n\n    Returns:\n        None: Displays the generated plots and saves them as PNG images.\n    \"\"\"\n    U_physical = convert_to_physical_temperature(U_data)\n    x_phys = np.array(x_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n    y_phys = np.array(y_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n    z_phys = np.array(z_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n\n    t_phys = t_plot[time_idx] * config.CHARACTERISTIC_TIME * 1e6\n\n    fig = plt.figure(figsize=(18, 12))\n\n    # \u0426\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b\n    center_x = len(x_plot) // 2\n    center_y = len(y_plot) // 2\n\n    # 1. \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n    ax1 = fig.add_subplot(2, 3, 1)\n    X, Y = np.meshgrid(x_phys, y_phys)\n    Z_surface = U_physical[:, :, -1, time_idx].T\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a\n    contour1 = ax1.contourf(X, Y, Z_surface, levels=20, cmap='hot')\n\n    # \u041a\u043e\u043d\u0442\u0443\u0440 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n    if np.max(Z_surface) &gt;= 1900:\n        cs = ax1.contour(X, Y, Z_surface, levels=[1900], colors='lime', \n                        linewidths=3, alpha=0.9, linestyles='-')\n\n        # \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0432\u043d\u0443\u0442\u0440\u0438 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n        paths = cs.get_paths()\n        for path in paths:\n            vertices = path.vertices\n            if len(vertices) &gt; 2:\n                polygon = Polygon(vertices, closed=True, fill=True,\n                                 facecolor='lime', alpha=0.3, \n                                 edgecolor='lime', linewidth=2)\n                ax1.add_patch(polygon)\n\n    ax1.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax1.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11)\n    ax1.set_title(f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\\n\u0412\u0440\u0435\u043c\u044f: {t_phys:.1f} \u043c\u043a\u0441', fontsize=12)\n    ax1.grid(True, alpha=0.3)\n    ax1.set_aspect('equal')\n    fig.colorbar(contour1, ax=ax1, shrink=0.8, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n    # 2. \u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0432\u0434\u043e\u043b\u044c X \u0447\u0435\u0440\u0435\u0437 \u0446\u0435\u043d\u0442\u0440\n    ax2 = fig.add_subplot(2, 3, 2)\n    x_profile = U_physical[:, center_y, -1, time_idx]\n\n    ax2.plot(x_phys, x_profile, 'b-', linewidth=2.5)\n    ax2.fill_between(x_phys, config.INITIAL_TEMPERATURE, x_profile, alpha=0.2, color='blue')\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n    ax2.axhline(y=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.8,\n                label='\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0448\u0438\u0440\u0438\u043d\u0443 \u0437\u043e\u043d\u044b &gt;1900 K\n    width_1900 = None\n    left_idx = None\n    right_idx = None\n\n    for i in range(center_x, len(x_phys)):\n        if x_profile[i] &gt;= 1900 and right_idx is None:\n            right_idx = i\n        if x_profile[center_x - (i-center_x)] &gt;= 1900 and left_idx is None:\n            left_idx = center_x - (i-center_x)\n\n    if left_idx is not None and right_idx is not None:\n        width_1900 = x_phys[right_idx] - x_phys[left_idx]\n        # \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u0437\u043e\u043d\u0443 &gt;1900 K\n        ax2.fill_between(x_phys[left_idx:right_idx+1], 1900, x_profile[left_idx:right_idx+1], \n                        alpha=0.3, color='lime', label=f'\u0417\u043e\u043d\u0430 &gt;1900 K ({width_1900:.1f} \u043c\u043a\u043c)')\n\n    ax2.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax2.set_ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=11)\n    ax2.set_title('\u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432\u0434\u043e\u043b\u044c X (y=0)', fontsize=12)\n    ax2.grid(True, alpha=0.3)\n    ax2.legend(fontsize=10)\n\n    # 3. \u041f\u0440\u043e\u0444\u0438\u043b\u044c \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax3 = fig.add_subplot(2, 3, 3)\n    depth_profile = U_physical[center_x, center_y, :, time_idx]\n\n    ax3.plot(depth_profile, z_phys, 'r-', linewidth=2.5)\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n    ax3.axvline(x=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.8,\n                label='\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    # \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0433\u043b\u0443\u0431\u0438\u043d\u0443 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f 1900 K\n    depth_1900 = None\n    for i in range(len(z_phys)):\n        if depth_profile[i] &gt;= 1900:\n            depth_1900 = z_phys[i]\n            # \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u0437\u043e\u043d\u0443 &gt;1900 K \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435\n            ax3.fill_betweenx(z_phys[:i+1], 1900, depth_profile[:i+1], \n                            alpha=0.3, color='lime', \n                            label=f'\u0413\u043b\u0443\u0431\u0438\u043d\u0430: {depth_1900:.1f} \u043c\u043a\u043c')\n            break\n\n    ax3.set_xlabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=11)\n    ax3.set_ylabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 z (\u043c\u043a\u043c)', fontsize=11)\n    ax3.set_title('\u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 (\u0446\u0435\u043d\u0442\u0440)', fontsize=12)\n    ax3.grid(True, alpha=0.3)\n    ax3.invert_yaxis()\n    ax3.legend(fontsize=10)\n\n    # 4. 3D \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0437\u043e\u043d\u044b &gt;1900 K\n    ax4 = fig.add_subplot(2, 3, 4, projection='3d')\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u043a\u0443 \u0434\u043b\u044f \u0437\u043e\u043d\u044b &gt;1900 K\n    mask_1900 = U_physical[:, :, :, time_idx] &gt; 1900\n\n    if np.any(mask_1900):\n        # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u0435\u043a \u0432 \u0437\u043e\u043d\u0435 &gt;1900 K\n        x_idx, y_idx, z_idx = np.where(mask_1900)\n        x_points = x_phys[x_idx]\n        y_points = y_phys[y_idx]\n        z_points = z_phys[z_idx]\n        temp_points = U_physical[x_idx, y_idx, z_idx, time_idx]\n\n        # \u0420\u0438\u0441\u0443\u0435\u043c \u0442\u043e\u0447\u043a\u0438 \u0432 3D\n        sc = ax4.scatter(x_points, y_points, -z_points, c=temp_points, \n                        cmap='hot', alpha=0.6, s=10, vmin=1900)\n\n        # \u041f\u043e\u0434\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0447\u0435\u043a\n        ax4.text2D(0.05, 0.95, f'\u0422\u043e\u0447\u0435\u043a &gt;1900K: {len(x_points)}', \n                  transform=ax4.transAxes, fontsize=10, fontweight='bold',\n                  bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"white\", alpha=0.8))\n    else:\n        ax4.text2D(0.3, 0.5, \"\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\\n\u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\", \n                  transform=ax4.transAxes, fontsize=12, fontweight='bold',\n                  color='red', ha='center')\n\n    ax4.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11, labelpad=10)\n    ax4.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11, labelpad=10)\n    ax4.set_zlabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 (\u043c\u043a\u043c)', fontsize=11, labelpad=10)\n    ax4.set_title('3D \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0437\u043e\u043d\u044b &gt;1900 K', fontsize=12)\n    ax4.view_init(elev=25, azim=45)\n\n    if np.any(mask_1900):\n        fig.colorbar(sc, ax=ax4, shrink=0.6, pad=0.1, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n    # 5. \u042d\u0432\u043e\u043b\u044e\u0446\u0438\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u0437\u043e\u043d\u044b &gt;1900 K \u0432\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n    ax5 = fig.add_subplot(2, 3, 5)\n\n    widths = []\n    depths = []\n    volumes = []\n\n    for t_idx in range(len(t_plot)):\n        # \u0428\u0438\u0440\u0438\u043d\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        surface_temp = U_physical[:, center_y, -1, t_idx]\n        left_idx = None\n        right_idx = None\n\n        for i in range(center_x, len(x_phys)):\n            if surface_temp[i] &gt;= 1900 and right_idx is None:\n                right_idx = i\n            if surface_temp[center_x - (i-center_x)] &gt;= 1900 and left_idx is None:\n                left_idx = center_x - (i-center_x)\n\n        width = 0\n        if left_idx is not None and right_idx is not None:\n            width = x_phys[right_idx] - x_phys[left_idx]\n        widths.append(width)\n\n        # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f\n        center_temp_profile = U_physical[center_x, center_y, :, t_idx]\n        depth = 0\n        for i in range(len(z_phys)):\n            if center_temp_profile[i] &gt;= 1900:\n                depth = z_phys[i]\n        depths.append(depth)\n\n        # \u041e\u0431\u044a\u0435\u043c (\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0447\u0435\u043a &gt;1900 K)\n        volume = np.sum(U_physical[:, :, :, t_idx] &gt; 1900)\n        volumes.append(volume)\n\n    widths = np.array(widths)\n    depths = np.array(depths)\n    volumes = np.array(volumes)\n\n    # \u041d\u043e\u0440\u043c\u0430\u043b\u0438\u0437\u0443\u0435\u043c \u043e\u0431\u044a\u0435\u043c\n    if np.max(volumes) &gt; 0:\n        volumes = volumes / np.max(volumes) * 100\n\n    ax5.plot(t_phys, widths, 'b-', linewidth=2, label='\u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b (\u043c\u043a\u043c)')\n    ax5.plot(t_phys, depths, 'r-', linewidth=2, label='\u0413\u043b\u0443\u0431\u0438\u043d\u0430 (\u043c\u043a\u043c)')\n    ax5.plot(t_phys, volumes, 'g-', linewidth=2, label='\u041e\u0442\u043d. \u043e\u0431\u044a\u0435\u043c (%)')\n\n    ax5.set_xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=11)\n    ax5.set_ylabel('\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u043e\u043d\u044b &gt;1900 K', fontsize=11)\n    ax5.set_title('\u042d\u0432\u043e\u043b\u044e\u0446\u0438\u044f \u0437\u043e\u043d\u044b &gt;1900 K \u0432\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438', fontsize=12)\n    ax5.grid(True, alpha=0.3)\n    ax5.legend(fontsize=10)\n\n    # 6. \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n    ax6 = fig.add_subplot(2, 3, 6)\n    ax6.axis('off')\n\n    max_temp = np.max(U_physical[:, :, :, time_idx])\n\n    # \u0422\u0435\u043a\u0443\u0449\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n    current_width = widths[time_idx] if time_idx &lt; len(widths) else widths[-1]\n    current_depth = depths[time_idx] if time_idx &lt; len(depths) else depths[-1]\n    current_volume = volumes[time_idx] if time_idx &lt; len(volumes) else volumes[-1]\n\n    # \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430 \u0432\u0441\u0435 \u0432\u0440\u0435\u043c\u044f\n    max_width = np.max(widths)\n    max_depth = np.max(depths)\n    max_volume_idx = np.argmax(volumes)\n    time_max_volume = t_phys[max_volume_idx]\n\n    info_text = f\"\u0410\u041d\u0410\u041b\u0418\u0417 \u0418\u0417\u041e\u0422\u0415\u0420\u041c\u042b 1900 K\\n\"\n    info_text += \"=\" * 30 + \"\\n\\n\"\n    info_text += f\"\u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f: {t_phys:.1f} \u043c\u043a\u0441\\n\\n\"\n\n    info_text += f\"\u0422\u0415\u041a\u0423\u0429\u0418\u0415 \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b:\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0442\u0435\u043c\u043f.: {max_temp:.1f} K\\n\"\n    info_text += f\"\u2022 \u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b: {current_width:.1f} \u043c\u043a\u043c\\n\"\n    info_text += f\"\u2022 \u0413\u043b\u0443\u0431\u0438\u043d\u0430: {current_depth:.1f} \u043c\u043a\u043c\\n\"\n    info_text += f\"\u2022 \u041e\u0442\u043d. \u043e\u0431\u044a\u0435\u043c: {current_volume:.1f}%\\n\\n\"\n\n    info_text += f\"\u041c\u0410\u041a\u0421\u0418\u041c\u0410\u041b\u042c\u041d\u042b\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u042f:\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0448\u0438\u0440\u0438\u043d\u0430: {max_width:.1f} \u043c\u043a\u043c\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u0433\u043b\u0443\u0431\u0438\u043d\u0430: {max_depth:.1f} \u043c\u043a\u043c\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441. \u043e\u0431\u044a\u0435\u043c: {np.max(volumes):.1f}%\\n\"\n    info_text += f\"\u2022 \u0412\u0440\u0435\u043c\u044f \u043c\u0430\u043a\u0441. \u043e\u0431\u044a\u0435\u043c\u0430: {time_max_volume:.1f} \u043c\u043a\u0441\\n\\n\"\n\n    if config.LASER_MODE == \"pulsed\":\n        pulse_number = min(int(t_plot[time_idx] // config.LASER_PULSE_PERIOD_NORM) + 1, config.NUM_PULSES)\n        info_text += f\"\u0420\u0415\u0416\u0418\u041c: \u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419\\n\"\n        info_text += f\"\u2022 \u0418\u043c\u043f\u0443\u043b\u044c\u0441: {pulse_number}/{config.NUM_PULSES}\\n\"\n    else:\n        info_text += f\"\u0420\u0415\u0416\u0418\u041c: \u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\\n\"\n\n    ax6.text(0.1, 0.95, info_text, fontsize=11, va='top', linespacing=1.5,\n             bbox=dict(boxstyle=\"round,pad=0.6\", facecolor=\"lightgreen\", alpha=0.9))\n\n    mode_text = \"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439\"\n\n    plt.suptitle(f'\u0414\u0435\u0442\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\\n\u0420\u0435\u0436\u0438\u043c: {mode_text}, \u0412\u0440\u0435\u043c\u044f: {t_phys:.1f} \u043c\u043a\u0441', \n                fontsize=15, y=0.98)\n\n    plt.tight_layout()\n    plt.savefig(f'animations/isotherm_1900_analysis_{mode_text}_t{t_phys:.0f}us.png', \n               dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_laser_intensity_3d","title":"<code>plot_laser_intensity_3d()</code>","text":"<p>\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430 \u0432 3D \u0438 2D, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044f \u0435\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u0438 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_laser_intensity_3d():\n    \"\"\"\n    \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430 \u0432 3D \u0438 2D, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044f \u0435\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u0438 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    x = np.linspace(-1, 1, 100) * config.CHARACTERISTIC_LENGTH * 1e6\n    y = np.linspace(-1, 1, 100) * config.CHARACTERISTIC_LENGTH * 1e6\n    X, Y = np.meshgrid(x, y)\n\n    # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c \u0432 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0435\u0434\u0438\u043d\u0438\u0446\u0430\u0445\n    intensity = np.exp(-(X**2 + Y**2) / (config.LASER_BEAM_RADIUS*1e6)**2)\n\n    fig = plt.figure(figsize=(16, 8))\n\n    # 3D \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\n    ax1 = fig.add_subplot(1, 2, 1, projection='3d')\n    surf = ax1.plot_surface(X, Y, intensity, cmap='hot', alpha=0.85, \n                           rstride=2, cstride=2, linewidth=0.3, antialiased=True,\n                           edgecolor='black')\n    ax1.set_xlabel('x (\u043c\u043a\u043c)', fontsize=12, labelpad=10)\n    ax1.set_ylabel('y (\u043c\u043a\u043c)', fontsize=12, labelpad=10)\n    ax1.set_zlabel('\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=12, labelpad=10)\n    ax1.set_title('3D \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430', fontsize=13)\n    fig.colorbar(surf, ax=ax1, shrink=0.6, pad=0.1, label='\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c')\n    ax1.view_init(elev=35, azim=45)\n\n    # 2D \u043a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a\n    ax2 = fig.add_subplot(1, 2, 2)\n    contour = ax2.contourf(X, Y, intensity, levels=30, cmap='hot')\n    ax2.contour(X, Y, intensity, levels=15, colors='white', linewidths=0.5, alpha=0.5)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u0440\u0443\u0433\u0438 \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0440\u0430\u0434\u0438\u0443\u0441\u0430\u0445\n    radius = config.LASER_BEAM_RADIUS * 1e6\n\n    # \u041f\u043e\u043b\u043d\u044b\u0439 \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430\n    circle_full = Circle((0, 0), radius, fill=False, color='cyan', \n                            linestyle='-', linewidth=3, alpha=0.8, \n                            label=f'\u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430: {radius:.0f} \u043c\u043a\u043c')\n    ax2.add_patch(circle_full)\n\n    # \u0420\u0430\u0434\u0438\u0443\u0441 \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 1/e\u00b2 (13.5% \u043e\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0430)\n    radius_1e2 = radius / np.sqrt(2)\n    circle_1e2 = Circle((0, 0), radius_1e2, fill=False, color='lime', \n                           linestyle='--', linewidth=2, alpha=0.7, \n                           label=f'1/e\u00b2 \u0440\u0430\u0434\u0438\u0443\u0441: {radius_1e2:.0f} \u043c\u043a\u043c')\n    ax2.add_patch(circle_1e2)\n\n    # \u0420\u0430\u0434\u0438\u0443\u0441 \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 1/e (36.8% \u043e\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0430)\n    radius_1e = radius\n    circle_1e = Circle((0, 0), radius_1e, fill=False, color='yellow', \n                          linestyle=':', linewidth=2, alpha=0.6, \n                          label=f'1/e \u0440\u0430\u0434\u0438\u0443\u0441: {radius_1e:.0f} \u043c\u043a\u043c')\n    ax2.add_patch(circle_1e)\n\n    ax2.set_xlabel('x (\u043c\u043a\u043c)', fontsize=12)\n    ax2.set_ylabel('y (\u043c\u043a\u043c)', fontsize=12)\n    ax2.set_title('2D \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438', fontsize=13)\n    ax2.grid(True, alpha=0.3)\n    ax2.legend(loc='upper right', fontsize=10)\n    ax2.set_aspect('equal')\n    fig.colorbar(contour, ax=ax2, shrink=0.9, label='\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c')\n\n    mode_text = \"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439\"\n    power_text = f\"{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\" if config.LASER_MODE == \"pulsed\" else f\"{config.LASER_CONTINUOUS_POWER} \u0412\u0442\"\n\n    plt.suptitle(f'\u041b\u0430\u0437\u0435\u0440\u043d\u044b\u0439 \u043f\u0443\u0447\u043e\u043a: {mode_text} \u0440\u0435\u0436\u0438\u043c\\n\u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {power_text}, \u03bb={config.LASER_WAVELENGTH*1e6:.1f} \u043c\u043a\u043c, \u0420\u0430\u0434\u0438\u0443\u0441: {radius:.0f} \u043c\u043a\u043c',\n                fontsize=14, y=0.95)\n\n    plt.tight_layout()\n    plt.savefig('animations/laser_intensity_3d_profile.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_pulse_train_visualization","title":"<code>plot_pulse_train_visualization()</code>","text":"<p>\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e \u043e\u0446\u0435\u043d\u0438\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a \u043f\u0435\u0440\u0438\u043e\u0434, \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438 \u0430\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_pulse_train_visualization():\n    \"\"\"\n    \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.\n\n    \u041c\u0435\u0442\u043e\u0434 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432,\n    \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e \u043e\u0446\u0435\u043d\u0438\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430, \u0442\u0430\u043a\u0438\u0435 \u043a\u0430\u043a \u043f\u0435\u0440\u0438\u043e\u0434,\n    \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438 \u0430\u043c\u043f\u043b\u0438\u0442\u0443\u0434\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    if config.LASER_MODE != \"pulsed\":\n        print(\"\u042d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0430 \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430!\")\n        return\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n    total_time = config.NUM_PULSES * config.LASER_PULSE_PERIOD_NORM\n    t_test = np.linspace(0, total_time, 5000)\n\n    source_values = np.zeros_like(t_test)\n    pulse_peaks = []\n\n    for i, t_val in enumerate(t_test):\n        t_mod = t_val % config.LASER_PULSE_PERIOD_NORM\n        pulse_value = config.LASER_AMPLITUDE * np.exp(\n            -(t_mod - config.LASER_PULSE_PERIOD_NORM/2)**2 / \n            (2 * config.LASER_PULSE_SIGMA_NORM**2)\n        )\n        source_values[i] = pulse_value\n\n        # \u0417\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u043f\u0438\u043a\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n        if t_mod &lt; 0.1 * config.LASER_PULSE_PERIOD_NORM and i &gt; 0:\n            pulse_peaks.append(t_val)\n\n    # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n    t_phys = t_test * config.CHARACTERISTIC_TIME * 1e6\n\n    plt.figure(figsize=(14, 8))\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0433\u0440\u0430\u0444\u0438\u043a\n    plt.plot(t_phys, source_values, 'r-', linewidth=2.5, alpha=0.8)\n\n    # \u0417\u0430\u043b\u0438\u0432\u043a\u0430 \u043f\u043e\u0434 \u043a\u0440\u0438\u0432\u043e\u0439\n    plt.fill_between(t_phys, 0, source_values, alpha=0.2, color='red')\n\n    # \u0412\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u043b\u0438\u043d\u0438\u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n    for i in range(config.NUM_PULSES + 1):\n        impulse_time = i * config.LASER_PULSE_PERiod_NORM * config.CHARACTERISTIC_TIME * 1e6\n        plt.axvline(x=impulse_time, color='gray', linestyle='--', alpha=0.5, linewidth=1)\n\n        if i &lt; config.NUM_PULSES:\n            # \u041d\u043e\u043c\u0435\u0440 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n            plt.text(impulse_time + 5, 0.9, f'{i+1}', fontsize=10, fontweight='bold', \n                    color='darkred', ha='left')\n\n            # \u041e\u0431\u043b\u0430\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n            impulse_end = impulse_time + config.LASER_PULSE_DURATION_NORM * config.CHARACTERISTIC_TIME * 1e6\n            plt.axvspan(impulse_time, impulse_end, alpha=0.1, color='red')\n\n    # \u0413\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u0430\u044f \u043b\u0438\u043d\u0438\u044f \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 1/e\u00b2\n    level_1e2 = config.LASER_AMPLITUDE / np.e**2\n    plt.axhline(y=level_1e2, color='orange', linestyle=':', alpha=0.7, linewidth=1.5,\n               label=f'\u0423\u0440\u043e\u0432\u0435\u043d\u044c 1/e\u00b2 ({level_1e2:.2f})')\n\n    plt.xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    plt.ylabel('\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=12)\n\n    title = f'\u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\\n'\n    title += f'{config.NUM_PULSES} \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, \u043f\u0435\u0440\u0438\u043e\u0434 {config.LASER_PULSE_PERIOD*1e6:.1f} \u043c\u043a\u0441, '\n    title += f'\u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c {config.LASER_PULSE_DURATION*1e6:.1f} \u043c\u043a\u0441'\n    plt.title(title, fontsize=13)\n\n    plt.grid(True, alpha=0.3)\n    plt.ylim(0, config.LASER_AMPLITUDE * 1.05)\n\n    # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n    info_text = f\"\u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b \u041f\u041e\u0421\u041b\u0415\u0414\u041e\u0412\u0410\u0422\u0415\u041b\u042c\u041d\u041e\u0421\u0422\u0418 \u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041e\u0412:\\n\"\n    info_text += \"=\" * 40 + \"\\n\\n\"\n    info_text += f\"\u2022 \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432: {config.NUM_PULSES}\\n\"\n    info_text += f\"\u2022 \u041f\u0435\u0440\u0438\u043e\u0434: {config.LASER_PULSE_PERIOD*1e6:.1f} \u043c\u043a\u0441\\n\"\n    info_text += f\"\u2022 \u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430: {config.LASER_PULSE_DURATION*1e6:.1f} \u043c\u043a\u0441\\n\"\n    info_text += f\"\u2022 \u0427\u0430\u0441\u0442\u043e\u0442\u0430: {config.LASER_REP_RATE:.0f} \u0413\u0446\\n\"\n    info_text += f\"\u2022 \u0421\u043a\u0432\u0430\u0436\u043d\u043e\u0441\u0442\u044c: {config.LASER_DUTY_CYCLE*100:.1f}%\\n\"\n    info_text += f\"\u2022 \u041f\u0438\u043a\u043e\u0432\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_PEAK_POWER:.1f} \u0412\u0442\\n\"\n    info_text += f\"\u2022 \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_AVG_POWER} \u0412\u0442\\n\"\n    info_text += f\"\u2022 \u041e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f: {total_time*config.CHARACTERISTIC_TIME*1e6:.1f} \u043c\u043a\u0441\"\n\n    plt.text(0.02, 0.98, info_text, transform=plt.gca().transAxes,\n             fontsize=10, verticalalignment='top', linespacing=1.5,\n             bbox=dict(boxstyle=\"round,pad=0.5\", facecolor=\"lightyellow\", alpha=0.9))\n\n    plt.legend(loc='upper right', fontsize=10)\n    plt.tight_layout()\n    plt.savefig('animations/pulse_train_visualization.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_temperature_distribution_at_time","title":"<code>plot_temperature_distribution_at_time(U_data, x_plot, y_plot, z_plot, t_plot, time_idx=-1)</code>","text":"<p>\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u043e\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044f \u0434\u0435\u0442\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u043d\u044b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b, \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b, \u043f\u0440\u043e\u0444\u0438\u043b\u0438 \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 \u0438 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0440\u0435\u0437\u044b.</p> <p>Parameters:</p> Name Type Description Default <code>U_data</code> <code>ndarray</code> <p>\u0414\u0430\u043d\u043d\u044b\u0435 \u043e \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0435.</p> required <code>x_plot</code> <code>ndarray</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b x \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.</p> required <code>y_plot</code> <code>ndarray</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b y \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.</p> required <code>z_plot</code> <code>ndarray</code> <p>\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b z \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.</p> required <code>t_plot</code> <code>ndarray</code> <p>\u041c\u0430\u0441\u0441\u0438\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0442\u043e\u0447\u0435\u043a.</p> required <code>time_idx</code> <code>int</code> <p>\u0418\u043d\u0434\u0435\u043a\u0441 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e -1 (\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>None</code> <p>\u041c\u0435\u0442\u043e\u0434 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a\u0438, \u0438\u043b\u043b\u044e\u0441\u0442\u0440\u0438\u0440\u0443\u044e\u0449\u0438\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_temperature_distribution_at_time(U_data, x_plot, y_plot, z_plot, t_plot, time_idx=-1):\n    \"\"\"\n    \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u043e\u043c \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044f \u0434\u0435\u0442\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044f, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u043d\u044b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b, \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b, \u043f\u0440\u043e\u0444\u0438\u043b\u0438 \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 \u0438 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0440\u0435\u0437\u044b.\n\n    Args:\n        U_data (numpy.ndarray): \u0414\u0430\u043d\u043d\u044b\u0435 \u043e \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0435.\n        x_plot (numpy.ndarray): \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b x \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.\n        y_plot (numpy.ndarray): \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b y \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.\n        z_plot (numpy.ndarray): \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b z \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430.\n        t_plot (numpy.ndarray): \u041c\u0430\u0441\u0441\u0438\u0432 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0442\u043e\u0447\u0435\u043a.\n        time_idx (int, optional): \u0418\u043d\u0434\u0435\u043a\u0441 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0434\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e -1 (\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438).\n\n    Returns:\n        None:  \u041c\u0435\u0442\u043e\u0434 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0433\u0440\u0430\u0444\u0438\u043a\u0438, \u0438\u043b\u043b\u044e\u0441\u0442\u0440\u0438\u0440\u0443\u044e\u0449\u0438\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b.\n    \"\"\"\n    U_physical = convert_to_physical_temperature(U_data)\n    x_phys = np.array(x_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n    y_phys = np.array(y_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n    z_phys = np.array(z_plot) * config.CHARACTERISTIC_LENGTH * 1e6\n\n    t_phys = t_plot[time_idx] * config.CHARACTERISTIC_TIME * 1e6\n\n    fig = plt.figure(figsize=(20, 12))\n\n    # 1. 3D \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n    ax1 = fig.add_subplot(2, 3, 1, projection='3d')\n    X, Y = np.meshgrid(x_phys, y_phys)\n    Z_surface = U_physical[:, :, -1, time_idx].T  # \u041f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c (z = max)\n\n    surf = ax1.plot_surface(X, Y, Z_surface, cmap='hot', alpha=0.85, \n                           rstride=1, cstride=1, linewidth=0.25, antialiased=True)\n    ax1.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11, labelpad=10)\n    ax1.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11, labelpad=10)\n    ax1.set_zlabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=11, labelpad=10)\n    ax1.set_title(f'\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\\n\u0412\u0440\u0435\u043c\u044f: {t_phys:.1f} \u043c\u043a\u0441', fontsize=12)\n    fig.colorbar(surf, ax=ax1, shrink=0.6, pad=0.1, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n    ax1.view_init(elev=30, azim=45)\n\n    # 2. \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u044b \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438 \u0441 \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u0437\u043e\u043d\u044b &gt;1900 K\n    ax2 = fig.add_subplot(2, 3, 2)\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a\n    contour = ax2.contourf(X, Y, Z_surface, levels=20, cmap='hot')\n\n    # \u041a\u043e\u043d\u0442\u0443\u0440 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n    if np.max(Z_surface) &gt;= 1900:\n        cs = ax2.contour(X, Y, Z_surface, levels=[1900], colors='lime', \n                        linewidths=3, alpha=0.9, linestyles='-')\n\n        # \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0432\u043d\u0443\u0442\u0440\u0438 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b\n        paths = cs.get_paths()\n        for path in paths:\n            vertices = path.vertices\n            if len(vertices) &gt; 2:\n                polygon = Polygon(vertices, closed=True, fill=True,\n                                 facecolor='lime', alpha=0.3, \n                                 edgecolor='lime', linewidth=2)\n                ax2.add_patch(polygon)\n\n    ax2.contour(X, Y, Z_surface, levels=10, colors='white', linewidths=0.5, alpha=0.5)\n    ax2.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax2.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11)\n    ax2.set_title('\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u044b \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438 (1900 K \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0430)', fontsize=12)\n    ax2.grid(True, alpha=0.3)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u0440\u0443\u0433 \u0440\u0430\u0434\u0438\u0443\u0441\u0430 \u043f\u0443\u0447\u043a\u0430\n    beam_radius_um = config.LASER_BEAM_RADIUS * 1e6\n    circle = Circle((0, 0), beam_radius_um, fill=False, color='cyan', \n                       linestyle='-', linewidth=2, alpha=0.7)\n    ax2.add_patch(circle)\n    ax2.text(0, -beam_radius_um*1.1, f'\u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430: {beam_radius_um:.0f} \u043c\u043a\u043c', \n            ha='center', color='cyan', fontsize=10)\n\n    fig.colorbar(contour, ax=ax2, shrink=0.9, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n    ax2.set_aspect('equal')\n\n    # 3. \u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax3 = fig.add_subplot(2, 3, 3)\n    center_x = len(x_plot) // 2\n    center_y = len(y_plot) // 2\n    temp_profile = U_physical[center_x, center_y, :, time_idx]\n\n    ax3.plot(temp_profile, z_phys, 'b-', linewidth=3)\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0443 1900 K\n    ax3.axvline(x=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.7,\n                label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    ax3.set_xlabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=11)\n    ax3.set_ylabel('\u0413\u043b\u0443\u0431\u0438\u043d\u0430 z (\u043c\u043a\u043c)', fontsize=11)\n    ax3.set_title('\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u043e \u0433\u043b\u0443\u0431\u0438\u043d\u0435 (\u0446\u0435\u043d\u0442\u0440 \u043f\u0443\u0447\u043a\u0430)', fontsize=12)\n    ax3.grid(True, alpha=0.3)\n    ax3.invert_yaxis()  # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u043d\u0438\u0437\n\n    # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u044b\u0445 \u0433\u043b\u0443\u0431\u0438\u043d\u0430\u0445\n    target_depths = [10, 20, 30]\n    colors = ['cyan', 'lime', 'yellow']\n\n    for depth, color in zip(target_depths, colors):\n        depth_idx = np.argmin(np.abs(z_phys - depth))\n        temp = temp_profile[depth_idx]\n        ax3.plot(temp, depth, 'o', color=color, markersize=10, \n                markeredgecolor='black', linewidth=1.5)\n        ax3.text(temp + 5, depth, f'{temp:.0f} K', fontsize=10, va='center',\n                bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"white\", alpha=0.7))\n\n    ax3.legend(fontsize=10)\n\n    # 4. \u0413\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0439 \u0441\u0440\u0435\u0437 \u043d\u0430 \u0433\u043b\u0443\u0431\u0438\u043d\u0435 20 \u043c\u043a\u043c\n    ax4 = fig.add_subplot(2, 3, 4)\n    depth_idx = np.argmin(np.abs(z_phys - 20))\n    actual_depth = z_phys[depth_idx]\n    depth_slice = U_physical[:, :, depth_idx, time_idx].T\n\n    im4 = ax4.imshow(depth_slice, extent=[x_phys[0], x_phys[-1], y_phys[0], y_phys[-1]], \n                    origin='lower', aspect='auto', cmap='hot')\n    ax4.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax4.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11)\n    ax4.set_title(f'\u0421\u0440\u0435\u0437 \u043d\u0430 \u0433\u043b\u0443\u0431\u0438\u043d\u0435 {actual_depth:.0f} \u043c\u043a\u043c', fontsize=12)\n    ax4.grid(True, alpha=0.3)\n\n    # \u041f\u0435\u0440\u0435\u043a\u0440\u0435\u0441\u0442\u0438\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax4.axhline(y=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n    ax4.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n\n    fig.colorbar(im4, ax=ax4, shrink=0.9, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)')\n\n    # 5. \u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0432\u0434\u043e\u043b\u044c \u043e\u0441\u0438 X \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n    ax5 = fig.add_subplot(2, 3, 5)\n    y_center_idx = len(y_plot) // 2\n    x_profile = U_physical[:, y_center_idx, -1, time_idx]\n\n    ax5.plot(x_phys, x_profile, 'r-', linewidth=3, label='\u041f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c (y=0)')\n    ax5.fill_between(x_phys, config.INITIAL_TEMPERATURE, x_profile, alpha=0.2, color='red')\n\n    # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0443 1900 K\n    ax5.axhline(y=1900, color='lime', linestyle='-', linewidth=2.5, alpha=0.8,\n                label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    ax5.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax5.set_ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=11)\n    ax5.set_title('\u041f\u0440\u043e\u0444\u0438\u043b\u044c \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432\u0434\u043e\u043b\u044c \u043e\u0441\u0438 X', fontsize=12)\n    ax5.grid(True, alpha=0.3)\n\n    # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0440\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430\n    ax5.axvline(x=beam_radius_um, color='cyan', linestyle='--', alpha=0.7, linewidth=2)\n    ax5.axvline(x=-beam_radius_um, color='cyan', linestyle='--', alpha=0.7, linewidth=2)\n    ax5.text(beam_radius_um, config.INITIAL_TEMPERATURE + 10, f'\u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430', \n            fontsize=10, color='cyan', ha='center')\n\n    ax5.legend(fontsize=10)\n\n    # 6. \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c \u0441 \u0430\u043a\u0446\u0435\u043d\u0442\u043e\u043c \u043d\u0430 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u0443 1900 K\n    ax6 = fig.add_subplot(2, 3, 6)\n    ax6.axis('off')\n\n    max_temp = np.max(U_physical[:, :, :, time_idx])\n    min_temp = np.min(U_physical[:, :, :, time_idx])\n    avg_temp = np.mean(U_physical[:, :, :, time_idx])\n\n    # \u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n    isotherm_reached = max_temp &gt;= 1900\n    width_1900 = None\n    depth_1900 = None\n\n    if isotherm_reached:\n        # \u0428\u0438\u0440\u0438\u043d\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        surface_temp = U_physical[:, center_y, -1, time_idx]\n        left_idx = None\n        right_idx = None\n\n        for i in range(center_x, len(x_phys)):\n            if surface_temp[i] &gt;= 1900 and right_idx is None:\n                right_idx = i\n            if surface_temp[center_x - (i-center_x)] &gt;= 1900 and left_idx is None:\n                left_idx = center_x - (i-center_x)\n\n        if left_idx is not None and right_idx is not None:\n            width_1900 = x_phys[right_idx] - x_phys[left_idx]\n\n        # \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f 1900 K\n        center_temp_profile = U_physical[center_x, center_y, :, time_idx]\n        for i in range(len(z_phys)):\n            if center_temp_profile[i] &gt;= 1900:\n                depth_1900 = z_phys[i]\n                break\n\n    info_text = f\"\u0410\u041d\u0410\u041b\u0418\u0417 \u0422\u0415\u041c\u041f\u0415\u0420\u0410\u0422\u0423\u0420\u041d\u041e\u0413\u041e \u041f\u041e\u041b\u042f\\n\"\n    info_text += \"=\" * 40 + \"\\n\\n\"\n    info_text += f\"\u0412\u0420\u0415\u041c\u042f: {t_phys:.1f} \u043c\u043a\u0441\\n\\n\"\n\n    info_text += f\"\u0422\u0415\u041c\u041f\u0415\u0420\u0410\u0422\u0423\u0420\u041d\u042b\u0415 \u0425\u0410\u0420\u0410\u041a\u0422\u0415\u0420\u0418\u0421\u0422\u0418\u041a\u0418:\\n\"\n    info_text += f\"\u2022 \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f: {max_temp:.1f} K\\n\"\n    info_text += f\"\u2022 \u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f: {min_temp:.1f} K\\n\"\n    info_text += f\"\u2022 \u0421\u0440\u0435\u0434\u043d\u044f\u044f: {avg_temp:.1f} K\\n\"\n    info_text += f\"\u2022 \u041f\u0435\u0440\u0435\u0433\u0440\u0435\u0432: {max_temp - config.INITIAL_TEMPERATURE:.1f} K\\n\\n\"\n\n    info_text += f\"\u0418\u0417\u041e\u0422\u0415\u0420\u041c\u0410 1900 K:\\n\"\n    info_text += f\"\u2022 \u0414\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430: {'\u0414\u0410' if isotherm_reached else '\u041d\u0415\u0422'}\\n\"\n    if width_1900 is not None:\n        info_text += f\"\u2022 \u0428\u0438\u0440\u0438\u043d\u0430 \u0437\u043e\u043d\u044b: {width_1900:.1f} \u043c\u043a\u043c\\n\"\n    if depth_1900 is not None:\n        info_text += f\"\u2022 \u0413\u043b\u0443\u0431\u0438\u043d\u0430 \u043f\u0440\u043e\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u044f: {depth_1900:.1f} \u043c\u043a\u043c\\n\"\n\n    if config.LASER_MODE == \"pulsed\":\n        pulse_number = min(int(t_plot[time_idx] // config.LASER_PULSE_PERIOD_NORM) + 1, config.NUM_PULSES)\n        info_text += f\"\\n\u0420\u0415\u0416\u0418\u041c: \u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419\\n\"\n        info_text += f\"\u2022 \u0418\u043c\u043f\u0443\u043b\u044c\u0441: {pulse_number}/{config.NUM_PULSES}\\n\"\n        info_text += f\"\u2022 \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\\n\"\n        info_text += f\"\u2022 \u0427\u0430\u0441\u0442\u043e\u0442\u0430: {config.LASER_REP_RATE:.0f} \u0413\u0446\\n\"\n    else:\n        info_text += f\"\\n\u0420\u0415\u0416\u0418\u041c: \u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\\n\"\n        info_text += f\"\u2022 \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_CONTINUOUS_POWER} \u0412\u0442\\n\"\n        info_text += f\"\u2022 \u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {config.LASER_PEAK_INTENSITY/1e6:.2f} \u041c\u0412\u0442/\u043c\u00b2\\n\"\n\n    info_text += f\"\\n\u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b \u041f\u0423\u0427\u041a\u0410:\\n\"\n    info_text += f\"\u2022 \u0420\u0430\u0434\u0438\u0443\u0441: {config.LASER_BEAM_RADIUS*1e6:.0f} \u043c\u043a\u043c\\n\"\n    info_text += f\"\u2022 \u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b: {config.LASER_WAVELENGTH*1e6:.1f} \u043c\u043a\u043c\\n\\n\"\n\n    info_text += f\"\u0422\u0415\u041c\u041f\u0415\u0420\u0410\u0422\u0423\u0420\u0410 \u041d\u0410 \u0413\u041b\u0423\u0411\u0418\u041d\u0410\u0425:\\n\"\n    for depth, color in zip(target_depths, colors):\n        depth_idx = np.argmin(np.abs(z_phys - depth))\n        temp = U_physical[center_x, center_y, depth_idx, time_idx]\n        info_text += f\"\u2022 {depth} \u043c\u043a\u043c: {temp:.1f} K\\n\"\n\n    ax6.text(0.1, 0.95, info_text, fontsize=11, va='top', linespacing=1.6,\n             bbox=dict(boxstyle=\"round,pad=0.6\", facecolor=\"lightblue\", alpha=0.9))\n\n    mode_text = \"\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439\" if config.LASER_MODE == \"pulsed\" else \"\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439\"\n    power_text = f\"{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\" if config.LASER_MODE == \"pulsed\" else f\"{config.LASER_CONTINUOUS_POWER} \u0412\u0442\"\n\n    plt.suptitle(f'\u0414\u0435\u0442\u0430\u043b\u044c\u043d\u044b\u0439 \u0430\u043d\u0430\u043b\u0438\u0437 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044f\\n\u0420\u0435\u0436\u0438\u043c: {mode_text}, \u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {power_text}, \u0412\u0440\u0435\u043c\u044f: {t_phys:.1f} \u043c\u043a\u0441', \n                fontsize=15, y=0.98)\n\n    plt.tight_layout()\n\n    mode = config.LASER_MODE\n    plt.savefig(f'animations/temperature_field_analysis_{mode}_t{t_phys:.0f}us.png', \n               dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.plot_temperature_evolution","title":"<code>plot_temperature_evolution(U_data, x_plot, y_plot, z_plot, t_plot)</code>","text":"<p>Plots the temperature evolution at the center of the laser beam over time.</p> <p>This visualization helps to understand the heating dynamics within the material  during laser exposure, accommodating both pulsed and continuous laser modes.  The plot displays the temperature changes, key temperature thresholds, and  relevant parameters like pulse timings or continuous power levels.</p> <p>Parameters:</p> Name Type Description Default <code>U_data</code> <code>ndarray</code> <p>Temperature data.</p> required <code>x_plot</code> <code>ndarray</code> <p>X-coordinates for plotting.</p> required <code>y_plot</code> <code>ndarray</code> <p>Y-coordinates for plotting.</p> required <code>z_plot</code> <code>ndarray</code> <p>Z-coordinates for plotting.</p> required <code>t_plot</code> <code>ndarray</code> <p>Time points for plotting.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Temperature values at the center of the beam over time.</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def plot_temperature_evolution(U_data, x_plot, y_plot, z_plot, t_plot):\n    \"\"\"\n    Plots the temperature evolution at the center of the laser beam over time.\n\n    This visualization helps to understand the heating dynamics within the material \n    during laser exposure, accommodating both pulsed and continuous laser modes. \n    The plot displays the temperature changes, key temperature thresholds, and \n    relevant parameters like pulse timings or continuous power levels.\n\n    Args:\n        U_data (numpy.ndarray): Temperature data.\n        x_plot (numpy.ndarray): X-coordinates for plotting.\n        y_plot (numpy.ndarray): Y-coordinates for plotting.\n        z_plot (numpy.ndarray): Z-coordinates for plotting.\n        t_plot (numpy.ndarray): Time points for plotting.\n\n    Returns:\n        numpy.ndarray: Temperature values at the center of the beam over time.\n    \"\"\"\n    U_physical = convert_to_physical_temperature(U_data)\n    t_phys = t_plot * config.CHARACTERISTIC_TIME * 1e6  # \u043c\u043a\u0441\n\n    # \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043f\u0443\u0447\u043a\u0430 \u043d\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n    center_x = len(x_plot) // 2\n    center_y = len(y_plot) // 2\n    surface_z = len(z_plot) - 1\n\n    center_temperature = U_physical[center_x, center_y, surface_z, :]\n\n    plt.figure(figsize=(14, 7))\n\n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0433\u0440\u0430\u0444\u0438\u043a \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b\n    plt.plot(t_phys, center_temperature, 'b-', linewidth=3, label='\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043f\u0443\u0447\u043a\u0430')\n\n    # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430\n    plt.axhline(y=config.INITIAL_TEMPERATURE, color='gray', linestyle='--', linewidth=2,\n                label=f'\u041d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 ({config.INITIAL_TEMPERATURE} K)')\n\n    # \u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K\n    plt.axhline(y=1900, color='lime', linestyle='-', linewidth=2, alpha=0.7,\n                label='\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    if config.LASER_MODE == \"pulsed\":\n        # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u043c\u043e\u043c\u0435\u043d\u0442\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n        impulse_colors = plt.cm.Reds(np.linspace(0.3, 0.8, config.NUM_PULSES))\n\n        for i in range(config.NUM_PULSES):\n            impulse_time = i * config.LASER_PULSE_PERIOD_NORM * config.CHARACTERISTIC_TIME * 1e6\n            impulse_end = impulse_time + config.LASER_PULSE_DURATION_NORM * config.CHARACTERISTIC_TIME * 1e6\n\n            # \u0417\u0430\u043b\u0438\u0432\u043a\u0430 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n            plt.axvspan(impulse_time, impulse_end, alpha=0.15, color=impulse_colors[i])\n\n            # \u0412\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u043b\u0438\u043d\u0438\u0438\n            plt.axvline(x=impulse_time, color='red', linestyle=':', alpha=0.6, linewidth=1)\n            if i == 0:\n                plt.axvline(x=impulse_end, color='red', linestyle=':', alpha=0.6, linewidth=1, \n                           label='\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432')\n\n            # \u041d\u043e\u043c\u0435\u0440\u0430 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n            if i &lt; min(config.NUM_PULSES, 10):  # \u041d\u0435 \u0431\u043e\u043b\u0435\u0435 10 \u043f\u043e\u0434\u043f\u0438\u0441\u0435\u0439\n                plt.text(impulse_time + 2, np.min(center_temperature) + 5, f'{i+1}', \n                        fontsize=9, color='red', fontweight='bold')\n\n        title_text = f'\u042d\u0432\u043e\u043b\u044e\u0446\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430\\n'\n        title_text += f'\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c: {config.NUM_PULSES} \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432, '\n        title_text += f'{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.), {config.LASER_REP_RATE:.0f} \u0413\u0446'\n\n        # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043b\u0435\u0433\u0435\u043d\u0434\u0443 \u0434\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n        from matplotlib.patches import Patch\n        impulse_patch = Patch(facecolor='red', alpha=0.15, label='\u041e\u0431\u043b\u0430\u0441\u0442\u044c \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432')\n\n    else:\n        # \u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c\n        title_text = f'\u042d\u0432\u043e\u043b\u044e\u0446\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430\\n'\n        title_text += f'\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c: {config.LASER_CONTINUOUS_POWER} \u0412\u0442, '\n        title_text += f'\u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: {config.SIMULATION_TIME_PHYSICAL*1e6:.1f} \u043c\u043a\u0441'\n\n        # \u0417\u0430\u043b\u0438\u0432\u043a\u0430 \u043e\u0431\u043b\u0430\u0441\u0442\u0438 \u043d\u0430\u0433\u0440\u0435\u0432\u0430\n        plt.fill_between(t_phys, config.INITIAL_TEMPERATURE, center_temperature, \n                        alpha=0.2, color='blue', label='\u041e\u0431\u043b\u0430\u0441\u0442\u044c \u043d\u0430\u0433\u0440\u0435\u0432\u0430')\n\n    plt.xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n    plt.ylabel('\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 (K)', fontsize=12)\n    plt.title(title_text, fontsize=13)\n    plt.grid(True, alpha=0.3)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0435\n    max_temp = np.max(center_temperature)\n    max_time = t_phys[np.argmax(center_temperature)]\n    overheating = max_temp - config.INITIAL_TEMPERATURE\n\n    # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K\n    isotherm_reached = np.any(center_temperature &gt;= 1900)\n    isotherm_time = None\n    if isotherm_reached:\n        isotherm_idx = np.where(center_temperature &gt;= 1900)[0][0]\n        isotherm_time = t_phys[isotherm_idx]\n\n    info_text = f\"\u041c\u0430\u043a\u0441. \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {max_temp:.1f} K\\n\"\n    info_text += f\"\u041f\u0435\u0440\u0435\u0433\u0440\u0435\u0432: {overheating:.1f} K\\n\"\n    info_text += f\"\u0412\u0440\u0435\u043c\u044f \u043c\u0430\u043a\u0441. \u043d\u0430\u0433\u0440\u0435\u0432\u0430: {max_time:.1f} \u043c\u043a\u0441\\n\"\n\n    if isotherm_reached:\n        info_text += f\"\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\\n\"\n        info_text += f\"\u0412\u0440\u0435\u043c\u044f \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f: {isotherm_time:.1f} \u043c\u043a\u0441\"\n    else:\n        info_text += f\"\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\"\n\n    plt.text(0.02, 0.98, info_text, transform=plt.gca().transAxes,\n             fontsize=11, verticalalignment='top',\n             bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"lightyellow\", alpha=0.8))\n\n    # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0442\u043e\u0447\u043a\u0443 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b\n    plt.scatter([max_time], [max_temp], color='red', s=100, zorder=5, \n                label=f'\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c: {max_temp:.1f} K')\n\n    # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u0442\u043e\u0447\u043a\u0443 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f \u0438\u0437\u043e\u0442\u0435\u0440\u043c\u044b 1900 K \u0435\u0441\u043b\u0438 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u0430\n    if isotherm_reached:\n        plt.scatter([isotherm_time], [1900], color='lime', s=100, zorder=5,\n                    edgecolor='black', linewidth=2, label=f'\u0418\u0437\u043e\u0442\u0435\u0440\u043c\u0430 1900 K')\n\n    plt.legend(loc='lower right', fontsize=10)\n    plt.tight_layout()\n\n    mode = config.LASER_MODE\n    plt.savefig(f'animations/temperature_evolution_center_{mode}.png', dpi=150, bbox_inches='tight')\n    plt.show()\n\n    return center_temperature\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.visualize_laser_pulses","title":"<code>visualize_laser_pulses()</code>","text":"<p>\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f,  \u0430\u0434\u0430\u043f\u0442\u0438\u0440\u0443\u044f\u0441\u044c \u043a \u0442\u0435\u043a\u0443\u0449\u0435\u043c\u0443 \u0440\u0435\u0436\u0438\u043c\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \u043b\u0430\u0437\u0435\u0440\u0430 (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439). \u0412 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442\u0441\u044f \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432,  \u0430 \u0432 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u043c - \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def visualize_laser_pulses():\n    \"\"\"\n    \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432.\n\n    \u041c\u0435\u0442\u043e\u0434 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f, \n    \u0430\u0434\u0430\u043f\u0442\u0438\u0440\u0443\u044f\u0441\u044c \u043a \u0442\u0435\u043a\u0443\u0449\u0435\u043c\u0443 \u0440\u0435\u0436\u0438\u043c\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \u043b\u0430\u0437\u0435\u0440\u0430 (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439).\n    \u0412 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442\u0441\u044f \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u0438\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432, \n    \u0430 \u0432 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u043c - \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0440\u0435\u0436\u0438\u043c \u0438\u0437 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n    current_mode = config.LASER_MODE\n\n    if current_mode == \"pulsed\":\n        # \u0414\u043b\u044f \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 - \u0433\u0430\u0443\u0441\u0441\u043e\u0432\u044b \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u044b\n        # \u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u043f\u0435\u0440\u0432\u044b\u0435 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432\n        num_impulses_to_how = min(config.NUM_PULSES, 5)  # \u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 5 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 \u0434\u043b\u044f \u043d\u0430\u0433\u043b\u044f\u0434\u043d\u043e\u0441\u0442\u0438\n        t_test = np.linspace(0, config.LASER_PULSE_PERIOD_NORM * num_impulses_to_how, 2000)\n        source_values = np.zeros_like(t_test)\n\n        for i, t_val in enumerate(t_test):\n            t_mod = t_val % config.LASER_PULSE_PERIOD_NORM\n            # \u0413\u0430\u0443\u0441\u0441\u043e\u0432 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\n            source_values[i] = config.LASER_AMPLITUDE * np.exp(\n                -(t_mod - config.LASER_PULSE_PERIOD_NORM/2)**2 / \n                (2 * config.LASER_PULSE_SIGMA_NORM**2)\n            )\n\n        # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n        t_phys = t_test * config.CHARACTERISTIC_TIME * 1e6  # \u0432 \u043c\u0438\u043a\u0440\u043e\u0441\u0435\u043a\u0443\u043d\u0434\u044b\n\n        plt.figure(figsize=(12, 5))\n        plt.plot(t_phys, source_values, 'r-', linewidth=2.5, label='\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c \u043b\u0430\u0437\u0435\u0440\u0430')\n        plt.xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n        plt.ylabel('\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=12)\n\n        title = f'\u0412\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u044b\u0445 \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432 (\u0418\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c)\\n'\n        title += f'\u041f\u0438\u043a\u043e\u0432\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_PEAK_POWER:.1f} \u0412\u0442, '\n        title += f'\u0427\u0430\u0441\u0442\u043e\u0442\u0430: {config.LASER_REP_RATE:.0f} \u0413\u0446, '\n        title += f'\u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c: {config.LASER_PULSE_DURATION*1e6:.1f} \u043c\u043a\u0441'\n        plt.title(title, fontsize=13)\n\n        plt.grid(True, alpha=0.3)\n\n        # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u043b\u0438\u043d\u0438\u0438 \u0434\u043b\u044f \u043f\u0435\u0440\u0438\u043e\u0434\u043e\u0432\n        for i in range(num_impulses_to_how + 1):\n            period_time = i * config.LASER_PULSE_PERIOD_NORM * config.CHARACTERISTIC_TIME * 1e6\n            plt.axvline(x=period_time, color='gray', linestyle='--', alpha=0.5, linewidth=1)\n            if i &lt; num_impulses_to_how:\n                plt.text(period_time + 0.5, 0.85 * config.LASER_AMPLITUDE, \n                        f'\u0418\u043c\u043f\u0443\u043b\u044c\u0441 {i+1}', fontsize=10, ha='left')\n\n        # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u0437\u0430\u043b\u0438\u0432\u043a\u0443 \u043f\u043e\u0434 \u043a\u0440\u0438\u0432\u043e\u0439 \u0434\u043b\u044f \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u0430\n        first_impulse_end = config.LASER_PULSE_PERIOD_NORM * config.CHARACTERISTIC_TIME * 1e6\n        mask = t_phys &lt;= first_impulse_end\n        plt.fill_between(t_phys[mask], 0, source_values[mask], alpha=0.3, color='red')\n\n        # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n        info_text = f\"\u0412\u0441\u0435\u0433\u043e \u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043e\u0432: {config.NUM_PULSES}\\n\"\n        info_text += f\"\u041f\u0435\u0440\u0438\u043e\u0434: {config.LASER_PULSE_PERIOD*1e6:.1f} \u043c\u043a\u0441\\n\"\n        info_text += f\"\u0421\u043a\u0432\u0430\u0436\u043d\u043e\u0441\u0442\u044c: {config.LASER_DUTY_CYCLE*100:.1f}%\\n\"\n        info_text += f\"\u0421\u0440\u0435\u0434\u043d\u044f\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_AVG_POWER} \u0412\u0442\"\n\n        plt.text(0.02, 0.98, info_text, transform=plt.gca().transAxes,\n                fontsize=10, verticalalignment='top',\n                bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"lightyellow\", alpha=0.8))\n\n        plt.legend(loc='upper right')\n        plt.tight_layout()\n        plt.savefig('animations/laser_pulse_profile_gaussian.png', dpi=150, bbox_inches='tight')\n        plt.show()\n\n    else:\n        # \u0414\u043b\u044f \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430 - \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n        t_test = np.linspace(0, config.SIMULATION_TIME_NORM, 1000)\n        source_values = np.ones_like(t_test) * config.LASER_AMPLITUDE\n\n        # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n        t_phys = t_test * config.CHARACTERISTIC_TIME * 1e6  # \u0432 \u043c\u0438\u043a\u0440\u043e\u0441\u0435\u043a\u0443\u043d\u0434\u044b\n\n        plt.figure(figsize=(12, 5))\n        plt.plot(t_phys, source_values, 'b-', linewidth=2.5, label='\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c \u043b\u0430\u0437\u0435\u0440\u0430')\n        plt.fill_between(t_phys, 0, source_values, alpha=0.3, color='blue')\n        plt.xlabel('\u0412\u0440\u0435\u043c\u044f (\u043c\u043a\u0441)', fontsize=12)\n        plt.ylabel('\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=12)\n\n        title = '\u0412\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u0438\u0437\u043b\u0443\u0447\u0435\u043d\u0438\u044f (\u041d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439 \u0440\u0435\u0436\u0438\u043c)\\n'\n        title += f'\u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_CONTINUOUS_POWER} \u0412\u0442, '\n        title += f'\u0414\u043b\u0438\u043d\u0430 \u0432\u043e\u043b\u043d\u044b: {config.LASER_WAVELENGTH*1e6:.1f} \u043c\u043a\u043c'\n        plt.title(title, fontsize=13)\n\n        plt.grid(True, alpha=0.3)\n        plt.ylim(0, config.LASER_AMPLITUDE * 1.1)\n\n        # \u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u0430\u044f \u043f\u0430\u043d\u0435\u043b\u044c\n        info_text = f\"\u0420\u0435\u0436\u0438\u043c: \u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\\n\"\n        info_text += f\"\u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {config.LASER_CONTINUOUS_POWER} \u0412\u0442\\n\"\n        info_text += f\"\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c: {config.LASER_PEAK_INTENSITY/1e6:.2f} \u041c\u0412\u0442/\u043c\u00b2\\n\"\n        info_text += f\"\u0412\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f: {config.SIMULATION_TIME_PHYSICAL*1e6:.1f} \u043c\u043a\u0441\"\n\n        plt.text(0.02, 0.98, info_text, transform=plt.gca().transAxes,\n                fontsize=10, verticalalignment='top',\n                bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"lightblue\", alpha=0.8))\n\n        # \u041e\u0442\u043c\u0435\u0442\u0438\u043c \u043d\u0430\u0447\u0430\u043b\u043e \u0438 \u043a\u043e\u043d\u0435\u0446 \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438\n        plt.axvline(x=0, color='green', linestyle='-', alpha=0.7, linewidth=2, label='\u041d\u0430\u0447\u0430\u043b\u043e')\n        plt.axvline(x=config.SIMULATION_TIME_PHYSICAL*1e6, color='red', linestyle='-', \n                   alpha=0.7, linewidth=2, label='\u041a\u043e\u043d\u0435\u0446')\n\n        plt.legend(loc='upper right')\n        plt.tight_layout()\n        plt.savefig('animations/laser_continuous_profile.png', dpi=150, bbox_inches='tight')\n        plt.show()\n</code></pre>"},{"location":"PINN_3D_real_parms/visual/#PINN_3D_real_parms.visual.visualize_laser_spatial_profile","title":"<code>visualize_laser_spatial_profile()</code>","text":"<p>\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430.</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a \u0438 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u0443\u044e \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0449\u0438\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430 \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435.  \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0440\u0430\u0434\u0438\u0443\u0441\u0435 \u043f\u0443\u0447\u043a\u0430 \u0438 \u0440\u0435\u0436\u0438\u043c\u0435 \u0435\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u044b (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439). \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442\u0441\u044f \u0432 \u0444\u0430\u0439\u043b \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\u0435.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>PINN_3D_real_parms/visual.py</code> <pre><code>def visualize_laser_spatial_profile():\n    \"\"\"\n    \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430.\n\n    \u041c\u0435\u0442\u043e\u0434 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a \u0438 \u0442\u0440\u0435\u0445\u043c\u0435\u0440\u043d\u0443\u044e \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0449\u0438\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430 \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435.  \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0440\u0430\u0434\u0438\u0443\u0441\u0435 \u043f\u0443\u0447\u043a\u0430 \u0438 \u0440\u0435\u0436\u0438\u043c\u0435 \u0435\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u044b (\u0438\u043c\u043f\u0443\u043b\u044c\u0441\u043d\u044b\u0439 \u0438\u043b\u0438 \u043d\u0435\u043f\u0440\u0435\u0440\u044b\u0432\u043d\u044b\u0439). \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442\u0441\u044f \u0432 \u0444\u0430\u0439\u043b \u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044f \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\u0435.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0440\u0435\u0436\u0438\u043c\n    current_mode = config.LASER_MODE\n\n    x_test = np.linspace(-1, 1, 200)\n    y_test = np.linspace(-1, 1, 200)\n    X, Y = np.meshgrid(x_test, y_test)\n\n    # \u0413\u0430\u0443\u0441\u0441\u043e\u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u043f\u0443\u0447\u043a\u0430\n    spatial_dist = config.LASER_AMPLITUDE * np.exp(-(X**2 + Y**2) / (config.LASER_SIGMA_NORM**2))\n\n    # \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u044f \u0432 \u0444\u0438\u0437\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b (\u043c\u043a\u043c)\n    X_phys = X * config.CHARACTERISTIC_LENGTH * 1e6\n    Y_phys = Y * config.CHARACTERISTIC_LENGTH * 1e6\n\n    fig = plt.figure(figsize=(15, 6))\n\n    # 1. \u041a\u043e\u043d\u0442\u0443\u0440\u043d\u044b\u0439 \u0433\u0440\u0430\u0444\u0438\u043a\n    ax1 = fig.add_subplot(1, 2, 1)\n    contour = ax1.contourf(X_phys, Y_phys, spatial_dist, levels=50, cmap='hot')\n    plt.colorbar(contour, ax=ax1, label='\u041e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c')\n    ax1.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax1.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043f\u0435\u0440\u0435\u043a\u0440\u0435\u0441\u0442\u0438\u0435 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435\n    ax1.axhline(y=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n    ax1.axvline(x=0, color='white', linestyle='--', alpha=0.5, linewidth=1)\n    ax1.plot(0, 0, 'w+', markersize=12, markeredgewidth=2, label='\u0426\u0435\u043d\u0442\u0440 \u043f\u0443\u0447\u043a\u0430')\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u0440\u0443\u0433 \u0440\u0430\u0434\u0438\u0443\u0441\u0430 \u043f\u0443\u0447\u043a\u0430\n    beam_radius_um = config.LASER_BEAM_RADIUS * 1e6\n    circle = plt.Circle((0, 0), beam_radius_um, fill=False, color='cyan', \n                       linestyle='-', linewidth=2, alpha=0.8, label=f'\u0420\u0430\u0434\u0438\u0443\u0441 \u043f\u0443\u0447\u043a\u0430: {beam_radius_um:.0f} \u043c\u043a\u043c')\n    ax1.add_patch(circle)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043a\u0440\u0443\u0433 \u043d\u0430 1/e\u00b2 \u0440\u0430\u0434\u0438\u0443\u0441\u0435\n    radius_1e2 = beam_radius_um / np.sqrt(2)\n    circle_1e2 = plt.Circle((0, 0), radius_1e2, fill=False, color='lime', \n                           linestyle='--', linewidth=1.5, alpha=0.7, label=f'1/e\u00b2 \u0440\u0430\u0434\u0438\u0443\u0441: {radius_1e2:.0f} \u043c\u043a\u043c')\n    ax1.add_patch(circle_1e2)\n\n    mode_text = \"\u0418\u041c\u041f\u0423\u041b\u042c\u0421\u041d\u042b\u0419\" if current_mode == \"pulsed\" else \"\u041d\u0415\u041f\u0420\u0415\u0420\u042b\u0412\u041d\u042b\u0419\"\n    power_text = f\"{config.LASER_AVG_POWER} \u0412\u0442 (\u0441\u0440.)\" if current_mode == \"pulsed\" else f\"{config.LASER_CONTINUOUS_POWER} \u0412\u0442\"\n\n    ax1.set_title(f'\u041f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430\\n\u0420\u0435\u0436\u0438\u043c: {mode_text}', fontsize=13)\n    ax1.legend(loc='upper right', fontsize=9)\n    ax1.grid(True, alpha=0.2)\n    ax1.set_aspect('equal')\n\n    # 2. 3D \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\n    ax2 = fig.add_subplot(1, 2, 2, projection='3d')\n\n    # \u0411\u0435\u0440\u0435\u043c \u043f\u043e\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0447\u0435\u043a \u0434\u043b\u044f 3D \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n    X_3d = X_phys[::4, ::4]\n    Y_3d = Y_phys[::4, ::4]\n    Z_3d = spatial_dist[::4, ::4]\n\n    surf = ax2.plot_surface(X_3d, Y_3d, Z_3d, cmap='hot', alpha=0.8, \n                           rstride=1, cstride=1, linewidth=0.5, antialiased=True)\n    ax2.set_xlabel('x (\u043c\u043a\u043c)', fontsize=11)\n    ax2.set_ylabel('y (\u043c\u043a\u043c)', fontsize=11)\n    ax2.set_zlabel('\u0418\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u044c', fontsize=11)\n    ax2.set_title('3D \u043f\u0440\u043e\u0444\u0438\u043b\u044c \u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u043e\u0441\u0442\u0438', fontsize=13)\n\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0440\u0435\u0436\u0438\u043c\u0435 \u0432 3D \u0433\u0440\u0430\u0444\u0438\u043a\n    info_text_3d = f\"\u0420\u0435\u0436\u0438\u043c: {mode_text}\\n\"\n    info_text_3d += f\"\u041c\u043e\u0449\u043d\u043e\u0441\u0442\u044c: {power_text}\\n\"\n    info_text_3d += f\"\u0420\u0430\u0434\u0438\u0443\u0441: {beam_radius_um:.0f} \u043c\u043a\u043c\"\n\n    ax2.text2D(0.05, 0.95, info_text_3d, transform=ax2.transAxes,\n              fontsize=10, verticalalignment='top',\n              bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"white\", alpha=0.7))\n\n    # \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0443\u0433\u043b\u0430 \u043e\u0431\u0437\u043e\u0440\u0430\n    ax2.view_init(elev=30, azim=45)\n\n    plt.suptitle(f'\u0425\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0447\u043a\u0430\\n', fontsize=14, y=0.98)\n    plt.tight_layout()\n    plt.savefig(f'animations/laser_spatial_profile_{current_mode}.png', dpi=150, bbox_inches='tight')\n    plt.show()\n</code></pre>"},{"location":"data_base/","title":"Data Processing","text":""},{"location":"data_base/#overview","title":"Overview","text":"<p>This module provides functionalities for data extraction from databases, image segmentation and analysis, and profile data processing. It includes tools for sorting files, automating profile analysis, and managing microscope image segmentation. The module utilizes SQLite databases and relies on libraries like Pandas for data manipulation.</p>"},{"location":"data_base/#purpose","title":"Purpose","text":"<p>This module serves to extract, process, and analyze data generated from laser-based experiments, specifically focusing on microscope images and corresponding profiles. It aims to provide a pipeline for retrieving data from a database, segmenting images to identify regions of interest, automatically analyzing profile data related to laser interactions, and storing/visualizing the results. Core features include database interaction, automated image segmentation, and tools for precise profile analysis, contributing to a broader understanding of laser-material interactions and characterization of laser-induced processes.</p>"},{"location":"data_base/data_extract/","title":"Data Extract","text":""},{"location":"data_base/data_extract/#data_base.data_extract.jpeg_extract","title":"<code>jpeg_extract()</code>","text":"<p>Fetches a JPEG image from an SQLite database and saves it to a file.</p> <p>This method retrieves the first image stored in the 'microscope_results' table of the 'ILT_data_base.db' database and writes it to a JPEG file named '\u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435_\u0438\u0437_\u0431\u0430\u0437\u044b.jpg'. This allows for the extraction and preservation of visual data captured during microscopic analysis.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>data_base/data_extract.py</code> <pre><code>def jpeg_extract():\n    \"\"\"\n    Fetches a JPEG image from an SQLite database and saves it to a file.\n\n    This method retrieves the first image stored in the 'microscope_results' table of the 'ILT_data_base.db' database and writes it to a JPEG file named '\u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435_\u0438\u0437_\u0431\u0430\u0437\u044b.jpg'. This allows for the extraction and preservation of visual data captured during microscopic analysis.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 (\u0438\u043b\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0439)\n    conn = sqlite3.connect('ILT_data_base.db')\n    cursor = conn.cursor()\n\n    # SQL-\u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u043a\u0438 \u043c\u0438\u043a\u0440\u043e\u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0438\u0439\n    select_query = \"SELECT micro_photo FROM microscope_results;\"   # \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0432\u0430\u0448 \u0437\u0430\u043f\u0440\u043e\u0441 \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 SQLlite\n    cursor.execute(select_query)\n    rows = cursor.fetchall()\n    for row in rows:\n        blob_data = row[0]\n\n    # \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\n    conn.close()\n\n    #\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0438\u0437 blob \u0432 \u0444\u0430\u0439\u043b jpg\n    with open('\u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435_\u0438\u0437_\u0431\u0430\u0437\u044b.jpg', 'wb') as file:\n        file.write(blob_data)\n</code></pre>"},{"location":"data_base/data_extract/#data_base.data_extract.text_extract","title":"<code>text_extract()</code>","text":"<p>Retrieves all records from the 'laser_modes' table in the 'ILT_data_base.db' SQLite database and displays them.</p> <p>This method is used to access and present the stored laser mode data for review or further processing.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>data_base/data_extract.py</code> <pre><code>def text_extract():\n    \"\"\"\n    Retrieves all records from the 'laser_modes' table in the 'ILT_data_base.db' SQLite database and displays them.\n\n    This method is used to access and present the stored laser mode data for review or further processing.\n\n    Args:\n      None\n\n    Returns:\n      None\n    \"\"\"\n    # \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 (\u0438\u043b\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0439)\n    conn = sqlite3.connect('ILT_data_base.db')\n    cursor = conn.cursor()\n\n    # SQL-\u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n    select_query = \"SELECT * FROM laser_modes\"  # \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0432\u0430\u0448 \u0437\u0430\u043f\u0440\u043e\u0441 \u043d\u0430 \u044f\u0437\u044b\u043a\u0435 SQLlite\n\n    # \u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n    cursor.execute(select_query)\n\n    # \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0432\u0441\u0435\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n    rows = cursor.fetchall()\n\n    # \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n    for row in rows:\n        print(row)\n\n    # \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\n    conn.close()\n</code></pre>"},{"location":"data_base/mass_segmentation/","title":"Mass Segmentation","text":""},{"location":"data_base/mass_segmentation/#data_base.mass_segmentation.segmentation_for_folder","title":"<code>segmentation_for_folder(folder)</code>","text":"<p>Segments images in a folder and returns segmentation results.</p> <p>This method processes images within a specified folder, performing segmentation on each image to identify regions of interest, potentially related to laser-material interactions. It refines the segmentation by iteratively adjusting a black level parameter to optimize the results. Segmented images are saved to a designated directory for further analysis.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The path to the folder containing the images to be segmented.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing three lists: <code>result_list</code>, <code>avg_result_list</code>, and <code>std_div_result_list</code>. <code>result_list</code> stores lists of segmentation widths for each image. <code>avg_result_list</code> stores lists of average widths for each image. <code>std_div_result_list</code> stores lists of standard deviations for each image.</p> Source code in <code>data_base/mass_segmentation.py</code> <pre><code>def segmentation_for_folder(folder):\n    \"\"\"\n    Segments images in a folder and returns segmentation results.\n\n    This method processes images within a specified folder, performing segmentation\n    on each image to identify regions of interest, potentially related to laser-material interactions.\n    It refines the segmentation by iteratively adjusting a black level parameter to optimize the results.\n    Segmented images are saved to a designated directory for further analysis.\n\n    Args:\n        folder (str): The path to the folder containing the images to be segmented.\n\n    Returns:\n        tuple: A tuple containing three lists: `result_list`, `avg_result_list`,\n            and `std_div_result_list`.\n            `result_list` stores lists of segmentation widths for each image.\n            `avg_result_list` stores lists of average widths for each image.\n            `std_div_result_list` stores lists of standard deviations for each image.\n    \"\"\"\n    result_list, sup_list, avg_result_list, avg_sup_list, std_div_result_list, std_div_sup_list   = [], [], [], [], [], []\n    path = folder\n    filenames = sorting_folder(path)\n    for index, file in enumerate(filenames):\n        black_level = 50\n        img_path = os.path.join(os.path.abspath(folder), file)\n        width, img_to_save, avg_width, std_div = Segmentation.segmentation(Segmentation.crop_center_square(img_path), Segmentation.calculate_percentile_brightness(img_path, black_level))\n        prev_width, prev_img_to_save, prev_avg_width, prev_std_div = width, img_to_save, avg_width, std_div\n        if width &gt; 30:\n            while width &gt; 30:  \n                prev_width, prev_img_to_save, prev_avg_width, prev_std_div = width, img_to_save, avg_width, std_div\n                black_level -= 1\n                width, img_to_save, avg_width, std_div = Segmentation.segmentation(Segmentation.crop_center_square(img_path), Segmentation.calculate_percentile_brightness(img_path, black_level))\n        else:\n            width, img_to_save, avg_width, std_div = Segmentation.segmentation(Segmentation.crop_center_square(img_path), Segmentation.calculate_percentile_brightness(img_path, black_level, type_='brigth'), type_='brigth')\n            while width &gt; 30:\n                prev_width, prev_img_to_save, prev_avg_width, prev_std_div = width, img_to_save, avg_width, std_div\n                black_level -= 2\n                width, img_to_save, avg_width, std_div = Segmentation.segmentation(Segmentation.crop_center_square(img_path), Segmentation.calculate_percentile_brightness(img_path, black_level, type_='brigth'), type_='brigth')\n\n\n        if prev_img_to_save is not None:\n            prev_img_to_save.save(f'/Users/maximmikhalevich/Desktop/project/nirsii/sample_imgs4_segment_4/{file}')\n            if index % 4 == 0:\n                result_list.append(sup_list)\n                avg_result_list.append(avg_sup_list)\n                std_div_result_list.append(std_div_sup_list)\n                sup_list = []\n                avg_sup_list = []\n                std_div_sup_list = []\n            sup_list.append(prev_width)\n            avg_sup_list.append(prev_avg_width)\n            std_div_sup_list.append(prev_std_div)\n\n        #\u043b\u043e\u0433\u0433\u0438\u0440\u043e\u044b\u0432\u043d\u0438\u0435\n        print(f'{index} \u0438\u0437 {len(filenames)} \u0444\u043e\u0442\u043e \u0440\u0430\u0437\u043c\u0435\u0447\u0435\u043d\u043e')\n\n    return (result_list, avg_result_list, std_div_result_list)\n</code></pre>"},{"location":"data_base/mass_segmentation/#data_base.mass_segmentation.sorting_folder","title":"<code>sorting_folder(path)</code>","text":"<p>Sorts files within a folder based on a naming convention, preparing them for sequential processing.</p> <p>The function sorts files in a given directory, assuming filenames start with a numerical prefix followed by an underscore. It first sorts alphabetically by the prefix, then numerically by the prefix (after removing the first element). This ensures files are ordered logically for tasks like time-series analysis or step-by-step processing.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the folder containing the files to sort.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of sorted filenames.</p> Source code in <code>data_base/mass_segmentation.py</code> <pre><code>def sorting_folder(path):\n    \"\"\"\n    Sorts files within a folder based on a naming convention, preparing them for sequential processing.\n\n    The function sorts files in a given directory, assuming filenames start with a numerical prefix\n    followed by an underscore. It first sorts alphabetically by the prefix, then numerically\n    by the prefix (after removing the first element). This ensures files are ordered logically\n    for tasks like time-series analysis or step-by-step processing.\n\n    Args:\n        path (str): The path to the folder containing the files to sort.\n\n    Returns:\n        list: A list of sorted filenames.\n    \"\"\"\n    filenames = os.listdir(path)\n    filenames.sort(key=lambda file: file.split('_')[0])\n    filenames = filenames[1:]\n    filenames.sort(key=lambda file: int(file.split('_')[0]))\n    return filenames\n</code></pre>"},{"location":"data_base/profile/","title":"Rofile","text":""},{"location":"data_base/profile/#data_base.profile.Profile","title":"<code>Profile</code>","text":"<p>A class for processing and analyzing profile data.</p> Source code in <code>data_base/profile.py</code> <pre><code>class Profile():\n  \"\"\"\n  A class for processing and analyzing profile data.\n  \"\"\"\n\n\n  def auto_profile(profile, full_data):\n    \"\"\"\n    Identifies and characterizes regions of interest within profile data.\n\n    This method compares a profile dataset to a full dataset to pinpoint areas\n    where the profile's 'z' values are notably higher than the median 'z'\n    value of the full dataset. It then determines the width and maximum\n    depth of these regions, returning them as a dictionary of parameters.\n    This helps to highlight areas of significant variation or activity within the profile.\n\n    Args:\n        profile (pd.DataFrame): The profile data to analyze, expected to have 'x' and 'z' columns.\n        full_data (pd.DataFrame): The full dataset used to calculate the median 'z' value, expected to have 'z' column.\n\n    Returns:\n        dict: A dictionary where keys are region numbers (starting from 1) and\n            values are tuples containing the width (in mm) and depth of each\n            identified region.  Returns an empty dictionary if no regions are found.\n    \"\"\"\n\n    mediana = np.median(full_data['z'])\n    print(mediana)\n\n    result = []\n    start = 0\n    for i in range(len(profile)):\n      if profile['z'].iloc[i] - mediana &gt; mediana*5:\n        if start == 0:\n          start = i\n      else:\n        if start != 0:\n          end = i\n          result.append((start, end))\n          start = 0\n\n    parametrs = {}\n    for key, pair in enumerate(result):\n      width = float(round(profile.iloc[pair[1]]['x'] - profile.iloc[pair[0]]['x'], 5)) * 1000\n      depth = profile.iloc[pair[0]: pair[1]]['z'].max()\n\n      parametrs[key+1] = (width, depth)\n\n    return parametrs\n\n\n  def auto_profile_40(profile):\n    \"\"\"\n    Calculates the maximum 'z' value for segments of a profile.\n\n    This method divides the input profile into segments of approximately equal size\n    (based on a chunk size of 40) and returns a list containing the maximum 'z'\n    value found within each segment. This is useful for identifying peaks or significant\n    heights within the profile data, which can be relevant for analyzing surface features\n    or material characteristics.\n\n    Args:\n        profile (list): The input profile data, expected to be a list of dictionaries,\n            where each dictionary contains a 'z' key.\n\n    Returns:\n        list: A list of floats, where each float represents the maximum 'z' value\n            found in a segment of the input profile.\n    \"\"\"\n\n    chunk = len(profile) // 40\n    prev_i = 0\n    result = []\n    for i in range(chunk, len(profile), chunk):\n      segment = profile[prev_i : i]\n      result.append(max(segment['z']))\n      prev_i = i\n\n    return result\n\n\n  def mass_profile():\n    \"\"\"\n    Calculates and stores mass profiles for multiple samples to characterize laser-material interactions.\n\n    This method processes data from eleven samples, extracting and analyzing mass distribution to understand the effects of laser processing. It reads data, filters it based on spatial coordinates, and generates averaged profiles representing the mass distribution for each sample.\n\n    Args:\n        None\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the averaged mass profiles for each sample (sample_1 to sample_11).  The values in each column represent the rounded, averaged mass profile data.\n    \"\"\"\n\n    result_frame = pd.DataFrame()\n\n    for i in range(1, 12):\n      sup_list = np.zeros([])\n      for j in range(1 ,4):\n        data = pd.read_csv(f'/content/sample_data/big/imgs4_x{i}_{j}.txt', names=['x', 'z'], sep=' ')\n        data['x'] = data['x'].apply(dots).apply(float)\n        data['z'] = data['z'].apply(dots).apply(float)\n        data = data[(data['x'] &gt; 5.0) &amp; (data['x'] &lt; 49)]\n\n        result = Profile.auto_profile_40(data) \n        if sup_list.all():\n          sup_list += np.array(result)\n        else:\n          sup_list = np.array(result)\n\n\n      result_frame[f'sample_{i}'] = np.round(sup_list / 3, 5)\n\n\n  def save_profile(result_frame):\n      \"\"\"\n      Saves the processed data to a CSV file for further analysis and record-keeping.\n\n      Args:\n          result_frame: The DataFrame containing the profile data to be saved.\n\n      Returns:\n          None\n      \"\"\"\n\n      result_frame = result_frame[result_frame.columns[::-1]][::-1]\n      result_frame.to_csv('profile.csv')\n\n\n  def plot_check():\n    \"\"\"\n    Generates visualizations of data acquired from experiments.\n\n    This method processes a sequence of CSV files, extracting and plotting data points \n    corresponding to specific conditions.  The plotted data helps in evaluating \n    experimental results and identifying trends or anomalies.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    for i in range(1, 12):\n      sup_list = np.zeros([])\n      for j in range(1 ,4):\n        data = pd.read_csv(f'/content/sample_data/big/imgs4_x{i}_{j}.txt', names=['x', 'z'], sep=' ')\n        data['x'] = data['x'].apply(dots).apply(float)\n        data['z'] = data['z'].apply(dots).apply(float)\n        data = data[(data['x'] &gt; 5.0) &amp; (data['x'] &lt; 49)]\n\n        fig, ax = plt.subplots(figsize=(8,5))\n        plt.plot(data['x'], data['z'])\n        ax.set_title(f'sample{i}_{j}')\n        ax.set_xlabel(\"X, \u043c\u043c\")\n        ax.set_ylabel(\"z, \u043c\u043a\u043c\")\n        plt.show()\n</code></pre>"},{"location":"data_base/profile/#data_base.profile.Profile.auto_profile","title":"<code>auto_profile(profile, full_data)</code>","text":"<p>Identifies and characterizes regions of interest within profile data.</p> <p>This method compares a profile dataset to a full dataset to pinpoint areas where the profile's 'z' values are notably higher than the median 'z' value of the full dataset. It then determines the width and maximum depth of these regions, returning them as a dictionary of parameters. This helps to highlight areas of significant variation or activity within the profile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>DataFrame</code> <p>The profile data to analyze, expected to have 'x' and 'z' columns.</p> required <code>full_data</code> <code>DataFrame</code> <p>The full dataset used to calculate the median 'z' value, expected to have 'z' column.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary where keys are region numbers (starting from 1) and values are tuples containing the width (in mm) and depth of each identified region.  Returns an empty dictionary if no regions are found.</p> Source code in <code>data_base/profile.py</code> <pre><code>def auto_profile(profile, full_data):\n  \"\"\"\n  Identifies and characterizes regions of interest within profile data.\n\n  This method compares a profile dataset to a full dataset to pinpoint areas\n  where the profile's 'z' values are notably higher than the median 'z'\n  value of the full dataset. It then determines the width and maximum\n  depth of these regions, returning them as a dictionary of parameters.\n  This helps to highlight areas of significant variation or activity within the profile.\n\n  Args:\n      profile (pd.DataFrame): The profile data to analyze, expected to have 'x' and 'z' columns.\n      full_data (pd.DataFrame): The full dataset used to calculate the median 'z' value, expected to have 'z' column.\n\n  Returns:\n      dict: A dictionary where keys are region numbers (starting from 1) and\n          values are tuples containing the width (in mm) and depth of each\n          identified region.  Returns an empty dictionary if no regions are found.\n  \"\"\"\n\n  mediana = np.median(full_data['z'])\n  print(mediana)\n\n  result = []\n  start = 0\n  for i in range(len(profile)):\n    if profile['z'].iloc[i] - mediana &gt; mediana*5:\n      if start == 0:\n        start = i\n    else:\n      if start != 0:\n        end = i\n        result.append((start, end))\n        start = 0\n\n  parametrs = {}\n  for key, pair in enumerate(result):\n    width = float(round(profile.iloc[pair[1]]['x'] - profile.iloc[pair[0]]['x'], 5)) * 1000\n    depth = profile.iloc[pair[0]: pair[1]]['z'].max()\n\n    parametrs[key+1] = (width, depth)\n\n  return parametrs\n</code></pre>"},{"location":"data_base/profile/#data_base.profile.Profile.auto_profile_40","title":"<code>auto_profile_40(profile)</code>","text":"<p>Calculates the maximum 'z' value for segments of a profile.</p> <p>This method divides the input profile into segments of approximately equal size (based on a chunk size of 40) and returns a list containing the maximum 'z' value found within each segment. This is useful for identifying peaks or significant heights within the profile data, which can be relevant for analyzing surface features or material characteristics.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>list</code> <p>The input profile data, expected to be a list of dictionaries, where each dictionary contains a 'z' key.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of floats, where each float represents the maximum 'z' value found in a segment of the input profile.</p> Source code in <code>data_base/profile.py</code> <pre><code>def auto_profile_40(profile):\n  \"\"\"\n  Calculates the maximum 'z' value for segments of a profile.\n\n  This method divides the input profile into segments of approximately equal size\n  (based on a chunk size of 40) and returns a list containing the maximum 'z'\n  value found within each segment. This is useful for identifying peaks or significant\n  heights within the profile data, which can be relevant for analyzing surface features\n  or material characteristics.\n\n  Args:\n      profile (list): The input profile data, expected to be a list of dictionaries,\n          where each dictionary contains a 'z' key.\n\n  Returns:\n      list: A list of floats, where each float represents the maximum 'z' value\n          found in a segment of the input profile.\n  \"\"\"\n\n  chunk = len(profile) // 40\n  prev_i = 0\n  result = []\n  for i in range(chunk, len(profile), chunk):\n    segment = profile[prev_i : i]\n    result.append(max(segment['z']))\n    prev_i = i\n\n  return result\n</code></pre>"},{"location":"data_base/profile/#data_base.profile.Profile.mass_profile","title":"<code>mass_profile()</code>","text":"<p>Calculates and stores mass profiles for multiple samples to characterize laser-material interactions.</p> <p>This method processes data from eleven samples, extracting and analyzing mass distribution to understand the effects of laser processing. It reads data, filters it based on spatial coordinates, and generates averaged profiles representing the mass distribution for each sample.</p> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the averaged mass profiles for each sample (sample_1 to sample_11).  The values in each column represent the rounded, averaged mass profile data.</p> Source code in <code>data_base/profile.py</code> <pre><code>def mass_profile():\n  \"\"\"\n  Calculates and stores mass profiles for multiple samples to characterize laser-material interactions.\n\n  This method processes data from eleven samples, extracting and analyzing mass distribution to understand the effects of laser processing. It reads data, filters it based on spatial coordinates, and generates averaged profiles representing the mass distribution for each sample.\n\n  Args:\n      None\n\n  Returns:\n      pd.DataFrame: A DataFrame containing the averaged mass profiles for each sample (sample_1 to sample_11).  The values in each column represent the rounded, averaged mass profile data.\n  \"\"\"\n\n  result_frame = pd.DataFrame()\n\n  for i in range(1, 12):\n    sup_list = np.zeros([])\n    for j in range(1 ,4):\n      data = pd.read_csv(f'/content/sample_data/big/imgs4_x{i}_{j}.txt', names=['x', 'z'], sep=' ')\n      data['x'] = data['x'].apply(dots).apply(float)\n      data['z'] = data['z'].apply(dots).apply(float)\n      data = data[(data['x'] &gt; 5.0) &amp; (data['x'] &lt; 49)]\n\n      result = Profile.auto_profile_40(data) \n      if sup_list.all():\n        sup_list += np.array(result)\n      else:\n        sup_list = np.array(result)\n\n\n    result_frame[f'sample_{i}'] = np.round(sup_list / 3, 5)\n</code></pre>"},{"location":"data_base/profile/#data_base.profile.Profile.plot_check","title":"<code>plot_check()</code>","text":"<p>Generates visualizations of data acquired from experiments.</p> <p>This method processes a sequence of CSV files, extracting and plotting data points  corresponding to specific conditions.  The plotted data helps in evaluating  experimental results and identifying trends or anomalies.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>data_base/profile.py</code> <pre><code>def plot_check():\n  \"\"\"\n  Generates visualizations of data acquired from experiments.\n\n  This method processes a sequence of CSV files, extracting and plotting data points \n  corresponding to specific conditions.  The plotted data helps in evaluating \n  experimental results and identifying trends or anomalies.\n\n  Args:\n      None\n\n  Returns:\n      None\n  \"\"\"\n\n  for i in range(1, 12):\n    sup_list = np.zeros([])\n    for j in range(1 ,4):\n      data = pd.read_csv(f'/content/sample_data/big/imgs4_x{i}_{j}.txt', names=['x', 'z'], sep=' ')\n      data['x'] = data['x'].apply(dots).apply(float)\n      data['z'] = data['z'].apply(dots).apply(float)\n      data = data[(data['x'] &gt; 5.0) &amp; (data['x'] &lt; 49)]\n\n      fig, ax = plt.subplots(figsize=(8,5))\n      plt.plot(data['x'], data['z'])\n      ax.set_title(f'sample{i}_{j}')\n      ax.set_xlabel(\"X, \u043c\u043c\")\n      ax.set_ylabel(\"z, \u043c\u043a\u043c\")\n      plt.show()\n</code></pre>"},{"location":"data_base/profile/#data_base.profile.Profile.save_profile","title":"<code>save_profile(result_frame)</code>","text":"<p>Saves the processed data to a CSV file for further analysis and record-keeping.</p> <p>Parameters:</p> Name Type Description Default <code>result_frame</code> <p>The DataFrame containing the profile data to be saved.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>data_base/profile.py</code> <pre><code>def save_profile(result_frame):\n    \"\"\"\n    Saves the processed data to a CSV file for further analysis and record-keeping.\n\n    Args:\n        result_frame: The DataFrame containing the profile data to be saved.\n\n    Returns:\n        None\n    \"\"\"\n\n    result_frame = result_frame[result_frame.columns[::-1]][::-1]\n    result_frame.to_csv('profile.csv')\n</code></pre>"},{"location":"data_base/segmentation_1/","title":"Segmentation 1","text":""},{"location":"data_base/segmentation_1/#data_base.segmentation_1.Segmentation","title":"<code>Segmentation</code>","text":"<p>This class performs image segmentation tasks, including applying masks based on contrast and converting images to BLOB format.</p> <pre><code>Attributes:\n    None\n\nClass Methods:\n- segmentation: Applies a mask to the input image based on its contrast, preparing it for database storage by converting it to BLOB format.\n- calculate_percentile_brightness: Calculates the percentile brightness of an image, allowing for calculation from either the darker or brighter side.\n- crop_center_square: Crops the center square region from an image.\n</code></pre> Source code in <code>data_base/segmentation_1.py</code> <pre><code>class Segmentation():\n    \"\"\"\n    This class performs image segmentation tasks, including applying masks based on contrast and converting images to BLOB format.\n\n        Attributes:\n            None\n\n        Class Methods:\n        - segmentation: Applies a mask to the input image based on its contrast, preparing it for database storage by converting it to BLOB format.\n        - calculate_percentile_brightness: Calculates the percentile brightness of an image, allowing for calculation from either the darker or brighter side.\n        - crop_center_square: Crops the center square region from an image.\n    \"\"\"\n\n    def segmentation(img, black_lavel, type_='dark'):\n\n        \"\"\"\n        Performs image segmentation based on contrast, preparing the image for database storage by converting it to a BLOB format.\n\n        Args:\n            img (str): Path to the image file.\n            black_lavel (int): Threshold value for segmentation, ranging from 0 to 255.\n            type_ (str, optional): Segmentation type. 'dark' for highlighting dark objects, otherwise highlights bright objects. Defaults to 'dark'.\n\n        Returns:\n            tuple: A tuple containing the width of the segmented object in micrometers, the segmented image as a PIL object, and the average width and standard deviation of the segmented object.\n                - width (float): Width of the segmented object in micrometers.\n                - image_pil (PIL.Image.Image): Segmented image as a PIL object.\n                - avg_width (float): Average width of the segmented object in micrometers.\n                - std_width (float): Standard deviation of the segmented object's width in micrometers.\n        \"\"\"\n\n        # \u0427\u0442\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n        try:\n            image = cv2.imread(img)\n        except:\n            image = img\n\n        sup = Image.fromarray(image)\n\n        # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0432 \u043e\u0442\u0442\u0435\u043d\u043a\u0438 \u0441\u0435\u0440\u043e\u0433\u043e\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n        # \u0411\u0438\u043d\u0430\u0440\u0438\u0437\u0430\u0446\u0438\u044f\n        if type_ == 'dark':\n            _, thresh = cv2.threshold(\n                gray, black_lavel, 255, cv2.THRESH_BINARY_INV)\n        else:\n            _, thresh = cv2.threshold(\n                gray, black_lavel, 255, cv2.THRESH_BINARY)\n\n\n        def other_segment(thresh):\n            thresh_test = thresh.T\n            width_result  = []\n            width_count = 0\n            for i in range(thresh_test.shape[0]):\n                width_iter = []\n                for j in range(thresh_test.shape[1]):\n                    if thresh_test[i][j] != 0:\n                        width_count += 1\n                    else:\n                        if width_count != 0:\n                            width_iter.append(width_count)\n                            width_count = 0\n                width_iter.append(width_count)\n                width_result.append(max(width_iter))\n\n            #print(f'\u0421\u041f\u0418\u0421\u041e\u041a {width_result}')    \n            return sum(width_result) / len(width_result) * 0.53836990\n\n        other_width = other_segment(thresh)\n        #print(f' TEST OTVET {other_segment(thresh) * 0.53836990} micrometetrs')\n\n        sup = Image.fromarray(thresh)\n        sup.save('sup_image.jpg')\n\n        # \u041f\u043e\u0438\u0441\u043a \u043a\u043e\u043d\u0442\u0443\u0440\u043e\u0432\n        contours, _ = cv2.findContours(\n            thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n        # \u041f\u043e\u0438\u0441\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n        def darkest_object_func(contours):\n            darkest_object = None\n            min_avg_intensity = 256\n            for cnt in contours:\n                mask = np.zeros(gray.shape[:2], dtype=np.uint8)\n                cv2.drawContours(mask, [cnt], -1, 255, -1)\n                mean_intensity = cv2.mean(gray, mask=mask)[0]\n                if mean_intensity &lt; min_avg_intensity:\n                    darkest_object = cnt\n                    min_avg_intensity = mean_intensity\n            return darkest_object\n\n        # \u041f\u043e\u0438\u0441\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0441\u0432\u0435\u0442\u043b\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n\n        def brightest_object_func(contours):\n            brightest_object = None\n            min_avg_intensity = -1\n            for cnt in contours:\n                mask = np.zeros(gray.shape[:2], dtype=np.uint8)\n                cv2.drawContours(mask, [cnt], -1, 255, -1)\n                mean_intensity = cv2.mean(gray, mask=mask)[0]\n                if mean_intensity &gt; min_avg_intensity:\n                    brightest_object = cnt\n                    min_avg_intensity = mean_intensity\n            return brightest_object\n\n        # \u041d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043a\u0440\u0430\u0439\u043d\u0438\u0445 \u0442\u043e\u0447\u0435\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n        if type_ == 'dark':\n            # print('USE DARK TYPE')\n            segment_object = darkest_object_func(contours)\n        else:\n            # print('USE BRIGHT TYPE')\n            segment_object = brightest_object_func(contours)\n\n\n        def other_segment_3(arr):\n            try:\n                arr_reshaped = arr.reshape(-1, 2)\n\n                # 2. \u0421\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043f\u043e X (\u043f\u0435\u0440\u0432\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430)\n                sorted_indices = np.argsort(arr_reshaped[:, 0])\n                sorted_arr_reshaped = arr_reshaped[sorted_indices]\n\n                # 3. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0444\u043e\u0440\u043c\u0443 (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)\n                sorted_arr = sorted_arr_reshaped.reshape(-1, 1, 2)\n\n                '''\n                for elem in sorted_arr:\n                    print('elem',elem[0][0])\n                '''\n                prev_elem = sorted_arr[0][0]\n                sup_list = []\n                result_list = []\n                for elem in sorted_arr:\n                    if elem[0][0] == prev_elem[0]:\n                        sup_list.append(elem[0])        \n                        prev_elem = elem[0]\n                    else:\n                        # prev_elem_ = sup_list[0]\n                        max_width = float('-inf')\n                        for i, elem_1 in enumerate(sup_list, 1):\n                            for elem_2 in sup_list[i:]:\n                                if abs(elem_1[1] - elem_2[1]) &gt; max_width:\n                                    max_width = abs(elem_1[1] - elem_2[1])\n\n                            # if abs(elem_[1] - prev_elem_[1]) &gt; max_width:\n                            #     max_width = abs(elem_[1] - prev_elem_[1])\n                            # prev_elem_ = elem_    \n                        result_list.append(max_width)\n                        max_width = float('inf')\n                        sup_list = []\n                        sup_list.append(elem[0])        \n                        prev_elem = elem[0]\n\n                result_list = list(filter(lambda elem: elem &gt; 60, result_list))\n                result_array = np.array(result_list)\n\n                try:\n                    result_1 = sum(result_list)/len(result_list) * 0.53836990\n                    result_2 = np.std(result_array) * 0.53836990\n                    return(result_1, result_2)\n                except:\n                    return (0, 0)\n            except:\n                return (0, 0)    \n\n        # \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u043f\u0440\u0438 \u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0435 \u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0438\u0438 '4_image_0_1600.jpeg' \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438 \n        #~~~ Segmentation.segmentation(test_img, Segmentation.calculate_percentile_brightness(test_img, 30)) ~~~ \n        # \u044f\u0432\u043b\u044f\u043b\u0441\u044f \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043b\u0438\u043d\u044b 514, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e 272 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f != 0, \u043f\u0440\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 X = 515 \u0438 \u043e\u0431\u0449\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0442\u043e\u0447\u0435\u043a \u0432 \u043a\u043e\u043d\u0442\u0443\u0440\u0435 = 950\n        # \u041f\u0440\u0438 \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0431\u0430\u0440\u044c\u0435\u0440\u0430 \u0444\u0438\u043b\u044c\u0442\u0440\u0430\u0446\u0438\u0438 \u0432 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0435 &gt; [20:60] \u0434\u043b\u0438\u043d\u0430 \u0438\u0442\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f, \u0437\u043d\u0430\u0447\u0438\u0442 \u0432 \u044d\u0442\u043e\u0439 \u043e\u0431\u043b\u0430\u0442\u0441\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043d\u0435\u0442, \n        # \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u044f, \u0447\u0442\u043e 60 px \u044d\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e +- \u0432 25 \u043c\u043a\u043c, \u0447\u0442\u043e \u043c\u0435\u043d\u044c\u0448\u0435 \u0434\u0438\u0430\u043c\u0435\u0442\u0440\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043e\u0442\u043f\u0435\u0447\u0430\u0442\u043a\u0430 \u043d\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u0430, \n        # \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c layer_width = 60 px, \u043a\u0430\u043a \u043f\u043e\u0440\u043e\u0433\u043e\u0432\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u0441 \u043d\u0438\u0436\u043d\u0435\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b  \n\n        #other_segment_3(contours)\n        # print(len(np.unique(segment_object[:, :, 0])))\n        # print(len(segment_object[:, :, 0]))\n        avg_width = other_segment_3(segment_object)\n\n\n        if segment_object is not None:\n            leftmost = tuple(\n                segment_object[segment_object[:, :, 0].argmin()][0])\n            rightmost = tuple(\n                segment_object[segment_object[:, :, 0].argmax()][0])\n            topmost = tuple(\n                segment_object[segment_object[:, :, 1].argmin()][0])\n            bottommost = tuple(\n                segment_object[segment_object[:, :, 1].argmax()][0])\n\n            lenght = np.round(0.53836990 * (rightmost[0] - leftmost[0]), 5)\n            width = np.round(0.53836990 * (bottommost[1] - topmost[1]), 5)\n\n        else:\n            print(f\"\u0421\u0430\u043c\u044b\u0439 {type_} \u043e\u0431\u044a\u0435\u043a\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d.\")\n            return (0, 0, 0, 0)\n\n        # \u0420\u0438\u0441\u0443\u0435\u043c \u043a\u043e\u043d\u0442\u0443\u0440 \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n        if segment_object is not None:\n            cv2.drawContours(image, [segment_object], -1, (0, 255, 0), 2)\n\n            # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0441 \u0440\u0430\u0437\u043c\u0435\u0440\u0430\u043c\u0438\n            cv2.putText(image, f'Width: {width} micrometers', (20, 30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n            cv2.putText(image, f'Lenght: {lenght} micrometers', (20, 60),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n            cv2.putText(image, f'avg width: {avg_width[0]} micrometers', (20, 90),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n            cv2.putText(image, f'standart deviation : {avg_width[1]} micrometers', (20, 120),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n\n\n        # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438\u0437 BGR \u0432 RGB\n        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n        # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0432 \u043e\u0431\u044a\u0435\u043a\u0442 PIL\n        image_pil = Image.fromarray(image_rgb)\n\n        # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n        image_pil.save('test_pic_2.jpg')\n\n        def image_to_blob(image_path):\n            with open(image_path, 'rb') as file:\n                blob_data = file.read()\n            return blob_data\n\n        return (width, image_pil, avg_width[0], avg_width[1])\n\n    def calculate_percentile_brightness(image_path, procentage: int, type_='dark'):\n        \"\"\"\n        Calculates a specified percentile of image brightness.\n\n        Args:\n            image_path (str or numpy.ndarray): The path to the image file or a numpy array representing the image.\n            procentage (int): The percentile value to calculate (0-100).\n            type_ (str, optional):  If 'dark', calculates the percentile from the darker side of the image. \n                                    Otherwise, calculates from the brighter side. Defaults to 'dark'.\n\n        Returns:\n            float: The calculated percentile brightness value.\n\n        This method determines the brightness level that corresponds to a given percentile within the image's pixel intensity distribution. \n        By default, it finds the brightness value below which a specified percentage of pixels fall (darker side). \n        When `type_` is not 'dark', it effectively calculates the percentile from the brighter side of the image by inverting the percentage value.\n        \"\"\"\n        # \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432 \u0447\u0435\u0440\u043d\u043e-\u0431\u0435\u043b\u043e\u0435\n        try:\n            image = Image.open(image_path).convert('L')\n            pixels = np.array(image)\n        except:\n            pixels = np.array(image_path)\n\n        if type_ != 'dark':\n            procentage = abs(100-procentage)\n        percentile = np.percentile(pixels, procentage)\n\n        return percentile\n\n    def crop_center_square(image_path):\n        \"\"\"\n        Crops the center square from an image, ensuring consistent input for subsequent analysis.\n\n        Args:\n            image_path (str): The path to the image file.\n\n        Returns:\n            numpy.ndarray: A NumPy array representing the cropped image.\n        \"\"\"\n        # \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n        img = Image.open(image_path)\n\n        # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n        width, height = img.size\n        size = height // 2\n        # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0434\u043b\u044f \u043e\u0431\u0440\u0435\u0437\u043a\u0438 \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430\n        left = width // 2\n        top = (height - size) // 2\n        right = width\n        bottom = (height + size) // 2\n\n        # \u041e\u0431\u0440\u0435\u0437\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n        cropped_img = img.crop((left, top, right, bottom))\n        # image_pil = Image.fromarray(cropped_img)\n        return np.array(cropped_img)\n</code></pre>"},{"location":"data_base/segmentation_1/#data_base.segmentation_1.Segmentation.calculate_percentile_brightness","title":"<code>calculate_percentile_brightness(image_path, procentage, type_='dark')</code>","text":"<p>Calculates a specified percentile of image brightness.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str or ndarray</code> <p>The path to the image file or a numpy array representing the image.</p> required <code>procentage</code> <code>int</code> <p>The percentile value to calculate (0-100).</p> required <code>type_</code> <code>str</code> <p>If 'dark', calculates the percentile from the darker side of the image.                      Otherwise, calculates from the brighter side. Defaults to 'dark'.</p> <code>'dark'</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated percentile brightness value.</p> <p>This method determines the brightness level that corresponds to a given percentile within the image's pixel intensity distribution.  By default, it finds the brightness value below which a specified percentage of pixels fall (darker side).  When <code>type_</code> is not 'dark', it effectively calculates the percentile from the brighter side of the image by inverting the percentage value.</p> Source code in <code>data_base/segmentation_1.py</code> <pre><code>def calculate_percentile_brightness(image_path, procentage: int, type_='dark'):\n    \"\"\"\n    Calculates a specified percentile of image brightness.\n\n    Args:\n        image_path (str or numpy.ndarray): The path to the image file or a numpy array representing the image.\n        procentage (int): The percentile value to calculate (0-100).\n        type_ (str, optional):  If 'dark', calculates the percentile from the darker side of the image. \n                                Otherwise, calculates from the brighter side. Defaults to 'dark'.\n\n    Returns:\n        float: The calculated percentile brightness value.\n\n    This method determines the brightness level that corresponds to a given percentile within the image's pixel intensity distribution. \n    By default, it finds the brightness value below which a specified percentage of pixels fall (darker side). \n    When `type_` is not 'dark', it effectively calculates the percentile from the brighter side of the image by inverting the percentage value.\n    \"\"\"\n    # \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432 \u0447\u0435\u0440\u043d\u043e-\u0431\u0435\u043b\u043e\u0435\n    try:\n        image = Image.open(image_path).convert('L')\n        pixels = np.array(image)\n    except:\n        pixels = np.array(image_path)\n\n    if type_ != 'dark':\n        procentage = abs(100-procentage)\n    percentile = np.percentile(pixels, procentage)\n\n    return percentile\n</code></pre>"},{"location":"data_base/segmentation_1/#data_base.segmentation_1.Segmentation.crop_center_square","title":"<code>crop_center_square(image_path)</code>","text":"<p>Crops the center square from an image, ensuring consistent input for subsequent analysis.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str</code> <p>The path to the image file.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: A NumPy array representing the cropped image.</p> Source code in <code>data_base/segmentation_1.py</code> <pre><code>def crop_center_square(image_path):\n    \"\"\"\n    Crops the center square from an image, ensuring consistent input for subsequent analysis.\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        numpy.ndarray: A NumPy array representing the cropped image.\n    \"\"\"\n    # \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n    img = Image.open(image_path)\n\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n    width, height = img.size\n    size = height // 2\n    # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0434\u043b\u044f \u043e\u0431\u0440\u0435\u0437\u043a\u0438 \u0446\u0435\u043d\u0442\u0440\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430\n    left = width // 2\n    top = (height - size) // 2\n    right = width\n    bottom = (height + size) // 2\n\n    # \u041e\u0431\u0440\u0435\u0437\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n    cropped_img = img.crop((left, top, right, bottom))\n    # image_pil = Image.fromarray(cropped_img)\n    return np.array(cropped_img)\n</code></pre>"},{"location":"data_base/segmentation_1/#data_base.segmentation_1.Segmentation.segmentation","title":"<code>segmentation(img, black_lavel, type_='dark')</code>","text":"<p>Performs image segmentation based on contrast, preparing the image for database storage by converting it to a BLOB format.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>str</code> <p>Path to the image file.</p> required <code>black_lavel</code> <code>int</code> <p>Threshold value for segmentation, ranging from 0 to 255.</p> required <code>type_</code> <code>str</code> <p>Segmentation type. 'dark' for highlighting dark objects, otherwise highlights bright objects. Defaults to 'dark'.</p> <code>'dark'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the width of the segmented object in micrometers, the segmented image as a PIL object, and the average width and standard deviation of the segmented object. - width (float): Width of the segmented object in micrometers. - image_pil (PIL.Image.Image): Segmented image as a PIL object. - avg_width (float): Average width of the segmented object in micrometers. - std_width (float): Standard deviation of the segmented object's width in micrometers.</p> Source code in <code>data_base/segmentation_1.py</code> <pre><code>def segmentation(img, black_lavel, type_='dark'):\n\n    \"\"\"\n    Performs image segmentation based on contrast, preparing the image for database storage by converting it to a BLOB format.\n\n    Args:\n        img (str): Path to the image file.\n        black_lavel (int): Threshold value for segmentation, ranging from 0 to 255.\n        type_ (str, optional): Segmentation type. 'dark' for highlighting dark objects, otherwise highlights bright objects. Defaults to 'dark'.\n\n    Returns:\n        tuple: A tuple containing the width of the segmented object in micrometers, the segmented image as a PIL object, and the average width and standard deviation of the segmented object.\n            - width (float): Width of the segmented object in micrometers.\n            - image_pil (PIL.Image.Image): Segmented image as a PIL object.\n            - avg_width (float): Average width of the segmented object in micrometers.\n            - std_width (float): Standard deviation of the segmented object's width in micrometers.\n    \"\"\"\n\n    # \u0427\u0442\u0435\u043d\u0438\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\n    try:\n        image = cv2.imread(img)\n    except:\n        image = img\n\n    sup = Image.fromarray(image)\n\n    # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0432 \u043e\u0442\u0442\u0435\u043d\u043a\u0438 \u0441\u0435\u0440\u043e\u0433\u043e\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    # \u0411\u0438\u043d\u0430\u0440\u0438\u0437\u0430\u0446\u0438\u044f\n    if type_ == 'dark':\n        _, thresh = cv2.threshold(\n            gray, black_lavel, 255, cv2.THRESH_BINARY_INV)\n    else:\n        _, thresh = cv2.threshold(\n            gray, black_lavel, 255, cv2.THRESH_BINARY)\n\n\n    def other_segment(thresh):\n        thresh_test = thresh.T\n        width_result  = []\n        width_count = 0\n        for i in range(thresh_test.shape[0]):\n            width_iter = []\n            for j in range(thresh_test.shape[1]):\n                if thresh_test[i][j] != 0:\n                    width_count += 1\n                else:\n                    if width_count != 0:\n                        width_iter.append(width_count)\n                        width_count = 0\n            width_iter.append(width_count)\n            width_result.append(max(width_iter))\n\n        #print(f'\u0421\u041f\u0418\u0421\u041e\u041a {width_result}')    \n        return sum(width_result) / len(width_result) * 0.53836990\n\n    other_width = other_segment(thresh)\n    #print(f' TEST OTVET {other_segment(thresh) * 0.53836990} micrometetrs')\n\n    sup = Image.fromarray(thresh)\n    sup.save('sup_image.jpg')\n\n    # \u041f\u043e\u0438\u0441\u043a \u043a\u043e\u043d\u0442\u0443\u0440\u043e\u0432\n    contours, _ = cv2.findContours(\n        thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n    # \u041f\u043e\u0438\u0441\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n    def darkest_object_func(contours):\n        darkest_object = None\n        min_avg_intensity = 256\n        for cnt in contours:\n            mask = np.zeros(gray.shape[:2], dtype=np.uint8)\n            cv2.drawContours(mask, [cnt], -1, 255, -1)\n            mean_intensity = cv2.mean(gray, mask=mask)[0]\n            if mean_intensity &lt; min_avg_intensity:\n                darkest_object = cnt\n                min_avg_intensity = mean_intensity\n        return darkest_object\n\n    # \u041f\u043e\u0438\u0441\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0441\u0432\u0435\u0442\u043b\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n\n    def brightest_object_func(contours):\n        brightest_object = None\n        min_avg_intensity = -1\n        for cnt in contours:\n            mask = np.zeros(gray.shape[:2], dtype=np.uint8)\n            cv2.drawContours(mask, [cnt], -1, 255, -1)\n            mean_intensity = cv2.mean(gray, mask=mask)[0]\n            if mean_intensity &gt; min_avg_intensity:\n                brightest_object = cnt\n                min_avg_intensity = mean_intensity\n        return brightest_object\n\n    # \u041d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043a\u0440\u0430\u0439\u043d\u0438\u0445 \u0442\u043e\u0447\u0435\u043a \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n    if type_ == 'dark':\n        # print('USE DARK TYPE')\n        segment_object = darkest_object_func(contours)\n    else:\n        # print('USE BRIGHT TYPE')\n        segment_object = brightest_object_func(contours)\n\n\n    def other_segment_3(arr):\n        try:\n            arr_reshaped = arr.reshape(-1, 2)\n\n            # 2. \u0421\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043f\u043e X (\u043f\u0435\u0440\u0432\u0430\u044f \u043a\u043e\u043b\u043e\u043d\u043a\u0430)\n            sorted_indices = np.argsort(arr_reshaped[:, 0])\n            sorted_arr_reshaped = arr_reshaped[sorted_indices]\n\n            # 3. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0444\u043e\u0440\u043c\u0443 (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e)\n            sorted_arr = sorted_arr_reshaped.reshape(-1, 1, 2)\n\n            '''\n            for elem in sorted_arr:\n                print('elem',elem[0][0])\n            '''\n            prev_elem = sorted_arr[0][0]\n            sup_list = []\n            result_list = []\n            for elem in sorted_arr:\n                if elem[0][0] == prev_elem[0]:\n                    sup_list.append(elem[0])        \n                    prev_elem = elem[0]\n                else:\n                    # prev_elem_ = sup_list[0]\n                    max_width = float('-inf')\n                    for i, elem_1 in enumerate(sup_list, 1):\n                        for elem_2 in sup_list[i:]:\n                            if abs(elem_1[1] - elem_2[1]) &gt; max_width:\n                                max_width = abs(elem_1[1] - elem_2[1])\n\n                        # if abs(elem_[1] - prev_elem_[1]) &gt; max_width:\n                        #     max_width = abs(elem_[1] - prev_elem_[1])\n                        # prev_elem_ = elem_    \n                    result_list.append(max_width)\n                    max_width = float('inf')\n                    sup_list = []\n                    sup_list.append(elem[0])        \n                    prev_elem = elem[0]\n\n            result_list = list(filter(lambda elem: elem &gt; 60, result_list))\n            result_array = np.array(result_list)\n\n            try:\n                result_1 = sum(result_list)/len(result_list) * 0.53836990\n                result_2 = np.std(result_array) * 0.53836990\n                return(result_1, result_2)\n            except:\n                return (0, 0)\n        except:\n            return (0, 0)    \n\n    # \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u043f\u0440\u0438 \u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0435 \u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0438\u0438 '4_image_0_1600.jpeg' \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438 \n    #~~~ Segmentation.segmentation(test_img, Segmentation.calculate_percentile_brightness(test_img, 30)) ~~~ \n    # \u044f\u0432\u043b\u044f\u043b\u0441\u044f \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043b\u0438\u043d\u044b 514, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e 272 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f != 0, \u043f\u0440\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 X = 515 \u0438 \u043e\u0431\u0449\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u0442\u043e\u0447\u0435\u043a \u0432 \u043a\u043e\u043d\u0442\u0443\u0440\u0435 = 950\n    # \u041f\u0440\u0438 \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0431\u0430\u0440\u044c\u0435\u0440\u0430 \u0444\u0438\u043b\u044c\u0442\u0440\u0430\u0446\u0438\u0438 \u0432 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0435 &gt; [20:60] \u0434\u043b\u0438\u043d\u0430 \u0438\u0442\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f, \u0437\u043d\u0430\u0447\u0438\u0442 \u0432 \u044d\u0442\u043e\u0439 \u043e\u0431\u043b\u0430\u0442\u0441\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043d\u0435\u0442, \n    # \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u044f, \u0447\u0442\u043e 60 px \u044d\u043a\u0432\u0438\u0432\u0430\u043b\u0435\u043d\u0442\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e +- \u0432 25 \u043c\u043a\u043c, \u0447\u0442\u043e \u043c\u0435\u043d\u044c\u0448\u0435 \u0434\u0438\u0430\u043c\u0435\u0442\u0440\u0430 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043e\u0442\u043f\u0435\u0447\u0430\u0442\u043a\u0430 \u043d\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043b\u0430\u0437\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u0430, \n    # \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c layer_width = 60 px, \u043a\u0430\u043a \u043f\u043e\u0440\u043e\u0433\u043e\u0432\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u0441 \u043d\u0438\u0436\u043d\u0435\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u044b  \n\n    #other_segment_3(contours)\n    # print(len(np.unique(segment_object[:, :, 0])))\n    # print(len(segment_object[:, :, 0]))\n    avg_width = other_segment_3(segment_object)\n\n\n    if segment_object is not None:\n        leftmost = tuple(\n            segment_object[segment_object[:, :, 0].argmin()][0])\n        rightmost = tuple(\n            segment_object[segment_object[:, :, 0].argmax()][0])\n        topmost = tuple(\n            segment_object[segment_object[:, :, 1].argmin()][0])\n        bottommost = tuple(\n            segment_object[segment_object[:, :, 1].argmax()][0])\n\n        lenght = np.round(0.53836990 * (rightmost[0] - leftmost[0]), 5)\n        width = np.round(0.53836990 * (bottommost[1] - topmost[1]), 5)\n\n    else:\n        print(f\"\u0421\u0430\u043c\u044b\u0439 {type_} \u043e\u0431\u044a\u0435\u043a\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d.\")\n        return (0, 0, 0, 0)\n\n    # \u0420\u0438\u0441\u0443\u0435\u043c \u043a\u043e\u043d\u0442\u0443\u0440 \u0441\u0430\u043c\u043e\u0433\u043e \u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n    if segment_object is not None:\n        cv2.drawContours(image, [segment_object], -1, (0, 255, 0), 2)\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0441 \u0440\u0430\u0437\u043c\u0435\u0440\u0430\u043c\u0438\n        cv2.putText(image, f'Width: {width} micrometers', (20, 30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n        cv2.putText(image, f'Lenght: {lenght} micrometers', (20, 60),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n        cv2.putText(image, f'avg width: {avg_width[0]} micrometers', (20, 90),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n        cv2.putText(image, f'standart deviation : {avg_width[1]} micrometers', (20, 120),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n\n\n    # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438\u0437 BGR \u0432 RGB\n    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n    # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0432 \u043e\u0431\u044a\u0435\u043a\u0442 PIL\n    image_pil = Image.fromarray(image_rgb)\n\n    # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n    image_pil.save('test_pic_2.jpg')\n\n    def image_to_blob(image_path):\n        with open(image_path, 'rb') as file:\n            blob_data = file.read()\n        return blob_data\n\n    return (width, image_pil, avg_width[0], avg_width[1])\n</code></pre>"},{"location":"solvers/","title":"Surface Optimizer","text":""},{"location":"solvers/#overview","title":"Overview","text":"<p>This module provides functionalities for optimizing surface shapes based on mechanical properties like stress and stiffness. It utilizes numerical optimization techniques, specifically the Covariance Matrix Adaptation Evolution Strategy (CMA), alongside simulation tools to evaluate surface performance under applied pressure. The module includes tools for Fourier series approximation, data visualization, and result saving.</p>"},{"location":"solvers/#purpose","title":"Purpose","text":"<p>This module is designed to find optimal surface geometries that minimize a defined objective function, balancing stress and stiffness characteristics. It supports running multiple optimization trials, analyzing the results through plots of objective function history and surface/stress distributions, and saving the best performing configurations. The core functionality revolves around simulating 2D contact mechanics and leveraging these simulations within an optimization loop to achieve desired surface properties. It is intended for applications where precise control of surface shape is critical for mechanical performance.</p>"},{"location":"solvers/surface_optimizer/","title":"Surface Optimizer","text":""},{"location":"solvers/surface_optimizer/#overview","title":"Overview","text":"<p>This module provides functionalities for optimizing surface shapes based on mechanical properties like stress and stiffness. It utilizes numerical optimization techniques, specifically the Covariance Matrix Adaptation Evolution Strategy (CMA), alongside simulation tools to evaluate surface performance under applied pressure. The module includes tools for Fourier series approximation, data visualization, and result saving.</p>"},{"location":"solvers/surface_optimizer/#purpose","title":"Purpose","text":"<p>This module is designed to find optimal surface geometries that minimize a defined objective function, balancing stress and stiffness characteristics. It supports running multiple optimization trials, analyzing the results through plots of objective function history and surface/stress distributions, and saving the best performing configurations. The core functionality revolves around simulating 2D contact mechanics and leveraging these simulations within an optimization loop to achieve desired surface properties. It is intended for applications where precise control of surface shape is critical for mechanical performance.</p>"},{"location":"solvers/surface_optimizer/mlwrapper1/","title":"Mlwrapper1","text":""},{"location":"solvers/surface_optimizer/mlwrapper1/#solvers.surface_optimizer.mlwrapper1.mlwrapper1","title":"<code>mlwrapper1(pressure, length, surface_1, E2, nu2, thickness_2=np.inf, maxiter=1000000, tol=1e-08, use_cuda=False, initial_guess=None, log_output=False)</code>","text":"<p>Simulate 2D contact between a rigid body (body 1) and an elastic layer     (body 2) under given pressure to determine the resulting interfacial stress and deformation.</p> <pre><code>Parameters:\n    pressure (float): Pressure of contact (Pa)\n    length (float): Unit cell size in one dimension (m)\n    surface_1 (ndarray): Surface topography unit cell height data (the\n        mesh) of body 1 (m)\n    E2 (float): Young modulus of body 2 (Pa)\n    nu2 (float): Poisson ratio of body 2\n    thickness_2 (float, optional): Thickness of body 2 (m). Body 2 is\n        indented by body 1 on one side and bonded to a rigid flat surface\n        on the other side. Defaults to np.inf (semi-infinite medium)\n    maxiter (int, optional): Maximum number of iterations\n    tol (float, optional): Convergence tolerance threshold\n    use_cuda (bool, optional): Use GPU acceleration\n    initial_guess (ndarray, optional): Initial guess for the gap array\n        between the surfaces (m)\n    log_output (bool, optional): Print solver progress\n\nReturns:\n    dict: Dictionary containing:\n        - max_stress (float): Maximum interfacial stress (Pa)\n        - contact_stiffness (float): Contact stiffness (Pa/m)\n        - stress (ndarray): Interfacial stress array (Pa)\n        - body_2_surface (ndarray): Deformed surface profile of body 2 (m)\n        - gap (ndarray): Final gap array between the surfaces (m). (Can be\n            used as initial_guess in follow-up simulations)\n</code></pre> Source code in <code>solvers/surface_optimizer/mlwrapper1.py</code> <pre><code>def mlwrapper1(\n        pressure,\n        length,\n        surface_1,\n        E2, nu2,\n        thickness_2=np.inf,\n        maxiter=1000000,\n        tol=1e-8,\n        use_cuda=False,\n        initial_guess=None,\n        log_output=False,\n):\n    \"\"\"\n    Simulate 2D contact between a rigid body (body 1) and an elastic layer\n        (body 2) under given pressure to determine the resulting interfacial stress and deformation.\n\n        Parameters:\n            pressure (float): Pressure of contact (Pa)\n            length (float): Unit cell size in one dimension (m)\n            surface_1 (ndarray): Surface topography unit cell height data (the\n                mesh) of body 1 (m)\n            E2 (float): Young modulus of body 2 (Pa)\n            nu2 (float): Poisson ratio of body 2\n            thickness_2 (float, optional): Thickness of body 2 (m). Body 2 is\n                indented by body 1 on one side and bonded to a rigid flat surface\n                on the other side. Defaults to np.inf (semi-infinite medium)\n            maxiter (int, optional): Maximum number of iterations\n            tol (float, optional): Convergence tolerance threshold\n            use_cuda (bool, optional): Use GPU acceleration\n            initial_guess (ndarray, optional): Initial guess for the gap array\n                between the surfaces (m)\n            log_output (bool, optional): Print solver progress\n\n        Returns:\n            dict: Dictionary containing:\n                - max_stress (float): Maximum interfacial stress (Pa)\n                - contact_stiffness (float): Contact stiffness (Pa/m)\n                - stress (ndarray): Interfacial stress array (Pa)\n                - body_2_surface (ndarray): Deformed surface profile of body 2 (m)\n                - gap (ndarray): Final gap array between the surfaces (m). (Can be\n                    used as initial_guess in follow-up simulations)\n    \"\"\"\n    E1 = 1e16 * E2\n    nu1 = 0.5\n    result = solve(\n        pressure,\n        length,\n        surface_1,\n        E1, nu1,\n        E2, nu2,\n        thickness_2=thickness_2,\n        maxiter=maxiter,\n        tol=tol,\n        use_cuda=use_cuda,\n        initial_guess=initial_guess,\n        log_output=log_output,\n    )\n    z2 = result['body_2_surface']\n    result['contact_stiffness'] = pressure / (np.max(z2) - np.min(z2))\n    result['length'] = length\n    return result\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/","title":"Optimize Surface","text":""},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.fourier_series","title":"<code>fourier_series(x, period, a_coeffs, b_coeffs)</code>","text":"<p>Computes the Fourier series approximation of a function.</p> <p>Calculates the Fourier series approximation using provided cosine and sine coefficients to reconstruct a periodic signal. This is useful for representing functions as a sum of simpler trigonometric functions, enabling analysis and manipulation in the frequency domain.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input values at which to evaluate the Fourier series.</p> required <code>period</code> <code>float</code> <p>The period of the function.</p> required <code>a_coeffs</code> <code>ndarray</code> <p>The cosine coefficients of the Fourier series.</p> required <code>b_coeffs</code> <code>ndarray</code> <p>The sine coefficients of the Fourier series.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The computed Fourier series approximation at the given input values.</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def fourier_series(x, period, a_coeffs, b_coeffs):\n    \"\"\"\n    Computes the Fourier series approximation of a function.\n\n    Calculates the Fourier series approximation using provided cosine and sine coefficients to reconstruct a periodic signal. This is useful for representing functions as a sum of simpler trigonometric functions, enabling analysis and manipulation in the frequency domain.\n\n    Args:\n        x (numpy.ndarray): The input values at which to evaluate the Fourier series.\n        period (float): The period of the function.\n        a_coeffs (numpy.ndarray): The cosine coefficients of the Fourier series.\n        b_coeffs (numpy.ndarray): The sine coefficients of the Fourier series.\n\n    Returns:\n        numpy.ndarray: The computed Fourier series approximation at the given input values.\n    \"\"\"\n    n_cos = np.arange(len(a_coeffs))\n    cos_terms = np.cos(2 * np.pi * n_cos[:, None] * x[None, :] / period)\n\n    n_sin = np.arange(1, len(b_coeffs) + 1)\n    sin_terms = np.sin(2 * np.pi * n_sin[:, None] * x[None, :] / period)\n\n    return np.dot(a_coeffs, cos_terms) + np.dot(b_coeffs, sin_terms)\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.make_surface","title":"<code>make_surface(weights, length, num_points, even_func=False)</code>","text":"<p>Creates a surface using a Fourier series.</p> <p>Calculates the values of a Fourier series at given points to generate a surface representation. This allows for the creation of complex shapes and patterns based on a set of weighted frequencies. The function leverages cosine and sine terms, configurable via the <code>even_func</code> parameter, to define the surface.</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>list</code> <p>The weights (coefficients) for the Fourier series.  Determines the amplitude of each frequency component.</p> required <code>length</code> <code>float</code> <p>The total length of the surface along the x-axis.</p> required <code>num_points</code> <code>int</code> <p>The number of points to sample along the surface.  Higher values result in a smoother surface.</p> required <code>even_func</code> <code>bool</code> <p>If True, only cosine terms are used, resulting in an even function symmetric around the y-axis.                           If False, both cosine and sine terms are used for a more general function. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>numpy.ndarray: A NumPy array containing the calculated surface values (y-coordinates) for each x-coordinate.</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def make_surface(weights, length, num_points, even_func=False):\n    \"\"\"\n    Creates a surface using a Fourier series.\n\n    Calculates the values of a Fourier series at given points to generate a surface representation.\n    This allows for the creation of complex shapes and patterns based on a set of weighted frequencies.\n    The function leverages cosine and sine terms, configurable via the `even_func` parameter, to define the surface.\n\n    Args:\n        weights (list): The weights (coefficients) for the Fourier series.  Determines the amplitude of each frequency component.\n        length (float): The total length of the surface along the x-axis.\n        num_points (int): The number of points to sample along the surface.  Higher values result in a smoother surface.\n        even_func (bool, optional): If True, only cosine terms are used, resulting in an even function symmetric around the y-axis. \n                                     If False, both cosine and sine terms are used for a more general function. Defaults to False.\n\n    Returns:\n        numpy.ndarray: A NumPy array containing the calculated surface values (y-coordinates) for each x-coordinate.\n    \"\"\"\n    x = np.linspace(-length / 2, length / 2, num_points, endpoint=False)\n    if even_func:\n        a_coeffs = np.concatenate(([0.0], weights))\n        b_coeffs = []\n    else:\n        assert len(weights) % 2 == 1\n        half = (len(weights) - 1) // 2 + 1\n        a_coeffs = np.concatenate(([0.0], weights[:half]))\n        b_coeffs = np.concatenate(([0.0], weights[half:]))\n    return fourier_series(x, length, a_coeffs, b_coeffs)\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.objective","title":"<code>objective(stress_weight, num_points, weights, pressure, length, young, poisson, tol, even_func)</code>","text":"<p>Calculates an objective function value based on stress and stiffness derived from a mechanical simulation.</p> <p>This method evaluates a design by combining normalized stress and stiffness values obtained from a simulation  that models the material's response to applied pressure. The simulation uses surface geometry defined by input weights  and material properties to calculate these metrics.</p> <p>Parameters:</p> Name Type Description Default <code>stress_weight</code> <code>float</code> <p>Weighting factor for the stress component of the objective function.  A value between 0 and 1.</p> required <code>num_points</code> <code>int</code> <p>The number of points used in the surface generation.</p> required <code>weights</code> <code>list</code> <p>Weights used to define the surface geometry.</p> required <code>pressure</code> <code>float</code> <p>Applied pressure in the simulation.</p> required <code>length</code> <code>float</code> <p>Length parameter used in the simulation.</p> required <code>young</code> <code>float</code> <p>Young's modulus of the material.</p> required <code>poisson</code> <code>float</code> <p>Poisson's ratio of the material.</p> required <code>tol</code> <code>float</code> <p>Tolerance parameter for the simulation.</p> required <code>even_func</code> <code>function</code> <p>Function to ensure even distribution of points.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - value (float): The objective function value, a weighted combination of normalized stress and stiffness. - mlwrapper1_result (dict): The raw results dictionary returned by the <code>mlwrapper1</code> function. - stiffness_ (float): The normalized stiffness value. - stress_ (float): The normalized stress value.</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def objective(stress_weight, num_points, weights, pressure, length, young,\n              poisson,\n              tol, even_func):\n    \"\"\"\n    Calculates an objective function value based on stress and stiffness derived from a mechanical simulation.\n\n    This method evaluates a design by combining normalized stress and stiffness values obtained from a simulation \n    that models the material's response to applied pressure. The simulation uses surface geometry defined by input weights \n    and material properties to calculate these metrics.\n\n    Args:\n        stress_weight (float): Weighting factor for the stress component of the objective function.  A value between 0 and 1.\n        num_points (int): The number of points used in the surface generation.\n        weights (list): Weights used to define the surface geometry.\n        pressure (float): Applied pressure in the simulation.\n        length (float): Length parameter used in the simulation.\n        young (float): Young's modulus of the material.\n        poisson (float): Poisson's ratio of the material.\n        tol (float): Tolerance parameter for the simulation.\n        even_func (function): Function to ensure even distribution of points.\n\n    Returns:\n        tuple: A tuple containing:\n            - value (float): The objective function value, a weighted combination of normalized stress and stiffness.\n            - mlwrapper1_result (dict): The raw results dictionary returned by the `mlwrapper1` function.\n            - stiffness_ (float): The normalized stiffness value.\n            - stress_ (float): The normalized stress value.\n    \"\"\"\n    surface = make_surface(weights, length, num_points, even_func)\n    mlwrapper1_result = mlwrapper1(pressure=pressure, length=length,\n                                   surface_1=surface, E2=young,\n                                   nu2=poisson, tol=tol)\n    stiffness = mlwrapper1_result['contact_stiffness']\n    stress_ = mlwrapper1_result['max_stress'] / pressure\n    stiffness_ = stiffness / (young / (1 - poisson ** 2) / length)\n    w = stress_weight\n    value = w * stress_ + (1 - w) * stiffness_\n    return value, mlwrapper1_result, stiffness_, stress_\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.optimize_surface","title":"<code>optimize_surface(mean, sigma=1.0, save_dir='output', seed=0, num_generations=4000, pressure=1.0, length=1.0, young=1.0, poisson=0.0, num_points=512, stress_weight=0.5, tol=1e-06, even_func=False, improvement_threshold=1e-05, max_no_improvement=50)</code>","text":"<p>Optimizes a surface to minimize a combined objective function of stress and stiffness  using the Covariance Matrix Adaptation Evolution Strategy (CMA).</p> <p>The method iteratively refines a set of weights that define the surface shape,  aiming to achieve a balance between minimizing stress concentration and maximizing  structural stiffness under a given load. Optimization results, including surface  data and performance metrics, are saved for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <p>Initial guess for the surface weights.</p> required <code>sigma</code> <p>Initial step size for the CMA optimization. Defaults to 1.0.</p> <code>1.0</code> <code>save_dir</code> <p>Directory to store optimization results. Defaults to 'output'.</p> <code>'output'</code> <code>seed</code> <p>Random seed for reproducibility. Defaults to 0.</p> <code>0</code> <code>num_generations</code> <p>Maximum number of optimization iterations. Defaults to 4000.</p> <code>4000</code> <code>pressure</code> <p>Applied pressure on the surface. Defaults to 1.</p> <code>1.0</code> <code>length</code> <p>Length of the surface domain. Defaults to 1.</p> <code>1.0</code> <code>young</code> <p>Young's modulus of the material. Defaults to 1.</p> <code>1.0</code> <code>poisson</code> <p>Poisson's ratio of the material. Defaults to 0.</p> <code>0.0</code> <code>num_points</code> <p>Number of discrete points used to represent the surface. Defaults to 512.</p> <code>512</code> <code>stress_weight</code> <p>Weighting factor balancing stress minimization and stiffness maximization. Defaults to 0.5.</p> <code>0.5</code> <code>tol</code> <p>Tolerance for the numerical solver used in the objective function. Defaults to 1e-6.</p> <code>1e-06</code> <code>even_func</code> <p>Flag to enforce symmetry in the surface representation. Defaults to False.</p> <code>False</code> <code>improvement_threshold</code> <p>Minimum improvement in the objective function to continue optimization. Defaults to 1e-5.</p> <code>1e-05</code> <code>max_no_improvement</code> <p>Number of generations without significant improvement before stopping. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The lowest objective function value achieved during optimization.</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def optimize_surface(\n        mean,\n        sigma=1.0,\n        save_dir='output',\n        seed=0,\n        num_generations=4000,\n        pressure=1.,\n        length=1.,\n        young=1.,\n        poisson=0.,\n        num_points=512,\n        stress_weight=0.5,\n        tol=1e-6,\n        even_func=False,\n        improvement_threshold=1e-5,\n        max_no_improvement=50,\n):\n    \"\"\"\n    Optimizes a surface to minimize a combined objective function of stress and stiffness \n    using the Covariance Matrix Adaptation Evolution Strategy (CMA).\n\n    The method iteratively refines a set of weights that define the surface shape, \n    aiming to achieve a balance between minimizing stress concentration and maximizing \n    structural stiffness under a given load. Optimization results, including surface \n    data and performance metrics, are saved for analysis.\n\n    Args:\n        mean: Initial guess for the surface weights.\n        sigma: Initial step size for the CMA optimization. Defaults to 1.0.\n        save_dir: Directory to store optimization results. Defaults to 'output'.\n        seed: Random seed for reproducibility. Defaults to 0.\n        num_generations: Maximum number of optimization iterations. Defaults to 4000.\n        pressure: Applied pressure on the surface. Defaults to 1.\n        length: Length of the surface domain. Defaults to 1.\n        young: Young's modulus of the material. Defaults to 1.\n        poisson: Poisson's ratio of the material. Defaults to 0.\n        num_points: Number of discrete points used to represent the surface. Defaults to 512.\n        stress_weight: Weighting factor balancing stress minimization and stiffness maximization. Defaults to 0.5.\n        tol: Tolerance for the numerical solver used in the objective function. Defaults to 1e-6.\n        even_func: Flag to enforce symmetry in the surface representation. Defaults to False.\n        improvement_threshold: Minimum improvement in the objective function to continue optimization. Defaults to 1e-5.\n        max_no_improvement: Number of generations without significant improvement before stopping. Defaults to 50.\n\n    Returns:\n        float: The lowest objective function value achieved during optimization.\n    \"\"\"\n    path = pathlib.Path(save_dir)\n    path.mkdir(exist_ok=True, parents=True)\n\n    with open(path / 'inputs.json', 'w', encoding='utf-8') as f:\n        json.dump({\n            'stress_weight': stress_weight,\n            'num_weights': len(mean),\n            'num_generations': num_generations,\n            'cma_seed': seed,\n            'cma_sigma': sigma,\n            'num_points': num_points,\n            'pressure': pressure,\n            'length': length,\n            'young_modulus': young,\n            'poisson_ratio': poisson,\n            'gfmd_tolerance': tol,\n            'even_func': even_func,\n            'sigma': sigma,\n        }, f, indent=2)\n\n    bounds = []\n    for i in range(len(mean)):\n        if i == 0:\n            bounds.append([0.0, np.inf])\n        else:\n            bounds.append([-np.inf, np.inf])\n    bounds = np.array(bounds)\n\n    optimizer = CMA(mean=mean, sigma=sigma, seed=seed, bounds=bounds)\n\n    objective_history = []\n\n    try:\n        for generation in range(num_generations):\n            solutions = []\n            for _ in range(optimizer.population_size):\n                weights = optimizer.ask()\n\n                value, mlwrapper1_result, stiffness_, stress_, = objective(\n                    stress_weight, num_points, weights, pressure, length, young,\n                    poisson, tol, even_func)\n\n                solutions.append((weights, value, mlwrapper1_result,\n                                  stress_, stiffness_))\n                print(f\"#{generation}\\t\"\n                      f\"objective={value:.6f}\\t\"\n                      f\"\u03c3_max={stress_:.4f}\\t\"\n                      f\"K={stiffness_:.4f}\\t\"\n                      f\"(weights[:3]={weights[:3]})\")\n\n            best_x, best_value, mlwrapper1_result, stress_, stiffness_ = (\n                min(solutions, key=lambda item: item[1]))\n\n            _save_best(generation, best_value, stress_, stiffness_,\n                       np.asarray(best_x, dtype=float),\n                       path / \"best_per_epoch.csv\")\n\n            optimizer.tell(solutions)\n\n            objective_history.append(best_value)\n\n            idx_compare = len(objective_history) - 1 - max_no_improvement\n            if idx_compare &gt;= 0:\n                improvement = abs(objective_history[idx_compare]\n                                  - objective_history[-1])\n                if improvement &lt; improvement_threshold:\n                    print(f\"Early stopping at generation {generation} - no \"\n                          f\"significant improvement in {max_no_improvement} \"\n                          f\"generations\")\n                    break\n    except KeyboardInterrupt:\n        pass\n\n    best_x, best_value, mlwrapper1_result, _, _ = min(solutions,\n                                                      key=lambda item: item[1])\n\n    z_1 = mlwrapper1_result['body_1_surface']\n    z_2 = mlwrapper1_result['body_2_surface']\n    stress = mlwrapper1_result['stress']\n\n    is_active = z_1 == z_2\n    z = z_1.copy()\n    z[~is_active] = z_2[~is_active]\n    np.savetxt(path / 'surface.txt', np.array([z, is_active]).T, fmt='%s %d',\n               header='z is_active')\n\n    z_1 = np.array([*z_1, z_1[0]])\n    z_2 = np.array([*z_2, z_2[0]])\n    stress = np.array([*stress, stress[0]])\n\n    x = np.linspace(0.0, mlwrapper1_result['length'], len(z_1), endpoint=True)\n\n    np.savetxt(path / 'stress.txt', np.array([x, z_1, z_2, stress]))\n    plot_surfaces_and_stress(path)\n    plot_objective_history(path)\n    return best_value\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.optimize_trials","title":"<code>optimize_trials(num_weights, num_trials, mean_rng_range, save_dir, seed=0, **kwargs)</code>","text":"<p>Runs multiple optimization trials to find optimal surface configurations and saves the results for analysis.</p> <p>This method executes a series of optimization runs, each with a randomly generated starting point, and stores the configuration details and sorted results in a specified directory. This allows for comparison and selection of the best performing configurations.</p> <p>Parameters:</p> Name Type Description Default <code>num_weights</code> <p>The number of weights used in the optimization process.</p> required <code>num_trials</code> <p>The number of independent optimization trials to perform.</p> required <code>mean_rng_range</code> <p>The range from which random means are generated for each trial.</p> required <code>save_dir</code> <p>The directory where the configuration and results will be saved.</p> required <code>seed</code> <p>The random seed for reproducibility. Defaults to 0.</p> <code>0</code> <code>kwargs</code> <p>Additional keyword arguments to be passed to the <code>optimize_surface</code> function, allowing for customization of the optimization process.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def optimize_trials(num_weights, num_trials, mean_rng_range, save_dir, seed=0,\n                    **kwargs):\n    \"\"\"\n    Runs multiple optimization trials to find optimal surface configurations and saves the results for analysis.\n\n    This method executes a series of optimization runs, each with a randomly generated starting point, and stores the configuration details and sorted results in a specified directory. This allows for comparison and selection of the best performing configurations.\n\n    Args:\n        num_weights: The number of weights used in the optimization process.\n        num_trials: The number of independent optimization trials to perform.\n        mean_rng_range: The range from which random means are generated for each trial.\n        save_dir: The directory where the configuration and results will be saved.\n        seed: The random seed for reproducibility. Defaults to 0.\n        kwargs: Additional keyword arguments to be passed to the `optimize_surface` function,\n            allowing for customization of the optimization process.\n\n    Returns:\n        None\n    \"\"\"\n    path = pathlib.Path(save_dir)\n\n    shutil.rmtree(path, ignore_errors=True)\n    path.mkdir(parents=True, exist_ok=True)\n\n    config = {\n        'num_weights': num_weights,\n        'num_trials': num_trials,\n        'mean_rng_range': mean_rng_range,\n        'seed': seed,\n        'kwargs': kwargs,\n    }\n    with open(path / 'config.json', 'w') as f:\n        json.dump(config, f, indent=2)\n\n    objective_values = []\n    for i in range(num_trials):\n        print(f\"Running trial {i}/{num_trials}\")\n        mean = random_mean(num_weights, mean_rng_range, seed + i)\n        result = optimize_surface(mean=mean, save_dir=path / f'{i}',\n                                  seed=seed + i, **kwargs)\n        objective_values.append(result)\n\n    sorted_results = sorted(enumerate(objective_values), key=lambda x: x[1])\n    with open(path / 'results_sorted.txt', 'w') as f:\n        f.write(f\"{'#':3s}  {'objective':&gt;10s}\\n\")\n        for i, objective in sorted_results:\n            f.write(f'{i:3d}  {objective:10.6f}\\n')\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.plot_objective_history","title":"<code>plot_objective_history(path)</code>","text":"<p>Plots the objective function's history from a CSV file.</p> <p>This method visualizes how the optimization process improved over time  by plotting the objective function value at each generation.  This allows for assessment of the optimization's convergence and performance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory containing the 'best_per_epoch.csv' file.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def plot_objective_history(path):\n    \"\"\"\n    Plots the objective function's history from a CSV file.\n\n    This method visualizes how the optimization process improved over time \n    by plotting the objective function value at each generation. \n    This allows for assessment of the optimization's convergence and performance.\n\n    Args:\n        path (str): The path to the directory containing the 'best_per_epoch.csv' file.\n\n    Returns:\n        None\n    \"\"\"\n    data = np.genfromtxt(path / 'best_per_epoch.csv', names=True,\n                         delimiter=',')\n\n    fig, ax = plt.subplots(figsize=(6, 4))\n\n    ax.plot(data['epoch'], data['objective'])\n\n    ax.set_xlabel('Generation')\n    ax.set_ylabel('Objective value')\n    ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)\n\n    plt.tight_layout()\n\n    plt.savefig(path / 'optimization_convergence.png', dpi=300,\n                bbox_inches='tight')\n    plt.savefig(path / 'optimization_convergence.pdf',\n                bbox_inches='tight')\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.plot_surfaces_and_stress","title":"<code>plot_surfaces_and_stress(path)</code>","text":"<p>Plots the optimized and elastic body surfaces, along with the stress distribution.</p> <p>This method visualizes the results of a simulation, displaying the optimized and elastic body surfaces  and the corresponding stress distribution to assess the impact of optimization.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory containing the 'stress.txt' file.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def plot_surfaces_and_stress(path):\n    \"\"\"\n    Plots the optimized and elastic body surfaces, along with the stress distribution.\n\n    This method visualizes the results of a simulation, displaying the optimized and elastic body surfaces \n    and the corresponding stress distribution to assess the impact of optimization.\n\n    Args:\n        path (str): The path to the directory containing the 'stress.txt' file.\n\n    Returns:\n        None\n    \"\"\"\n    x, z_1, z_2, stress = np.loadtxt(path / 'stress.txt')\n    z_1[z_1 != z_2] = np.nan\n\n    fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True,\n                           gridspec_kw={'height_ratios': [1, 1],\n                                        'hspace': 0.1})\n\n    ax[0].plot(x, (z_2 - z_2.min()), '--', label='Elastic body surface')\n    ax[0].plot(x, (z_1 - z_2.min()),\n               label='Optimized surface (active part)', linewidth=2.5)\n    ax[0].set_ylabel('Height')\n    ax[0].grid(True, alpha=0.3, linestyle='--')\n    ax[0].legend(prop={'size': 7})\n\n    ax[1].plot(x, stress, color='#C44536', linewidth=2.5)\n    ax[1].set_xlabel('Position')\n    ax[1].set_ylabel('Stress')\n    ax[1].grid(True, alpha=0.3, linestyle='--')\n\n    plt.subplots_adjust(hspace=0.1)\n\n    plt.savefig(path / 'surfaces_and_stress.png', dpi=300, bbox_inches='tight')\n    plt.savefig(path / 'surfaces_and_stress.pdf', bbox_inches='tight')\n</code></pre>"},{"location":"solvers/surface_optimizer/optimize_surface/#solvers.surface_optimizer.optimize_surface.random_mean","title":"<code>random_mean(size, high, seed)</code>","text":"<p>Generates an array of random numbers with a mean close to zero.</p> <p>This method creates a NumPy array of a specified size, filled with random numbers drawn from a uniform distribution. It constructs the array by combining positive and negative random values to center the distribution around zero, which is useful for initializing simulations or creating balanced datasets.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The desired size of the array.</p> required <code>high</code> <code>float</code> <p>The upper bound for the random numbers (exclusive).</p> required <code>seed</code> <code>int</code> <p>The seed for the random number generator.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: A NumPy array of random numbers.</p> Source code in <code>solvers/surface_optimizer/optimize_surface.py</code> <pre><code>def random_mean(size, high, seed):\n    \"\"\"\n    Generates an array of random numbers with a mean close to zero.\n\n    This method creates a NumPy array of a specified size, filled with random\n    numbers drawn from a uniform distribution. It constructs the array by\n    combining positive and negative random values to center the distribution\n    around zero, which is useful for initializing simulations or creating\n    balanced datasets.\n\n    Args:\n        size (int): The desired size of the array.\n        high (float): The upper bound for the random numbers (exclusive).\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        numpy.ndarray: A NumPy array of random numbers.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    return np.concatenate((rng.uniform(0, high, 1),\n                           rng.uniform(-high, high, size - 1)))\n</code></pre>"},{"location":"solvers/surface_optimizer/src/","title":"src","text":""},{"location":"solvers/surface_optimizer/src/#overview","title":"Overview","text":"<p>This module provides functionalities for simulating and analyzing physical interactions, particularly those involving elastic bodies and wave propagation. It includes tools for optimization, signal processing, data formatting, and animation generation. The module also contains benchmarking and testing routines for performance evaluation and validation.</p>"},{"location":"solvers/surface_optimizer/src/#purpose","title":"Purpose","text":"<p>This module serves as a core component for modeling physical systems, specifically focusing on contact mechanics and wave phenomena. It enables users to solve contact problems between elastic bodies, analyze frequency spectra, format numerical data for presentation, and visualize simulation results through animations. The included optimization algorithms and testing frameworks support the development and validation of numerical methods for these types of simulations. It is designed for applications requiring accurate modeling of material behavior under external forces or wave excitation.</p>"},{"location":"solvers/surface_optimizer/src/animation/","title":"Animation","text":""},{"location":"solvers/surface_optimizer/src/animation/#solvers.surface_optimizer.src.animation.Animation","title":"<code>Animation</code>","text":"<p>A class for generating and saving animations from a series of lines.</p> <pre><code>Attributes:\n    step: The interval between points.\n    interval: The time interval between frames.\n    max_points: The maximum number of points to store.\n    i: The current index of the point being generated.\n    x: A list to store the x-coordinates of the points.\n    y: A list to store the y-coordinates of the points.\n</code></pre> Source code in <code>solvers/surface_optimizer/src/animation.py</code> <pre><code>class Animation:\n    \"\"\"\n    A class for generating and saving animations from a series of lines.\n\n        Attributes:\n            step: The interval between points.\n            interval: The time interval between frames.\n            max_points: The maximum number of points to store.\n            i: The current index of the point being generated.\n            x: A list to store the x-coordinates of the points.\n            y: A list to store the y-coordinates of the points.\n    \"\"\"\n\n    def __init__(self, num, fps=30, length=10.0, max_points=512):\n        \"\"\"\n        Initializes a new instance of the class.\n\n        Args:\n            num (int): The total number of points to generate for the animation.\n            fps (int, optional): Frames per second for the animation. Defaults to 30.\n            length (float, optional): The length of the animation in seconds. Defaults to 10.0.\n            max_points (int, optional): The maximum number of points to store. Defaults to 512.\n\n        Initializes the following class fields:\n            step (int): The interval between points, calculated to ensure a smooth animation based on the desired length and frame rate.\n            interval (float): The time interval between frames, adjusted to maintain the specified frame rate while accommodating the generated points.\n            max_points (int): The maximum number of points that can be stored.\n            i (int): The current index of the point being generated.\n            x (list): A list to store the x-coordinates of the points.\n            y (list): A list to store the y-coordinates of the points.\n\n        Returns:\n            None\n        \"\"\"\n        min_interval = 1 / fps\n        max_frames = math.ceil(length / min_interval)\n        self.step = math.ceil(num / max_frames)\n\n        num_frames = len(range(0, num, self.step))\n        self.interval = max(length / num_frames, min_interval)\n\n        self.max_points = max_points\n        self.i = 0\n        self.x = []\n        self.y = []\n\n    def update(self, lines):\n        \"\"\"\n        Updates the internal data with new lines, sampling points if necessary.\n\n        Args:\n            self: The instance of the class.\n            lines: A list of tuples, where each tuple contains two lists representing x and y coordinates.\n\n        This method processes incoming coordinate data by selectively adding sampled points\n        to maintain a manageable data size while preserving the overall trend. It calculates\n        a sampling interval based on the desired maximum number of points and the length\n        of the input data, ensuring that the data remains representative without becoming\n        excessively large.\n\n        Args:\n            self: The instance of the class.\n            lines (list): A list of tuples, where each tuple contains two lists representing x and y coordinates.\n\n        Returns:\n            None\n        \"\"\"\n        if self.i % self.step == 0:\n            xs = []\n            ys = []\n            for (x, y) in lines:\n                step = math.ceil(len(x) / self.max_points)\n                xs.append(x[::step].copy())\n                ys.append(y[::step].copy())\n            self.x.append(xs)\n            self.y.append(ys)\n        self.i += 1\n\n    def save(self, out_name, x_margin=0.1, y_margin=0.1):\n        \"\"\"\n        Saves the animation to an HTML file.\n\n        This method generates an animation from the stored data, configures the plot axes,\n        and saves the animation as an HTML file. It prepares the visualization by setting\n        axis limits based on the data and specified margins, then creates and saves the animation.\n        Existing files with the same name are removed to prevent conflicts.\n\n        Args:\n            self: The instance of the Animation class.\n            out_name (str): The base name for the output HTML file (without extension).\n            x_margin (float, optional): The margin to add to the x-axis limits. Defaults to 0.1.\n            y_margin (float, optional): The margin to add to the y-axis limits. Defaults to 0.1.\n\n        Returns:\n            None\n        \"\"\"\n        (fig, axes) = plt.subplots()\n        plots = [axes.plot([], [])[0] for _ in self.x[0]]\n        axes.set_xlim(*lim(self.x, x_margin))\n        axes.set_ylim(*lim(self.y, y_margin))\n\n        def update(frame):\n            for (plot, x, y) in zip(plots, self.x[frame], self.y[frame]):\n                plot.set_data(x, y)\n            return plots\n\n        ani = animation.FuncAnimation(fig=fig, func=update, frames=len(self.x),\n                                      interval=self.interval * 1000)\n        shutil.rmtree(f'{out_name}_frames', ignore_errors=True)\n        ani.save(filename=f'{out_name}.html', writer=\"html\")\n</code></pre>"},{"location":"solvers/surface_optimizer/src/animation/#solvers.surface_optimizer.src.animation.Animation.__init__","title":"<code>__init__(num, fps=30, length=10.0, max_points=512)</code>","text":"<p>Initializes a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The total number of points to generate for the animation.</p> required <code>fps</code> <code>int</code> <p>Frames per second for the animation. Defaults to 30.</p> <code>30</code> <code>length</code> <code>float</code> <p>The length of the animation in seconds. Defaults to 10.0.</p> <code>10.0</code> <code>max_points</code> <code>int</code> <p>The maximum number of points to store. Defaults to 512.</p> <code>512</code> Initializes the following class fields <p>step (int): The interval between points, calculated to ensure a smooth animation based on the desired length and frame rate. interval (float): The time interval between frames, adjusted to maintain the specified frame rate while accommodating the generated points. max_points (int): The maximum number of points that can be stored. i (int): The current index of the point being generated. x (list): A list to store the x-coordinates of the points. y (list): A list to store the y-coordinates of the points.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/animation.py</code> <pre><code>def __init__(self, num, fps=30, length=10.0, max_points=512):\n    \"\"\"\n    Initializes a new instance of the class.\n\n    Args:\n        num (int): The total number of points to generate for the animation.\n        fps (int, optional): Frames per second for the animation. Defaults to 30.\n        length (float, optional): The length of the animation in seconds. Defaults to 10.0.\n        max_points (int, optional): The maximum number of points to store. Defaults to 512.\n\n    Initializes the following class fields:\n        step (int): The interval between points, calculated to ensure a smooth animation based on the desired length and frame rate.\n        interval (float): The time interval between frames, adjusted to maintain the specified frame rate while accommodating the generated points.\n        max_points (int): The maximum number of points that can be stored.\n        i (int): The current index of the point being generated.\n        x (list): A list to store the x-coordinates of the points.\n        y (list): A list to store the y-coordinates of the points.\n\n    Returns:\n        None\n    \"\"\"\n    min_interval = 1 / fps\n    max_frames = math.ceil(length / min_interval)\n    self.step = math.ceil(num / max_frames)\n\n    num_frames = len(range(0, num, self.step))\n    self.interval = max(length / num_frames, min_interval)\n\n    self.max_points = max_points\n    self.i = 0\n    self.x = []\n    self.y = []\n</code></pre>"},{"location":"solvers/surface_optimizer/src/animation/#solvers.surface_optimizer.src.animation.Animation.save","title":"<code>save(out_name, x_margin=0.1, y_margin=0.1)</code>","text":"<p>Saves the animation to an HTML file.</p> <p>This method generates an animation from the stored data, configures the plot axes, and saves the animation as an HTML file. It prepares the visualization by setting axis limits based on the data and specified margins, then creates and saves the animation. Existing files with the same name are removed to prevent conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the Animation class.</p> required <code>out_name</code> <code>str</code> <p>The base name for the output HTML file (without extension).</p> required <code>x_margin</code> <code>float</code> <p>The margin to add to the x-axis limits. Defaults to 0.1.</p> <code>0.1</code> <code>y_margin</code> <code>float</code> <p>The margin to add to the y-axis limits. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/animation.py</code> <pre><code>def save(self, out_name, x_margin=0.1, y_margin=0.1):\n    \"\"\"\n    Saves the animation to an HTML file.\n\n    This method generates an animation from the stored data, configures the plot axes,\n    and saves the animation as an HTML file. It prepares the visualization by setting\n    axis limits based on the data and specified margins, then creates and saves the animation.\n    Existing files with the same name are removed to prevent conflicts.\n\n    Args:\n        self: The instance of the Animation class.\n        out_name (str): The base name for the output HTML file (without extension).\n        x_margin (float, optional): The margin to add to the x-axis limits. Defaults to 0.1.\n        y_margin (float, optional): The margin to add to the y-axis limits. Defaults to 0.1.\n\n    Returns:\n        None\n    \"\"\"\n    (fig, axes) = plt.subplots()\n    plots = [axes.plot([], [])[0] for _ in self.x[0]]\n    axes.set_xlim(*lim(self.x, x_margin))\n    axes.set_ylim(*lim(self.y, y_margin))\n\n    def update(frame):\n        for (plot, x, y) in zip(plots, self.x[frame], self.y[frame]):\n            plot.set_data(x, y)\n        return plots\n\n    ani = animation.FuncAnimation(fig=fig, func=update, frames=len(self.x),\n                                  interval=self.interval * 1000)\n    shutil.rmtree(f'{out_name}_frames', ignore_errors=True)\n    ani.save(filename=f'{out_name}.html', writer=\"html\")\n</code></pre>"},{"location":"solvers/surface_optimizer/src/animation/#solvers.surface_optimizer.src.animation.Animation.update","title":"<code>update(lines)</code>","text":"<p>Updates the internal data with new lines, sampling points if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the class.</p> required <code>lines</code> <p>A list of tuples, where each tuple contains two lists representing x and y coordinates.</p> required <p>This method processes incoming coordinate data by selectively adding sampled points to maintain a manageable data size while preserving the overall trend. It calculates a sampling interval based on the desired maximum number of points and the length of the input data, ensuring that the data remains representative without becoming excessively large.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the class.</p> required <code>lines</code> <code>list</code> <p>A list of tuples, where each tuple contains two lists representing x and y coordinates.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/animation.py</code> <pre><code>def update(self, lines):\n    \"\"\"\n    Updates the internal data with new lines, sampling points if necessary.\n\n    Args:\n        self: The instance of the class.\n        lines: A list of tuples, where each tuple contains two lists representing x and y coordinates.\n\n    This method processes incoming coordinate data by selectively adding sampled points\n    to maintain a manageable data size while preserving the overall trend. It calculates\n    a sampling interval based on the desired maximum number of points and the length\n    of the input data, ensuring that the data remains representative without becoming\n    excessively large.\n\n    Args:\n        self: The instance of the class.\n        lines (list): A list of tuples, where each tuple contains two lists representing x and y coordinates.\n\n    Returns:\n        None\n    \"\"\"\n    if self.i % self.step == 0:\n        xs = []\n        ys = []\n        for (x, y) in lines:\n            step = math.ceil(len(x) / self.max_points)\n            xs.append(x[::step].copy())\n            ys.append(y[::step].copy())\n        self.x.append(xs)\n        self.y.append(ys)\n    self.i += 1\n</code></pre>"},{"location":"solvers/surface_optimizer/src/animation/#solvers.surface_optimizer.src.animation.lim","title":"<code>lim(a, margin)</code>","text":"<p>Adjusts the display range of data to provide better visualization.</p> <p>This method calculates a new minimum and maximum value based on the input array and a given margin. It expands the range to ensure important features are visible without clipping, improving data interpretability.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The input array of numerical data.</p> required <code>margin</code> <code>float</code> <p>The margin as a percentage of the original range.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the new minimum and maximum values (min_val, max_val).</p> Source code in <code>solvers/surface_optimizer/src/animation.py</code> <pre><code>def lim(a, margin):\n    \"\"\"\n    Adjusts the display range of data to provide better visualization.\n\n    This method calculates a new minimum and maximum value based on the input array\n    and a given margin. It expands the range to ensure important features are visible\n    without clipping, improving data interpretability.\n\n    Args:\n        a (numpy.ndarray): The input array of numerical data.\n        margin (float): The margin as a percentage of the original range.\n\n    Returns:\n        tuple: A tuple containing the new minimum and maximum values (min_val, max_val).\n    \"\"\"\n    min_ = np.min(a)\n    max_ = np.max(a)\n    m = margin * (max_ - min_)\n    return (min_ - m, max_ + m)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/fire/","title":"Fire","text":""},{"location":"solvers/surface_optimizer/src/fire/#solvers.surface_optimizer.src.fire.FIRE","title":"<code>FIRE</code>","text":"Implements Fast Inertial Relaxation Engine optimization algorithm Source code in <code>solvers/surface_optimizer/src/fire.py</code> <pre><code>class FIRE:\n    \"\"\"\n    Implements Fast Inertial Relaxation Engine optimization algorithm:\n        https://arxiv.org/abs/1908.02038\n    \"\"\"\n\n\n    def __init__(self, neg_grad, initial_guess, dt_max):\n        \"\"\"\n        Initializes an instance of the class.\n\n        Args:\n            neg_grad (callable): A function that returns the negative gradient of the potential.\n            initial_guess (ndarray): The initial guess for the optimization.\n            dt_max (float): The maximum step size.\n\n        Initializes the following object properties:\n            dt_max (float): The maximum step size.\n            dt (float): The current step size, initialized to dt_max / 10.\n            n_pos (int): A counter for positive definite steps, initialized to 0.\n            alpha (float): A parameter controlling step size adjustment, initialized to 0.25.\n            x (ndarray): The current position, initialized to the initial guess.\n            v (ndarray): The current velocity, initialized to a zero array with the same shape as the initial guess.\n            neg_grad (callable): The negative gradient function.\n            f (ndarray): The force, initialized to the negative gradient at the initial guess.\n\n        Returns:\n            None\n        \"\"\"\n        self.dt_max = dt_max\n        self.dt = dt_max / 10\n        self.n_pos = 0\n        self.alpha = 0.25\n        self.x = initial_guess\n        self.v = zeros_like(initial_guess)\n        self.neg_grad = neg_grad\n        self.f = neg_grad(initial_guess)\n\n    def step(self):\n        \"\"\"\n        Steps the optimization process forward.\n\n        Updates the position, velocity, and step size based on the current gradient to efficiently navigate towards a minimum. The method dynamically adjusts parameters to accelerate convergence when moving in a consistent direction and dampens oscillations when encountering resistance.\n\n        Args:\n            self: The instance of the FIRE class.\n\n        Returns:\n            None\n\n        Class Fields Initialized:\n            n_pos: Counter for consecutive positive dot products of velocity and gradient, influencing step size.\n            dt: The step size, adjusted based on optimization progress.\n            alpha: The momentum factor, controlling the influence of past velocities.\n            v: The velocity vector, updated with gradient information.\n            x: The current position vector, representing the optimized parameters.\n            f: The current gradient vector, indicating the direction of steepest ascent.\n        \"\"\"\n        f_norm = norm(self.f)\n        if f_norm == 0.0:\n            return\n\n        if dot(self.v.ravel(), self.f.ravel()) &gt; 0:\n            self.n_pos += 1\n            if self.n_pos &gt; 20:\n                self.dt = min(self.dt * 1.1, self.dt_max)\n                self.alpha *= 0.99\n        else:\n            self.n_pos = 0\n            self.v = zeros_like(self.v)\n            self.dt = self.dt / 2\n            self.alpha = 0.25\n\n        self.v += 0.5 * self.dt * self.f\n        f_dir = self.f / f_norm\n        self.v = (1 - self.alpha) * self.v + self.alpha * norm(self.v) * f_dir\n        self.x += self.dt * self.v\n        self.f = self.neg_grad(self.x)\n        self.v += 0.5 * self.dt * self.f\n\n    def solution(self):\n        \"\"\"\n        Returns the x-coordinate of the current point.\n\n        Args:\n            self: The instance of the FIRE class.\n\n        Returns:\n            int: The x-coordinate value.\n        \"\"\"\n        return self.x\n</code></pre>"},{"location":"solvers/surface_optimizer/src/fire/#solvers.surface_optimizer.src.fire.FIRE.__init__","title":"<code>__init__(neg_grad, initial_guess, dt_max)</code>","text":"<p>Initializes an instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>neg_grad</code> <code>callable</code> <p>A function that returns the negative gradient of the potential.</p> required <code>initial_guess</code> <code>ndarray</code> <p>The initial guess for the optimization.</p> required <code>dt_max</code> <code>float</code> <p>The maximum step size.</p> required Initializes the following object properties <p>dt_max (float): The maximum step size. dt (float): The current step size, initialized to dt_max / 10. n_pos (int): A counter for positive definite steps, initialized to 0. alpha (float): A parameter controlling step size adjustment, initialized to 0.25. x (ndarray): The current position, initialized to the initial guess. v (ndarray): The current velocity, initialized to a zero array with the same shape as the initial guess. neg_grad (callable): The negative gradient function. f (ndarray): The force, initialized to the negative gradient at the initial guess.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/fire.py</code> <pre><code>def __init__(self, neg_grad, initial_guess, dt_max):\n    \"\"\"\n    Initializes an instance of the class.\n\n    Args:\n        neg_grad (callable): A function that returns the negative gradient of the potential.\n        initial_guess (ndarray): The initial guess for the optimization.\n        dt_max (float): The maximum step size.\n\n    Initializes the following object properties:\n        dt_max (float): The maximum step size.\n        dt (float): The current step size, initialized to dt_max / 10.\n        n_pos (int): A counter for positive definite steps, initialized to 0.\n        alpha (float): A parameter controlling step size adjustment, initialized to 0.25.\n        x (ndarray): The current position, initialized to the initial guess.\n        v (ndarray): The current velocity, initialized to a zero array with the same shape as the initial guess.\n        neg_grad (callable): The negative gradient function.\n        f (ndarray): The force, initialized to the negative gradient at the initial guess.\n\n    Returns:\n        None\n    \"\"\"\n    self.dt_max = dt_max\n    self.dt = dt_max / 10\n    self.n_pos = 0\n    self.alpha = 0.25\n    self.x = initial_guess\n    self.v = zeros_like(initial_guess)\n    self.neg_grad = neg_grad\n    self.f = neg_grad(initial_guess)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/fire/#solvers.surface_optimizer.src.fire.FIRE.solution","title":"<code>solution()</code>","text":"<p>Returns the x-coordinate of the current point.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the FIRE class.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The x-coordinate value.</p> Source code in <code>solvers/surface_optimizer/src/fire.py</code> <pre><code>def solution(self):\n    \"\"\"\n    Returns the x-coordinate of the current point.\n\n    Args:\n        self: The instance of the FIRE class.\n\n    Returns:\n        int: The x-coordinate value.\n    \"\"\"\n    return self.x\n</code></pre>"},{"location":"solvers/surface_optimizer/src/fire/#solvers.surface_optimizer.src.fire.FIRE.step","title":"<code>step()</code>","text":"<p>Steps the optimization process forward.</p> <p>Updates the position, velocity, and step size based on the current gradient to efficiently navigate towards a minimum. The method dynamically adjusts parameters to accelerate convergence when moving in a consistent direction and dampens oscillations when encountering resistance.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the FIRE class.</p> required <p>Returns:</p> Type Description <p>None</p> Class Fields Initialized Source code in <code>solvers/surface_optimizer/src/fire.py</code> <pre><code>def step(self):\n    \"\"\"\n    Steps the optimization process forward.\n\n    Updates the position, velocity, and step size based on the current gradient to efficiently navigate towards a minimum. The method dynamically adjusts parameters to accelerate convergence when moving in a consistent direction and dampens oscillations when encountering resistance.\n\n    Args:\n        self: The instance of the FIRE class.\n\n    Returns:\n        None\n\n    Class Fields Initialized:\n        n_pos: Counter for consecutive positive dot products of velocity and gradient, influencing step size.\n        dt: The step size, adjusted based on optimization progress.\n        alpha: The momentum factor, controlling the influence of past velocities.\n        v: The velocity vector, updated with gradient information.\n        x: The current position vector, representing the optimized parameters.\n        f: The current gradient vector, indicating the direction of steepest ascent.\n    \"\"\"\n    f_norm = norm(self.f)\n    if f_norm == 0.0:\n        return\n\n    if dot(self.v.ravel(), self.f.ravel()) &gt; 0:\n        self.n_pos += 1\n        if self.n_pos &gt; 20:\n            self.dt = min(self.dt * 1.1, self.dt_max)\n            self.alpha *= 0.99\n    else:\n        self.n_pos = 0\n        self.v = zeros_like(self.v)\n        self.dt = self.dt / 2\n        self.alpha = 0.25\n\n    self.v += 0.5 * self.dt * self.f\n    f_dir = self.f / f_norm\n    self.v = (1 - self.alpha) * self.v + self.alpha * norm(self.v) * f_dir\n    self.x += self.dt * self.v\n    self.f = self.neg_grad(self.x)\n    self.v += 0.5 * self.dt * self.f\n</code></pre>"},{"location":"solvers/surface_optimizer/src/format/","title":"Format","text":""},{"location":"solvers/surface_optimizer/src/format/#solvers.surface_optimizer.src.format.best_unit","title":"<code>best_unit(x, units)</code>","text":"<p>Finds the index of the largest unit in <code>units</code> that is less than or equal to <code>x</code>. This allows for selecting the most appropriate scale or level of detail for a given value.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The value to compare against the units.</p> required <code>units</code> <code>list of tuple</code> <p>A list of tuples, where each tuple contains a unit value (float) and its label (str).</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The index of the largest unit less than or equal to x.  Returns the last index if x is greater than or equal to all unit values.</p> Source code in <code>solvers/surface_optimizer/src/format.py</code> <pre><code>def best_unit(x, units):\n    \"\"\"\n    Finds the index of the largest unit in `units` that is less than or equal to `x`. This allows for selecting the most appropriate scale or level of detail for a given value.\n\n    Args:\n        x (float): The value to compare against the units.\n        units (list of tuple): A list of tuples, where each tuple contains a unit value (float) and its label (str).\n\n    Returns:\n        int: The index of the largest unit less than or equal to x.  Returns the last index if x is greater than or equal to all unit values.\n    \"\"\"\n    i = 0\n    while i + 1 &lt; len(units) and x &gt;= units[i + 1][0]:\n        i += 1\n    return i\n</code></pre>"},{"location":"solvers/surface_optimizer/src/format/#solvers.surface_optimizer.src.format.fmt","title":"<code>fmt(x, units)</code>","text":"<p>Formats a numerical value by scaling it to the most appropriate unit.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The numerical value to format.</p> required <code>units</code> <code>list of tuples</code> <p>A list of tuples, where each tuple contains a scaling factor and a unit string.                       For example: [(1, 'm'), (1000, 'mm'), (1000000, '\u00b5m')]</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string representing the formatted value with units, rounded to two decimal places.</p> Source code in <code>solvers/surface_optimizer/src/format.py</code> <pre><code>def fmt(x, units):\n    \"\"\"\n    Formats a numerical value by scaling it to the most appropriate unit.\n\n    Args:\n        x (float): The numerical value to format.\n        units (list of tuples): A list of tuples, where each tuple contains a scaling factor and a unit string. \n                                 For example: [(1, 'm'), (1000, 'mm'), (1000000, '\u00b5m')]\n\n    Returns:\n        str: A string representing the formatted value with units, rounded to two decimal places.\n    \"\"\"\n    i = best_unit(x, units)\n    return f'{x / units[i][0]:.2f} {units[i][1]}'\n</code></pre>"},{"location":"solvers/surface_optimizer/src/format/#solvers.surface_optimizer.src.format.sizefmt","title":"<code>sizefmt(x)</code>","text":"<p>Formats a number into a human-readable string, using appropriate units for clarity.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or int</code> <p>The numerical value to be formatted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the number with a suitable size unit appended.</p> Source code in <code>solvers/surface_optimizer/src/format.py</code> <pre><code>def sizefmt(x):\n    \"\"\"\n    Formats a number into a human-readable string, using appropriate units for clarity.\n\n    Args:\n        x (float or int): The numerical value to be formatted.\n\n    Returns:\n        str: A string representation of the number with a suitable size unit appended.\n    \"\"\"\n    return fmt(x, size_units)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/format/#solvers.surface_optimizer.src.format.tfmt","title":"<code>tfmt(t)</code>","text":"<p>Transforms a time value into a formatted string representing nanoseconds.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>The time value in seconds to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The formatted time string, scaled to nanoseconds and using the <code>time_units</code> format.</p> Source code in <code>solvers/surface_optimizer/src/format.py</code> <pre><code>def tfmt(t):\n    \"\"\"\n    Transforms a time value into a formatted string representing nanoseconds.\n\n    Args:\n        t (float): The time value in seconds to format.\n\n    Returns:\n        str: The formatted time string, scaled to nanoseconds and using the `time_units` format.\n    \"\"\"\n    return fmt(t * 1e9, time_units)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/","title":"Lc","text":""},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver","title":"<code>LcpSolver</code>","text":"<p>Solves the least common parent problem using optimization.</p> <pre><code>Attributes:\n    optimizer: The optimizer object used for solving the optimization problem.\n    n_steps: The number of optimization steps taken.\n    error_history: A tuple containing lists to store the error history during optimization.\n</code></pre> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>class LcpSolver:\n    \"\"\"\n    Solves the least common parent problem using optimization.\n\n        Attributes:\n            optimizer: The optimizer object used for solving the optimization problem.\n            n_steps: The number of optimization steps taken.\n            error_history: A tuple containing lists to store the error history during optimization.\n    \"\"\"\n\n    def __init__(self, a, b, initial_guess=None, device='cpu'):\n        \"\"\"\n        Initializes the optimization problem for solving a laser-induced heat transfer problem.\n\n        Args:\n            a: The coefficients representing the material properties and laser parameters for the Fourier transform. Must be non-positive.\n            b: The constant term representing the background temperature or heat source.\n            initial_guess: The initial temperature distribution as a tensor. If None, defaults to a tensor of zeros.\n            device: The device to use for computations ('cpu' or 'gpu').\n\n        Initializes the following object properties:\n            self.optimizer: The FIRE optimizer object used for finding the temperature distribution.\n            self.n_steps: An integer representing the number of optimization steps taken, initialized to 0.\n            self.error_history: A tuple containing two lists to store the error history during optimization.\n\n        Returns:\n            None\n        \"\"\"\n        assert np.all(a &lt;= 0)\n\n        a = torch.tensor(a, device=device)\n        b = torch.tensor(b, device=device)\n\n        min_period = 2 * np.pi * torch.max(-a).item() ** -0.5\n        dt = min_period / 8\n\n        if initial_guess is None:\n            initial_guess = torch.zeros_like(b)\n        else:\n            initial_guess = torch.tensor(initial_guess, device=device)\n\n        def neg_grad(x):\n            torch.nn.functional.relu(x, inplace=True)\n            f = torch.fft.irfftn(a * torch.fft.rfftn(x), b.shape) + b\n            f[torch.logical_and(x == 0, f &lt; 0)] = 0\n            return f\n\n        self.optimizer = FIRE(neg_grad, initial_guess, dt_max=dt)\n        self.n_steps = 0\n\n        self.error_history = ([], [])\n        self.update_error_history()\n\n    def update_error_history(self):\n        \"\"\"\n        Updates the error history during the iterative solving process.\n\n        Periodically records the step number and corresponding error value to track the convergence \n        and performance of the solution. This allows for monitoring the optimization process and \n        assessing the accuracy of the results over time.\n\n        Args:\n            self: The instance of the LcpSolver class.\n\n        Returns:\n            None\n        \"\"\"\n        if self.n_steps % 10 == 0:\n            self.error_history[0].append(self.n_steps)\n            self.error_history[1].append(self.error())\n\n    def error(self):\n        \"\"\"\n        Calculates the root mean square (RMS) of the objective function values obtained during optimization.\n\n        Args:\n            self: The instance of the LcpSolver class.\n\n        Returns:\n            float: The RMS value of the objective function.  This represents a measure of the overall discrepancy between the model's predictions and the observed data during the optimization process.\n        \"\"\"\n        return rms(self.optimizer.f)\n\n    def step(self):\n        \"\"\"\n        Performs a single optimization step to refine the solution.\n\n        Updates the model's parameters to minimize the error, tracks the error evolution,\n        and increments the step counter for monitoring progress.\n\n        Args:\n            self: The instance of the LcpSolver class.\n\n        Returns:\n            None\n        \"\"\"\n        self.optimizer.step()\n        self.update_error_history()\n        self.n_steps += 1\n\n    def solution(self):\n        \"\"\"\n        Retrieves the optimal solution determined by the solver.\n\n        Args:\n            self: The instance of the LcpSolver class.\n\n        Returns:\n            numpy.ndarray: The optimal solution as a NumPy array, \n                           representing the result of the optimization process.\n        \"\"\"\n        return self.optimizer.solution().cpu().numpy()\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver.__init__","title":"<code>__init__(a, b, initial_guess=None, device='cpu')</code>","text":"<p>Initializes the optimization problem for solving a laser-induced heat transfer problem.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>The coefficients representing the material properties and laser parameters for the Fourier transform. Must be non-positive.</p> required <code>b</code> <p>The constant term representing the background temperature or heat source.</p> required <code>initial_guess</code> <p>The initial temperature distribution as a tensor. If None, defaults to a tensor of zeros.</p> <code>None</code> <code>device</code> <p>The device to use for computations ('cpu' or 'gpu').</p> <code>'cpu'</code> Initializes the following object properties <p>self.optimizer: The FIRE optimizer object used for finding the temperature distribution. self.n_steps: An integer representing the number of optimization steps taken, initialized to 0. self.error_history: A tuple containing two lists to store the error history during optimization.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def __init__(self, a, b, initial_guess=None, device='cpu'):\n    \"\"\"\n    Initializes the optimization problem for solving a laser-induced heat transfer problem.\n\n    Args:\n        a: The coefficients representing the material properties and laser parameters for the Fourier transform. Must be non-positive.\n        b: The constant term representing the background temperature or heat source.\n        initial_guess: The initial temperature distribution as a tensor. If None, defaults to a tensor of zeros.\n        device: The device to use for computations ('cpu' or 'gpu').\n\n    Initializes the following object properties:\n        self.optimizer: The FIRE optimizer object used for finding the temperature distribution.\n        self.n_steps: An integer representing the number of optimization steps taken, initialized to 0.\n        self.error_history: A tuple containing two lists to store the error history during optimization.\n\n    Returns:\n        None\n    \"\"\"\n    assert np.all(a &lt;= 0)\n\n    a = torch.tensor(a, device=device)\n    b = torch.tensor(b, device=device)\n\n    min_period = 2 * np.pi * torch.max(-a).item() ** -0.5\n    dt = min_period / 8\n\n    if initial_guess is None:\n        initial_guess = torch.zeros_like(b)\n    else:\n        initial_guess = torch.tensor(initial_guess, device=device)\n\n    def neg_grad(x):\n        torch.nn.functional.relu(x, inplace=True)\n        f = torch.fft.irfftn(a * torch.fft.rfftn(x), b.shape) + b\n        f[torch.logical_and(x == 0, f &lt; 0)] = 0\n        return f\n\n    self.optimizer = FIRE(neg_grad, initial_guess, dt_max=dt)\n    self.n_steps = 0\n\n    self.error_history = ([], [])\n    self.update_error_history()\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver.error","title":"<code>error()</code>","text":"<p>Calculates the root mean square (RMS) of the objective function values obtained during optimization.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the LcpSolver class.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The RMS value of the objective function.  This represents a measure of the overall discrepancy between the model's predictions and the observed data during the optimization process.</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def error(self):\n    \"\"\"\n    Calculates the root mean square (RMS) of the objective function values obtained during optimization.\n\n    Args:\n        self: The instance of the LcpSolver class.\n\n    Returns:\n        float: The RMS value of the objective function.  This represents a measure of the overall discrepancy between the model's predictions and the observed data during the optimization process.\n    \"\"\"\n    return rms(self.optimizer.f)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver.solution","title":"<code>solution()</code>","text":"<p>Retrieves the optimal solution determined by the solver.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the LcpSolver class.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The optimal solution as a NumPy array,             representing the result of the optimization process.</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def solution(self):\n    \"\"\"\n    Retrieves the optimal solution determined by the solver.\n\n    Args:\n        self: The instance of the LcpSolver class.\n\n    Returns:\n        numpy.ndarray: The optimal solution as a NumPy array, \n                       representing the result of the optimization process.\n    \"\"\"\n    return self.optimizer.solution().cpu().numpy()\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver.step","title":"<code>step()</code>","text":"<p>Performs a single optimization step to refine the solution.</p> <p>Updates the model's parameters to minimize the error, tracks the error evolution, and increments the step counter for monitoring progress.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the LcpSolver class.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def step(self):\n    \"\"\"\n    Performs a single optimization step to refine the solution.\n\n    Updates the model's parameters to minimize the error, tracks the error evolution,\n    and increments the step counter for monitoring progress.\n\n    Args:\n        self: The instance of the LcpSolver class.\n\n    Returns:\n        None\n    \"\"\"\n    self.optimizer.step()\n    self.update_error_history()\n    self.n_steps += 1\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.LcpSolver.update_error_history","title":"<code>update_error_history()</code>","text":"<p>Updates the error history during the iterative solving process.</p> <p>Periodically records the step number and corresponding error value to track the convergence  and performance of the solution. This allows for monitoring the optimization process and  assessing the accuracy of the results over time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>The instance of the LcpSolver class.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def update_error_history(self):\n    \"\"\"\n    Updates the error history during the iterative solving process.\n\n    Periodically records the step number and corresponding error value to track the convergence \n    and performance of the solution. This allows for monitoring the optimization process and \n    assessing the accuracy of the results over time.\n\n    Args:\n        self: The instance of the LcpSolver class.\n\n    Returns:\n        None\n    \"\"\"\n    if self.n_steps % 10 == 0:\n        self.error_history[0].append(self.n_steps)\n        self.error_history[1].append(self.error())\n</code></pre>"},{"location":"solvers/surface_optimizer/src/lcp/#solvers.surface_optimizer.src.lcp.rms","title":"<code>rms(x)</code>","text":"<p>Calculates the Root Mean Square (RMS) of a tensor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The RMS value of the tensor.</p> Source code in <code>solvers/surface_optimizer/src/lcp.py</code> <pre><code>def rms(x):\n    \"\"\"\n    Calculates the Root Mean Square (RMS) of a tensor.\n\n    Args:\n      x (torch.Tensor): The input tensor.\n\n    Returns:\n      float: The RMS value of the tensor.\n    \"\"\"\n    return torch.sqrt(torch.mean(x ** 2)).item()\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/","title":"Sim","text":""},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.freq","title":"<code>freq(n, d)</code>","text":"<p>Computes the magnitude of the frequency spectrum for a 2D signal.</p> <p>Calculates the frequency components present in a signal based on its dimensions and sampling distance. This is useful for analyzing the spatial frequencies within the signal, which can reveal important information about its structure and characteristics.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int or list/tuple of int</code> <p>Dimensions of the signal.  A single integer represents a 1D signal, while a list/tuple of two integers represents a 2D signal (rows, columns).</p> required <code>d</code> <code>float</code> <p>Sample distance.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>The magnitude of the frequency spectrum.  Represents the strength of each frequency component in the signal.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def freq(n, d):\n    \"\"\"\n    Computes the magnitude of the frequency spectrum for a 2D signal.\n\n    Calculates the frequency components present in a signal based on its\n    dimensions and sampling distance. This is useful for analyzing the\n    spatial frequencies within the signal, which can reveal important\n    information about its structure and characteristics.\n\n    Args:\n        n (int or list/tuple of int): Dimensions of the signal.  A single\n            integer represents a 1D signal, while a list/tuple of two\n            integers represents a 2D signal (rows, columns).\n        d (float): Sample distance.\n\n    Returns:\n        ndarray: The magnitude of the frequency spectrum.  Represents the\n            strength of each frequency component in the signal.\n    \"\"\"\n    if len(n) == 1:\n        return rfftfreq(n[0], d)\n    xs = rfftfreq(n[1], d)\n    ys = fftfreq(n[0], d)\n    x, y = np.meshgrid(xs, ys, indexing='xy')\n    return np.sqrt(x * x + y * y)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.gap_to_z","title":"<code>gap_to_z(green_1, green_2, surface_1, gap)</code>","text":"<p>Transforms the input surface based on Green's functions and a gap function, then calculates the difference between the transformed surface and the original gap.</p> <p>Parameters:</p> Name Type Description Default <code>green_1</code> <code>array_like</code> <p>The first Green's function.</p> required <code>green_2</code> <code>array_like</code> <p>The second Green's function.</p> required <code>surface_1</code> <code>array_like</code> <p>The input surface data.</p> required <code>gap</code> <code>array_like</code> <p>The gap function representing a spatial distribution.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - The difference between the transformed surface and the gap (array_like). - The transformed surface (array_like).</p> <p>The method leverages Green's functions to modify the input surface, effectively modeling a physical response to an external influence represented by the gap function. This transformation is performed in the Fourier domain for efficiency, and the final result represents a refined surface accounting for the interaction between the initial surface, the gap, and the properties defined by the Green's functions.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def gap_to_z(green_1, green_2, surface_1, gap):\n    \"\"\"\n    Transforms the input surface based on Green's functions and a gap function, then calculates the difference between the transformed surface and the original gap.\n\n    Args:\n        green_1 (array_like): The first Green's function.\n        green_2 (array_like): The second Green's function.\n        surface_1 (array_like): The input surface data.\n        gap (array_like): The gap function representing a spatial distribution.\n\n    Returns:\n        tuple: A tuple containing:\n            - The difference between the transformed surface and the gap (array_like).\n            - The transformed surface (array_like).\n\n    The method leverages Green's functions to modify the input surface, effectively modeling a physical response to an external influence represented by the gap function. This transformation is performed in the Fourier domain for efficiency, and the final result represents a refined surface accounting for the interaction between the initial surface, the gap, and the properties defined by the Green's functions.\n    \"\"\"\n    with np.errstate(invalid='ignore'):\n        a = 1 / (1 + green_1 / green_2)\n    a.flat[0] = 0.0\n    z_2 = irfftn(a * rfftn(surface_1 + gap), gap.shape, range(gap.ndim))\n    return z_2 - gap, z_2\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.green_func_fourier","title":"<code>green_func_fourier(young, poisson, freq, thickness=np.inf)</code>","text":"<p>Computes the Green's function in Fourier space for a layered medium, representing the material's response to harmonic excitation.</p> <p>Parameters:</p> Name Type Description Default <code>young</code> <code>float</code> <p>Young's modulus of the material.</p> required <code>poisson</code> <code>float</code> <p>Poisson's ratio of the material.</p> required <code>freq</code> <code>float</code> <p>Frequency of the excitation.</p> required <code>thickness</code> <code>float</code> <p>Thickness of the layer. Defaults to infinity.</p> <code>inf</code> <p>Returns:</p> Type Description <p>numpy.ndarray: The Green's function in Fourier space, representing the displacement field due to a point force. The first element is set to 0.0 to avoid singularities.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def green_func_fourier(young, poisson, freq, thickness=np.inf):\n    \"\"\"\n    Computes the Green's function in Fourier space for a layered medium, representing the material's response to harmonic excitation.\n\n    Args:\n        young (float): Young's modulus of the material.\n        poisson (float): Poisson's ratio of the material.\n        freq (float): Frequency of the excitation.\n        thickness (float, optional): Thickness of the layer. Defaults to infinity.\n\n    Returns:\n        numpy.ndarray: The Green's function in Fourier space, representing the displacement field due to a point force. The first element is set to 0.0 to avoid singularities.\n    \"\"\"\n    with np.errstate(divide='ignore'):\n        result = 2 * (1 - poisson ** 2) / (young * 2 * pi * freq)\n    result.flat[0] = 0.0\n    return result * layer_factor(poisson, freq, thickness)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.inv","title":"<code>inv(x)</code>","text":"<p>Computes the inverse of an array, handling potential division by zero errors that can occur during data processing.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The input array.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: An array containing the inverse of the input array,</p> <p>with division by zero resulting in 0 to maintain numerical stability.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def inv(x):\n    \"\"\"\n    Computes the inverse of an array, handling potential division by zero errors that can occur during data processing.\n\n    Args:\n        x (numpy.ndarray): The input array.\n\n    Returns:\n        numpy.ndarray: An array containing the inverse of the input array,\n        with division by zero resulting in 0 to maintain numerical stability.\n    \"\"\"\n    with np.errstate(divide='ignore'):\n        x = 1 / x\n    return np.nan_to_num(x, 0, 0, 0)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.layer_factor","title":"<code>layer_factor(poisson, freq, thickness)</code>","text":"<p>Calculates the layer factor to determine how a wave propagates through a material layer.</p> <p>This function computes the layer factor based on the material's properties (Poisson's ratio),  the wave's frequency, and the layer's thickness. It's designed to accurately model wave  behavior, particularly in scenarios involving laser-material interactions, by accounting  for potential numerical issues and specific layer conditions.</p> <p>Parameters:</p> Name Type Description Default <code>poisson</code> <code>float</code> <p>Poisson's ratio of the material, representing its resistance to deformation.</p> required <code>freq</code> <code>float</code> <p>Frequency of the wave, determining its oscillatory rate.</p> required <code>thickness</code> <code>float</code> <p>Thickness of the material layer, influencing wave propagation.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The calculated layer factor, a value between 0 and 1 that indicates             the extent to which the wave is affected by the layer.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def layer_factor(poisson, freq, thickness):\n    \"\"\"\n    Calculates the layer factor to determine how a wave propagates through a material layer.\n\n    This function computes the layer factor based on the material's properties (Poisson's ratio), \n    the wave's frequency, and the layer's thickness. It's designed to accurately model wave \n    behavior, particularly in scenarios involving laser-material interactions, by accounting \n    for potential numerical issues and specific layer conditions.\n\n    Args:\n        poisson (float): Poisson's ratio of the material, representing its resistance to deformation.\n        freq (float): Frequency of the wave, determining its oscillatory rate.\n        thickness (float): Thickness of the material layer, influencing wave propagation.\n\n    Returns:\n        numpy.ndarray: The calculated layer factor, a value between 0 and 1 that indicates \n                       the extent to which the wave is affected by the layer.\n    \"\"\"\n    # https://doi.org/10.1093/qjmam/4.1.94\n    if thickness == np.inf:\n        return 1.0\n    a = 2 * pi * freq * thickness\n    b = 3 - 4 * poisson\n    with np.errstate(all='ignore'):\n        c = b * np.sinh(2 * a) - 2 * a\n        c /= b * np.cosh(2 * a) + 2 * a * a + b + 2 * (1 - 2 * poisson) ** 2\n    c[a &gt; 40] = 1\n    c.flat[0] = 1\n    return c\n</code></pre>"},{"location":"solvers/surface_optimizer/src/sim/#solvers.surface_optimizer.src.sim.solve","title":"<code>solve(pressure, length, surface_1, E1, nu1, E2, nu2, thickness_2=np.inf, maxiter=1000000, tol=1e-08, shear_str=None, use_cuda=False, initial_guess=None, log_output=False, dump_dir=None)</code>","text":"<p>Solves the contact problem between two elastic bodies under external pressure.</p> <p>This method determines the deformation and stress distribution resulting from the interaction of two elastic bodies subjected to a given pressure, leveraging Fourier transforms and a  Linear Complementarity Problem (LCP) solver. The solution provides insights into the  contact mechanics of the system.</p> <p>Parameters:</p> Name Type Description Default <code>pressure</code> <p>The external pressure applied to the bodies.</p> required <code>length</code> <p>The length of the bodies.</p> required <code>surface_1</code> <p>The shape of the first body's surface.</p> required <code>E1</code> <p>Young's modulus of the first body.</p> required <code>nu1</code> <p>Poisson's ratio of the first body.</p> required <code>E2</code> <p>Young's modulus of the second body.</p> required <code>nu2</code> <p>Poisson's ratio of the second body.</p> required <code>thickness_2</code> <p>The thickness of the second body (default is infinity).</p> <code>inf</code> <code>maxiter</code> <p>The maximum number of iterations for the LCP solver (default is 1000000).</p> <code>1000000</code> <code>tol</code> <p>The tolerance for the LCP solver (default is 1e-8).</p> <code>1e-08</code> <code>shear_str</code> <p>The shear strength (default is None).</p> <code>None</code> <code>use_cuda</code> <p>Whether to use CUDA for the LCP solver (default is False).</p> <code>False</code> <code>initial_guess</code> <p>The initial guess for the gap (default is None).</p> <code>None</code> <code>log_output</code> <p>Whether to print log output (default is False).</p> <code>False</code> <code>dump_dir</code> <p>The directory to dump the results to (default is None).</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary containing the results of the solution, including the mean gap,</p> <p>relative contact area, maximum stress, stress distribution, deformed surfaces,</p> <p>gap, and number of iterations. If shear strength is provided, the friction</p> <p>coefficient is also included. If a dump directory is provided, the results</p> <p>are saved to files in that directory.</p> Source code in <code>solvers/surface_optimizer/src/sim.py</code> <pre><code>def solve(\n        pressure,\n        length,\n        surface_1,\n        E1, nu1,\n        E2, nu2,\n        thickness_2=np.inf,\n        maxiter=1000000,\n        tol=1e-8,\n        shear_str=None,\n        use_cuda=False,\n        initial_guess=None,\n        log_output=False,\n        dump_dir=None,\n):\n    \"\"\"\n    Solves the contact problem between two elastic bodies under external pressure.\n\n    This method determines the deformation and stress distribution resulting from the interaction\n    of two elastic bodies subjected to a given pressure, leveraging Fourier transforms and a \n    Linear Complementarity Problem (LCP) solver. The solution provides insights into the \n    contact mechanics of the system.\n\n    Args:\n        pressure: The external pressure applied to the bodies.\n        length: The length of the bodies.\n        surface_1: The shape of the first body's surface.\n        E1: Young's modulus of the first body.\n        nu1: Poisson's ratio of the first body.\n        E2: Young's modulus of the second body.\n        nu2: Poisson's ratio of the second body.\n        thickness_2: The thickness of the second body (default is infinity).\n        maxiter: The maximum number of iterations for the LCP solver (default is 1000000).\n        tol: The tolerance for the LCP solver (default is 1e-8).\n        shear_str: The shear strength (default is None).\n        use_cuda: Whether to use CUDA for the LCP solver (default is False).\n        initial_guess: The initial guess for the gap (default is None).\n        log_output: Whether to print log output (default is False).\n        dump_dir: The directory to dump the results to (default is None).\n\n    Returns:\n        A dictionary containing the results of the solution, including the mean gap,\n        relative contact area, maximum stress, stress distribution, deformed surfaces,\n        gap, and number of iterations. If shear strength is provided, the friction\n        coefficient is also included. If a dump directory is provided, the results\n        are saved to files in that directory.\n    \"\"\"\n    shape = surface_1.shape\n    f = freq(shape, length / shape[-1])\n    ft_green_1 = green_func_fourier(E1, nu1, f)\n    ft_green_2 = green_func_fourier(E2, nu2, f, thickness_2)\n    ft_green_eff = ft_green_1 + ft_green_2\n\n    a = -inv(ft_green_eff)\n    b = irfftn(a * rfftn(surface_1), shape, range(len(shape))) - pressure\n\n    (a, b) = (a / -a.flat[1], b / -a.flat[1])\n    if initial_guess is None:\n        initial_guess = np.max(surface_1) - surface_1\n    device = 'cuda' if use_cuda else 'cpu'\n    lcp = LcpSolver(a, b, initial_guess=initial_guess, device=device)\n\n    t0 = time.perf_counter_ns()\n    success = False\n    start_str = f'P={pressure:.4},'\n\n    for i in range(maxiter):\n        if i % 20 == 0:\n            error = lcp.error()\n            if log_output:\n                print(start_str, f'step={i}, |F|={error:.2e}')\n            if error &lt; tol:\n                success = True\n                break\n        lcp.step()\n\n    if log_output:\n        if lcp.n_steps != 0:\n            total = time.perf_counter_ns() - t0\n            step = total / lcp.n_steps\n            print(start_str,\n                  f'{total / 1e9:.2} sec total, '\n                  f'{int(step / 1e3)} usec per step')\n        print(start_str, 'success' if success else 'failure')\n\n    gap = lcp.solution()\n    z_1, z_2 = gap_to_z(ft_green_1, ft_green_2, surface_1, gap)\n\n    stress = pressure + irfftn(inv(ft_green_2) * rfftn(z_2),\n                               shape, range(len(shape)))\n\n    result = {\n        'mean_gap': np.mean(gap),\n        'rel_contact_area': np.mean(gap &lt; 1e-14),\n        'max_stress': np.max(stress),\n        'stress': stress,\n        'body_1_surface': z_1,\n        'body_2_surface': z_2,\n        'gap': gap,\n        'n_steps': lcp.n_steps,\n    }\n    if shear_str is not None:\n        result['friction_coeff'] = (\n                result['rel_contact_area'] * shear_str / pressure)\n\n    if dump_dir is not None:\n        path = pathlib.Path(dump_dir)\n        path.mkdir(exist_ok=True, parents=True)\n        x = np.linspace(0, length, shape[0], endpoint=False)\n        if len(shape) == 2:\n            (x, y) = np.meshgrid(x, x)\n            np.savetxt(path / 'y.txt', y)\n        np.savetxt(path / 'x.txt', x)\n        np.savetxt(path / 'z1.txt', result['body_1_surface'])\n        np.savetxt(path / 'z2.txt', result['body_2_surface'])\n        np.savetxt(path / 'stress.txt', result['stress'])\n\n    return result\n</code></pre>"},{"location":"solvers/surface_optimizer/src/test/","title":"Test","text":""},{"location":"solvers/surface_optimizer/src/test/#solvers.surface_optimizer.src.test.benchmark_fft","title":"<code>benchmark_fft(size, device, use_threads=True)</code>","text":"<p>Benchmarks the performance of the real-valued fast Fourier transform (rFFT) operation.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <p>The size of the input tensor (tuple of integers).</p> required <code>device</code> <p>The device on which to perform the FFT (e.g., 'cpu', 'cuda').</p> required <code>use_threads</code> <p>Whether to utilize multiple threads during the FFT computation. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>None. Prints the benchmark results, including execution time, to the console.</p> Source code in <code>solvers/surface_optimizer/src/test.py</code> <pre><code>def benchmark_fft(size, device, use_threads=True):\n    \"\"\"\n    Benchmarks the performance of the real-valued fast Fourier transform (rFFT) operation.\n\n    Args:\n        size: The size of the input tensor (tuple of integers).\n        device: The device on which to perform the FFT (e.g., 'cpu', 'cuda').\n        use_threads: Whether to utilize multiple threads during the FFT computation. Defaults to True.\n\n    Returns:\n        None. Prints the benchmark results, including execution time, to the console.\n    \"\"\"\n    a = torch.randn(size, device=device, dtype=torch.float64)\n    num_threads = torch.get_num_threads() if use_threads else 1\n    t = benchmark.Timer(stmt='torch.fft.rfftn(a)', globals={'a': a},\n                        num_threads=num_threads)\n    print(t.blocked_autorange())\n</code></pre>"},{"location":"solvers/surface_optimizer/src/test/#solvers.surface_optimizer.src.test.benchmark_step","title":"<code>benchmark_step(shape, device, use_threads=True)</code>","text":"<p>Benchmarks the performance of a single step within the LcpSolver.</p> <p>This function measures the time taken to execute one step of the LcpSolver,  providing insights into its computational efficiency. It generates random input  data for the solver and utilizes benchmarking tools to assess performance  with and without multi-threading.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>The shape of the input array used to generate test data.</p> required <code>device</code> <code>str</code> <p>The device (e.g., 'cpu', 'cuda') on which the solver operates.</p> required <code>use_threads</code> <code>bool</code> <p>If True, utilizes multiple threads during the benchmark.                             Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>None. Prints the benchmark results, including execution time, to the console.</p> Source code in <code>solvers/surface_optimizer/src/test.py</code> <pre><code>def benchmark_step(shape, device, use_threads=True):\n    \"\"\"\n    Benchmarks the performance of a single step within the LcpSolver.\n\n    This function measures the time taken to execute one step of the LcpSolver, \n    providing insights into its computational efficiency. It generates random input \n    data for the solver and utilizes benchmarking tools to assess performance \n    with and without multi-threading.\n\n    Args:\n        shape (tuple): The shape of the input array used to generate test data.\n        device (str): The device (e.g., 'cpu', 'cuda') on which the solver operates.\n        use_threads (bool, optional):  If True, utilizes multiple threads during the benchmark. \n                                       Defaults to True.\n\n    Returns:\n        None. Prints the benchmark results, including execution time, to the console.\n    \"\"\"\n    b = np.random.random(shape)\n    a = -np.random.random(np.fft.rfftn(b).shape)\n    solver = LcpSolver(a, b, device=device)\n    num_threads = torch.get_num_threads() if use_threads else 1\n    t = benchmark.Timer(stmt='solver.step()', globals={'solver': solver},\n                        num_threads=num_threads)\n    print(t.blocked_autorange())\n</code></pre>"},{"location":"solvers/surface_optimizer/src/test/#solvers.surface_optimizer.src.test.rms","title":"<code>rms(x)</code>","text":"<p>Calculates the Root Mean Square (RMS) of a tensor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The RMS value of the tensor.</p> Source code in <code>solvers/surface_optimizer/src/test.py</code> <pre><code>def rms(x):\n    \"\"\"\n    Calculates the Root Mean Square (RMS) of a tensor.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n\n    Returns:\n        float: The RMS value of the tensor.\n    \"\"\"\n    return torch.sqrt(torch.mean(x ** 2)).item()\n</code></pre>"},{"location":"solvers/surface_optimizer/src/test/#solvers.surface_optimizer.src.test.test","title":"<code>test()</code>","text":"<p>Tests the solve function with various input parameters and validates the results.</p> <p>This method executes the <code>solve</code> function with a set of predefined parameters representing physical properties and boundary conditions. It then verifies that the returned <code>mean_gap</code> and <code>max_stress</code> values fall within acceptable ranges, ensuring the accuracy of the underlying physical model. Different parameter combinations are used to cover a range of scenarios and validate the robustness of the solution.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvers/surface_optimizer/src/test.py</code> <pre><code>def test():\n    \"\"\"\n    Tests the solve function with various input parameters and validates the results.\n\n    This method executes the `solve` function with a set of predefined parameters\n    representing physical properties and boundary conditions. It then verifies\n    that the returned `mean_gap` and `max_stress` values fall within acceptable\n    ranges, ensuring the accuracy of the underlying physical model. Different\n    parameter combinations are used to cover a range of scenarios and validate\n    the robustness of the solution.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    nx = 2 ** 7\n    ny = 2 ** 7\n    x = np.linspace(-0.5, 0.5, nx, endpoint=False)\n    y = np.linspace(-0.5, 0.5, ny, endpoint=False)\n    length = 1.0\n    (x, y) = np.meshgrid(x, y, indexing='xy')\n    surface_1 = -0.5 * (x * x + y * y)\n\n    result = solve(pressure=0.2, length=length,\n                   surface_1=surface_1, E1=1e7, nu1=0.5,\n                   E2=3.0, nu2=0.25, thickness_2=50.0)\n    assert np.isclose(result['mean_gap'], 0.0245015)\n\n    result = solve(pressure=0.2, length=length,\n                   surface_1=surface_1, E1=(2 * 3.0), nu1=0.25,\n                   E2=(2 * 3.0), nu2=0.25, thickness_2=50.0)\n\n    assert np.isclose(result['max_stress'], 0.78204305)\n    assert np.isclose(result['mean_gap'], 0.0245015)\n\n    result = solve(pressure=0.2, length=length,\n                   surface_1=surface_1, E1=1e7, nu1=0.25,\n                   E2=3.0, nu2=0.25, thickness_2=0.25)\n\n    assert np.isclose(result['mean_gap'], 0.0324626)\n    assert np.isclose(result['max_stress'], 0.978424)\n    result = solve(pressure=0.2, length=length,\n                   surface_1=surface_1, E1=1e7, nu1=0.25,\n                   E2=3.0, nu2=0.25, thickness_2=0.25)\n\n    assert np.isclose(result['mean_gap'], 0.0324626)\n    assert np.isclose(result['max_stress'], 0.978424)\n\n    x = np.linspace(-0.5, 0.5, 128, endpoint=False)\n    surface_1 = -0.5 * (x * x)\n    result = solve(pressure=0.2, length=length,\n                   surface_1=surface_1, E1=1e7, nu1=0.25,\n                   E2=3.0, nu2=0.25, thickness_2=100.0)\n    assert np.isclose(result['mean_gap'], 0.0132305)\n</code></pre>"},{"location":"solvers/surface_optimizer/src/test/#solvers.surface_optimizer.src.test.test_fire","title":"<code>test_fire()</code>","text":"<p>Tests the FIRE optimization algorithm on the Rosenbrock function.</p> <pre><code>This method sets the default PyTorch data type to float64, defines the\nRosenbrock function's negative gradient, initializes a FIRE optimizer,\nand runs the optimization for a maximum of 3000 steps. It prints the\nRMS error at each step and breaks if the error falls below a threshold.\nThe algorithm iteratively refines an initial guess towards a minimum of the Rosenbrock function.\n\nArgs:\n    None\n\nReturns:\n    None\n</code></pre> Source code in <code>solvers/surface_optimizer/src/test.py</code> <pre><code>def test_fire():\n    \"\"\"\n    Tests the FIRE optimization algorithm on the Rosenbrock function.\n\n        This method sets the default PyTorch data type to float64, defines the\n        Rosenbrock function's negative gradient, initializes a FIRE optimizer,\n        and runs the optimization for a maximum of 3000 steps. It prints the\n        RMS error at each step and breaks if the error falls below a threshold.\n        The algorithm iteratively refines an initial guess towards a minimum of the Rosenbrock function.\n\n        Args:\n            None\n\n        Returns:\n            None\n    \"\"\"\n    torch.set_default_dtype(torch.float64)\n    a = 1.0\n    b = 100.0\n\n    def rosenbrock_neg_grad(xy):\n        (x, y) = xy\n        return torch.tensor([2 * (a - x) + 4 * b * (y - x * x) * x,\n                             2 * b * (x * x - y)])\n\n    optimizer = FIRE(rosenbrock_neg_grad, torch.tensor([3.0, 4.0]),\n                     dt_max=0.02)\n    for i in range(3000):\n        optimizer.step()\n        d = rms(optimizer.solution() - torch.tensor([1.0, 1.0]))\n        print(i + 1, f'{d :.20e}')\n        if d &lt; 1e-8:\n            break\n</code></pre>"}]}